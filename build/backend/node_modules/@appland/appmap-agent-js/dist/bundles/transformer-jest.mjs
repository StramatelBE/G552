import { cwd } from 'node:process';
import { createRequire } from 'node:module';
import { platform } from 'node:os';
import { pathToFileURL, URL as URL$3, fileURLToPath } from 'node:url';
import { win32, posix } from 'node:path';
import { readFile as readFile$1 } from 'node:fs/promises';
import { openSync, writeSync, readFileSync } from 'node:fs';
import { Buffer } from 'node:buffer';
import * as Astring from 'astring';
import { decode } from 'vlq';
import BabelParser from '@babel/parser';
import 'minimatch';
import { createHash } from 'node:crypto';
import { Socket } from 'node:net';
import NetSocketMessaging from 'net-socket-messaging';

const { Error: Error$6 } = globalThis;

class AssertionError extends Error$6 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const {
  Boolean,
  String: String$6,
  Number,
  parseInt: parseInt$2,
  Array: { isArray: isArray$4 },
  Number: {
    isNaN,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER,
    MIN_SAFE_INTEGER,
  },
  Math: { round },
  JSON: { stringify: stringifyJSON$4 },
} = globalThis;

const print = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$4(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$4(any);
  } else {
    return String$6(any);
  }
};

const {
  Error: Error$5,
  String: String$5,
  JSON: { stringify: stringifyJSON$3 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$3(value);
      }
      if (marker === "O") {
        try {
          return String$5(value);
        } catch {
          return print(value);
        }
      }
      if (marker === "o") {
        return print(value);
      }
      throw new Error$5("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const createCounter = (value) => ({ value });

const {
  Error: Error$4,
  Reflect: { apply },
  WeakMap: WeakMap$1,
} = globalThis;

new WeakMap$1();

const noop = () => {};

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const mapMaybe = (maybe, transform) =>
  maybe === null ? null : transform(maybe);

const {
  undefined: undefined$6,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$3, ownKeys: ownKeys$2, defineProperty: defineProperty$1 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$3(Object$1, "hasOwn") === undefined$6
    ? (object, key) => getOwnPropertyDescriptor$3(object, key) !== undefined$6
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

const {
  undefined: undefined$5,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2 },
  Error: Error$3,
  Set: Set$1,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$2(obj, key) !== undefined$5,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set$1([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error$3("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$4,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1 },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor$1(obj, key) !== undefined$4,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const { decodeURIComponent: decodeURIComponent$1, encodeURIComponent: encodeURIComponent$1 } = globalThis;

const getDrive = (protocol, pathname) =>
  protocol.toLowerCase() === "file:"
    ? /^\/[a-zA-Z]:\//u.test(pathname)
      ? pathname[1].toLowerCase()
      : null
    : null;

const normalizeCase = (pathname, drive) =>
  drive === null ? pathname : pathname.toLowerCase();

const toAbsoluteUrl = (relative, base_url) =>
  new URL$3(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toRelativeUrl = (
  url,
  base_url,
  encodeSegment = encodeURIComponent$1,
) => {
  const { protocol, host, pathname, search, hash } = new URL$3(url);
  const {
    protocol: base_protocol,
    host: base_host,
    pathname: base_pathname,
  } = new URL$3(base_url);
  if (
    protocol.toLowerCase() !== base_protocol.toLowerCase() ||
    host.toLowerCase() !== base_host.toLowerCase()
  ) {
    return null;
  } else {
    const drive = getDrive(protocol, pathname);
    const base_drive = getDrive(base_protocol, base_pathname);
    if (drive !== base_drive) {
      return null;
    } else {
      const segments = normalizeCase(pathname, drive)
        .split("/")
        .map(decodeURIComponent$1);
      const base_segments = normalizeCase(base_pathname, base_drive)
        .split("/")
        .map(decodeURIComponent$1);
      base_segments.pop();
      while (
        segments.length > 0 &&
        base_segments.length > 0 &&
        segments[0] === base_segments[0]
      ) {
        segments.shift();
        base_segments.shift();
      }
      while (base_segments.length > 0) {
        base_segments.pop();
        segments.unshift("..");
      }
      if (segments.length > 0 && segments[0] !== "") {
        return `${segments.map(encodeSegment).join("/")}${search}${hash}`;
      } else {
        return `.${search}${hash}`;
      }
    }
  }
};

const toDirectoryUrl = (url) => {
  const url_obj = new URL$3(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Alternatively:
//   url.match(/:\/{0,2}.*\/([^/#]+)(#.*)?$/)[1]
const getUrlFilename = (url) => {
  const { pathname } = new URL$3(url);
  if (pathname === "" || pathname.endsWith("/")) {
    return null;
  } else {
    return pathname.substring(pathname.lastIndexOf("/") + 1);
  }
};

// Alternatively:
//   url.match(/([^.\/]+)(\.[^/#]*)(#.*)?$/)[1]
const getUrlBasename = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(0, filename.indexOf("."));
  } else {
    return filename;
  }
};

const prefixDot = (string) => `.${string}`;

const getUrlExtensionArray = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else {
    const extensions = filename.split(".");
    extensions.shift();
    return extensions.map(prefixDot);
  }
};

// Alternatively:
//   url.match(/([^\/]+)(\.[^/#]*)(#.*)?$/)[2]
const getLastUrlExtension = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(filename.lastIndexOf("."));
  } else {
    return null;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$2,
  JSON: { parse: parseJSON$1 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$1(
  await readFile$1(
    new URL$2(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$2 } = globalThis;

class AppmapError extends Error$2 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$3,
  ReferenceError,
  Reflect: { defineProperty },
} = globalThis;

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$1 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$1(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$1 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$1(fd, "DEBUG"),
    logInfo: generateLog$1(fd, "INFO"),
    logWarning: generateLog$1(fd, "WARNING"),
    logError: generateLog$1(fd, "ERROR"),
  };
};

const { logDebug: logDebug$1, logInfo, logWarning: logWarning$1, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

const { log: logDebug, logWhen: logDebugWhen } = generateLog(
  "debug",
  logDebug$1,
);

generateLog(
  "info",
  logInfo,
);

const { log: logWarning, logWhen: logWarningWhen } = generateLog(
  "warning",
  logWarning$1,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const { Error: Error$1, decodeURIComponent, URL } = globalThis;

const { from: toBuffer } = Buffer;

const splitDataPath = (path) => {
  const index = path.indexOf(",");
  return {
    head: path.substring(0, index),
    body: path.substring(index + 1),
  };
};

const generateReadFile = (readFile) => (url) => {
  const url_obj = new URL(url);
  if (url_obj.protocol === "file:") {
    return readFile(url_obj, "utf8");
  } else if (url_obj.protocol === "data:") {
    const { head, body } = splitDataPath(url_obj.pathname);
    if (head.endsWith(";base64")) {
      logDebugWhen(
        !head.toLowerCase().includes(";charset=utf-8;") &&
          !head.toLowerCase().includes(";charset=utf8;"),
        "Data url is encoded as base64 and does not declare UTF-8 as its character encoding, will try to use UTF-8 anyway >> %s",
        url,
      );
      return toBuffer(body, "base64").toString("utf8");
    } else {
      return decodeURIComponent(body);
    }
  } else {
    // This file is meant to be used at the same
    //   abstraction level as a node library.
    // Hence, this is delibearately left as an unknown error.
    // ie: not an External/Internal AppmapError.
    throw new Error$1("unsupported protocol");
  }
};

const readFile = generateReadFile(readFileSync);

const validateSourceMap = noop;

const {
  JSON: { parse: parseJSON },
} = globalThis;

const extractSourcemapUrl = ({ url, content }) => {
  const parts = /\/\/[#@] sourceMappingURL=(.*)[\s]*$/u.exec(content);
  if (parts === null) {
    return null;
  } else {
    return toAbsoluteUrl(parts[1], url);
  }
};

const parseSourcemapJson = ({ url, content }) => {
  try {
    return parseJSON(content);
  } catch (error) {
    logWarning("Could not parse source map at %j >> %O", url, error);
    return null;
  }
};

const isSourcemapValid = ({ url, data }) => {
  try {
    validateSourceMap(data);
    return true;
  } catch (error) {
    logWarning("Invalid source map at %j >> %O", url, error);
    return false;
  }
};

const parseSourcemap = (file, base) => {
  const { url } = file;
  const data = parseSourcemapJson(file);
  if (data === null || !isSourcemapValid({ url, data })) {
    return null;
  } else {
    const {
      sourceRoot: root,
      sources: relatives,
      sourcesContent: contents,
      mappings: payload,
    } = {
      sourceRoot: null,
      sourcesContent: null,
      ...data,
    };
    if (!url.startsWith("data:")) {
      base = url;
    }
    if (root !== null && root !== "") {
      base = toDirectoryUrl(toAbsoluteUrl(root, url));
    }
    return {
      sources: relatives.map((relative, index) => ({
        url: toAbsoluteUrl(relative, base),
        content:
          contents === null || index >= contents.length
            ? null
            : contents[index],
      })),
      payload,
    };
  }
};

const compileSourcemap = (payload) => {
  let source_index = 0;
  let source_line = 0;
  let source_column = 0;
  return payload.split(";").map((group) => {
    if (group === "") {
      return [];
    } else {
      let generated_column = 0;
      return group.split(",").map((segment) => {
        const fields = decode(segment);
        /* c8 ignore start */ if (fields.length === 1) {
          return [(generated_column += fields[0])];
        } /* c8 ignore stop */ else {
          return [
            (generated_column += fields[0]),
            (source_index += fields[1]),
            (source_line += fields[2]),
            (source_column += fields[3]),
          ];
        }
      });
    }
  });
};

const mapPosition = (mapping, { line, column }) => {
  if (line > 0 && line <= mapping.length) {
    for (const fields of mapping[line - 1]) {
      if (fields[0] === column && fields.length >= 4) {
        const [, source_index, mapped_line, mapped_column] = fields;
        return {
          index: source_index,
          position: {
            line: mapped_line + 1,
            column: mapped_column,
          },
        };
      }
    }
    return null;
  } else {
    return null;
  }
};

const { parse: parseBabel } = BabelParser;

const getLeadingCommentArray = (node) =>
  coalesce(node, "leadingComments", []);

const trimStartString = (string) => string.trimStart();

const extractLineLabel = (line) => {
  assert(line.startsWith("@label "), "invalid label line", InternalAppmapError);
  const maybe_tokens = line.substring("@label".length).match(/\s+\S+/gu);
  return maybe_tokens === null ? [] : maybe_tokens.map(trimStartString);
};

const extractCommentLabelArray = ({ value: text }) => {
  const maybe_lines = text.match(/@label .*/gu);
  return maybe_lines === null ? [] : maybe_lines.flatMap(extractLineLabel);
};

const resolveSource = (source, { url }) => {
  if (source === null) {
    const extension = getLastUrlExtension(url);
    if (extension === ".cjs" || extension === ".cts" || extension === ".node") {
      return "script";
    } else if (extension === ".mjs" || extension === ".mts") {
      return "module";
    } else {
      return "unambiguous";
    }
  } else {
    return source;
  }
};

const resolvePluginArray = (plugins, { url, content }) => {
  if (plugins === null) {
    const extensions = getUrlExtensionArray(url);
    const plugins = [];
    if (extensions.includes(".jsx")) {
      plugins.push(["jsx", {}]);
    }
    if (
      extensions.includes(".ts") ||
      extensions.includes(".mts") ||
      extensions.includes(".cts")
    ) {
      plugins.push(["typescript", {}]);
    }
    if (
      extensions.includes(".tsx") ||
      extensions.includes(".mtsx") ||
      extensions.includes(".ctsx")
    ) {
      plugins.push(["jsx", {}], ["typescript", {}]);
    }
    if (
      extensions.includes(".flow") ||
      /^[ \t\n]*\/(\/[ \t]*|\*[ \t\n]*)@flow/u.test(content)
    ) {
      plugins.push(["flow", {}]);
    }
    return plugins;
  } else {
    return plugins;
  }
};

const parseSafe = ({ url, content }, options) => {
  try {
    return parseBabel(content, options);
  } catch (error) {
    logError("Unrecoverable parsing error at file %j >> %O", url, error);
    const { sourceType: source_type } = options;
    return {
      errors: [],
      program: {
        type: "Program",
        body: [],
        sourceType: source_type === "unambiguous" ? "script" : source_type,
        loc: {
          start: { line: 0, column: 0 },
          end: { line: 0, column: 0 },
          filename: url,
        },
      },
    };
  }
};

const parseEstree = (file, { source, plugins }) => {
  const { url } = file;
  const { errors, program: node } = parseSafe(file, {
    sourceFilename: url,
    sourceType: resolveSource(source, file),
    plugins: [
      ["estree", { classFeatures: true }],
      ...resolvePluginArray(plugins, file),
    ],
    errorRecovery: true,
    attachComment: true,
  });
  for (const error of errors) {
    logWarning("Recoverable parsing error at file %j >> %O", url, error);
  }
  return node;
};

const {
  String: String$4,
  parseInt: parseInt$1,
  Infinity: Infinity$1,
  Math: { abs },
} = globalThis;

const stringifyPosition = ({ line, column }) =>
  `${String$4(line)}:${String$4(column)}`;

const parsePosition = (string) => {
  const parts = /^([0-9]+):([0-9]+)$/u.exec(string);
  assert(parts !== null, "invalid position format", InternalAppmapError);
  return {
    line: parseInt$1(parts[1]),
    column: parseInt$1(parts[2]),
  };
};

const measurePositionDistance = (
  { line: line1, column: column1 },
  { line: line2, column: column2 },
  { line_weight, column_weight },
) => line_weight * abs(line2 - line1) + column_weight * abs(column2 - column1);

const resolvePosition = (map, position1, options) => {
  const key1 = stringifyPosition(position1);
  if (map.has(key1)) {
    return position1;
  } else {
    let best_distance = Infinity$1;
    let best_position = null;
    for (const key2 of map.keys()) {
      const position2 = parsePosition(key2);
      const distance = measurePositionDistance(position1, position2, options);
      if (distance < best_distance) {
        best_distance = distance;
        best_position = position2;
      }
    }
    const { threshold } = options;
    return best_distance <= threshold ? best_position : null;
  }
};

/* eslint-disable no-use-before-define */

const {
  Object: { entries: toEntries$3 },
  Array: { isArray: isArray$3 },
} = globalThis;

const ANONYMOUS = "[anonymous]";

const DYNAMIC = "[dynamic]";

const getBoundary = ({ start, end }) => ({ start, end });

const getHead = ({ head }) => head;

const getRest = ({ rest }) => rest;

const combine = (results) => ({
  head: results.flatMap(getHead),
  rest: results.flatMap(getRest),
});

const isContainerNodeType = (type) =>
  type === "FunctionExpression" ||
  type === "FunctionDeclaration" ||
  type === "ArrowFunctionExpression" ||
  type === "ClassExpression" ||
  type === "ClassDeclaration" ||
  type === "ObjectExpression";

const getContainerName = (node, name) => {
  if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
    return name === ANONYMOUS && node.id !== null ? node.id.name : name;
  } else if (
    node.type === "FunctionDeclaration" ||
    node.type === "ClassDeclaration"
  ) {
    return node.id === null ? "default" : node.id.name;
  } else if (
    node.type === "ArrowFunctionExpression" ||
    node.type === "ObjectExpression"
  ) {
    return name;
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid container node");
  } /* c8 ignore stop */
};

/////////////
// factory //
/////////////

const createFileEntity = (name, children, node) => ({
  type: "file",
  excluded: false,
  labels: getLeadingCommentArray(node).flatMap(extractCommentLabelArray),
  name,
  children,
});

const createClassEntity = (name, children, node) => ({
  type: "class",
  excluded: false,
  labels: getLeadingCommentArray(node).flatMap(extractCommentLabelArray),
  name,
  children,
});

const createClosureEntity = (name, children, node, is_static) => {
  const comments = getLeadingCommentArray(node);
  return {
    type: "closure",
    excluded: false,
    name,
    children,
    used: false,
    static: is_static,
    comments,
    labels: comments.flatMap(extractCommentLabelArray),
    parameters: node.params.map(getBoundary),
    boundary: getBoundary(node),
    position: { ...node.loc.start }, // cleanup prototype
  };
};

/////////////
// visitor //
/////////////

const visitProgram = (node, name) => {
  if (node.type === "Program") {
    return createFileEntity(
      name,
      node.body.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      node,
    );
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid program node");
  } /* c8 ignore stop */
};

const visitAny = (any) => {
  if (isArray$3(any)) {
    return any.flatMap(visitAny);
  } else if (
    typeof any === "object" &&
    any !== null &&
    hasOwnProperty(any, "type") &&
    typeof any.type === "string"
  ) {
    return visitNode$1(any, ANONYMOUS);
  } else {
    return [];
  }
};

const visitContainerNode = (node, name) => {
  if (
    node.type === "FunctionExpression" ||
    node.type === "FunctionDeclaration" ||
    node.type === "ArrowFunctionExpression"
  ) {
    return {
      head: [
        createClosureEntity(
          getContainerName(node, name),
          [
            ...node.params.flatMap((child) => visitNode$1(child, ANONYMOUS)),
            ...visitNode$1(node.body, ANONYMOUS),
          ],
          node,
          false,
        ),
      ],
      rest: [],
    };
  } else if (
    node.type === "ClassExpression" ||
    node.type === "ClassDeclaration"
  ) {
    const { head, rest } = visitClassBody(node.body);
    return {
      head: [createClassEntity(getContainerName(node, name), head, node)],
      rest: [
        ...(node.superClass === null
          ? []
          : visitNode$1(node.superClass, ANONYMOUS)),
        ...rest,
      ],
    };
  } else if (node.type === "ObjectExpression") {
    const { head, rest } = combine(node.properties.map(visitObjectProperty));
    return {
      head: [createClassEntity(getContainerName(node, name), head, node)],
      rest,
    };
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid container node type");
  } /* c8 ignore stop */
};

const visitEntry = ([key, value]) => {
  if (key === "type" || key === "start" || key === "end" || key === "loc") {
    return [];
  } else {
    return visitAny(value);
  }
};

const visitNode$1 = (node, name) => {
  if (node.type === "AssignmentExpression") {
    return [
      ...visitNode$1(node.left, ANONYMOUS),
      ...visitNode$1(
        node.right,
        node.left.type === "Identifier" ? node.left.name : ANONYMOUS,
      ),
    ];
  } else if (node.type === "VariableDeclarator") {
    return [
      ...visitNode$1(node.id, ANONYMOUS),
      ...(node.init === null
        ? []
        : visitNode$1(
            node.init,
            node.id.type === "Identifier" ? node.id.name : ANONYMOUS,
          )),
    ];
  } else if (node.type === "ConditionalExpression") {
    return [
      ...visitNode$1(node.test, ANONYMOUS),
      ...visitNode$1(node.consequent, name),
      ...visitNode$1(node.alternate, name),
    ];
  } else if (node.type === "SequenceExpression") {
    const children = node.expressions.slice();
    const last_child = children.pop();
    return [
      ...children.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      ...visitNode$1(last_child, name),
    ];
  } else if (node.type === "LogicalExpression") {
    return [...visitNode$1(node.left, name), ...visitNode$1(node.right, name)];
  } else if (isContainerNodeType(node.type)) {
    const { head, rest } = visitContainerNode(node, name);
    return [...head, ...rest];
  } else {
    return toEntries$3(node).flatMap(visitEntry);
  }
};

const visitClassBody = (node) => {
  if (node.type === "ClassBody") {
    return combine(node.body.map(visitClassProperty));
  } /* c8 ignore start */ else {
    logWarning("unrecognized class body node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitClassProperty = (node) => {
  if (node.type === "MethodDefinition") {
    return {
      rest: visitNode$1(node.key, ANONYMOUS),
      head: visitClassMethod(
        node.value,
        !node.computed && node.key.type === "Identifier"
          ? node.key.name
          : DYNAMIC,
        node.static,
      ),
    };
  } else if (node.type === "PropertyDefinition") {
    return combine([
      { head: [], rest: visitNode$1(node.key, ANONYMOUS) },
      node.value === null
        ? { head: [], rest: [] }
        : visitPropertyValue(
            node.value,
            !node.computed && node.key.type === "Identifier"
              ? node.key.name
              : DYNAMIC,
          ),
    ]);
  } /* c8 ignore start */ else {
    logWarning("unrecognized class property node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitClassMethod = (node, name, is_static) => {
  if (node.type === "FunctionExpression") {
    return createClosureEntity(
      name,
      [
        ...node.params.flatMap((child) => visitNode$1(child, ANONYMOUS)),
        .../* typescript abstract method */
        (hasOwnProperty(node, "body") && node.body !== null
          ? visitNode$1(node.body, ANONYMOUS)
          : []),
      ],
      node,
      is_static,
    );
  } /* c8 ignore start */ else {
    logWarning("unrecognized class method node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitObjectProperty = (node) => {
  if (node.type === "Property") {
    return combine([
      { head: [], rest: visitNode$1(node.key, ANONYMOUS) },
      visitPropertyValue(
        node.value,
        !node.computed && node.key.type === "Identifier"
          ? node.key.name
          : DYNAMIC,
      ),
    ]);
  } else if (node.type === "SpreadElement") {
    return {
      head: [],
      rest: visitNode$1(node.argument, ANONYMOUS),
    };
  } /* c8 ignore start */ else {
    logWarning("unrecognized object property node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitPropertyValue = (node, name) => {
  if (node.type === "LogicalExpression") {
    return combine([
      visitPropertyValue(node.left, name),
      visitPropertyValue(node.right, name),
    ]);
  } else if (node.type === "ConditionalExpression") {
    return combine([
      { head: [], rest: visitNode$1(node.test, ANONYMOUS) },
      visitPropertyValue(node.consequent, name),
      visitPropertyValue(node.alternate, name),
    ]);
  } else if (node.type === "SequenceExpression") {
    const children = node.expressions.slice();
    const last_child = children.pop();
    return combine([
      {
        head: [],
        rest: children.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      },
      visitPropertyValue(last_child, name),
    ]);
  } else if (isContainerNodeType(node.type)) {
    return visitContainerNode(node, name);
  } else {
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  }
};

////////////
// export //
////////////

const toEntity = visitProgram;

const {
  RegExp: RegExp$2,
  Object: { entries: toEntries$2 },
} = globalThis;

const compileClause = ([name, pattern]) => {
  if (typeof pattern === "boolean") {
    return (_node, _naming) => pattern;
  } else if (typeof pattern === "string") {
    const regexp = new RegExp$2(pattern, "u");
    const predicate = (string) => regexp.test(string);
    if (name === "name") {
      return (entity, _parent) => predicate(entity.name);
    } else if (name === "qualified-name") {
      return (entity, parent) =>
        predicate(
          entity.type === "closure"
            ? `${parent.name}${entity.static ? "#" : "."}${entity.name}`
            : entity.name,
        );
    } else if (name === "some-label") {
      return (entity, _parent) => entity.labels.some(predicate);
    } else if (name === "every-label") {
      return (entity, _parent) => entity.labels.every(predicate);
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid clause name");
    } /* c8 ignore stop */
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid clause pattern type");
  } /* c8 ignore stop */
};

const compileClauseArray = (combinator, clauses) => {
  const predicates = toEntries$2(clauses).map(compileClause);
  if (combinator === "and") {
    return (node, naming) =>
      predicates.every((predicate) => predicate(node, naming));
  } else if (combinator === "or") {
    return (node, naming) =>
      predicates.some((predicate) => predicate(node, naming));
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid exclusion combinator");
  } /* c8 ignore stop */
};

const compileCriterion = ({ combinator, excluded, recursive, ...clauses }) => {
  const predicate = compileClauseArray(combinator, clauses);
  const spec = { excluded, recursive };
  return (node, naming) => (predicate(node, naming) ? spec : null);
};

const compileCriteria = (criteria) => {
  const closures = criteria.map(compileCriterion);
  return (node, naming) => {
    for (const closure of closures) {
      const maybe_spec = closure(node, naming);
      if (maybe_spec !== null) {
        return maybe_spec;
      }
    }
    throw new InternalAppmapError("missing matching exclusion criterion");
  };
};

const { Map: Map$3, String: String$3 } = globalThis;

const getChild = (object, index) => object.children[index];

////////////
// Create //
////////////

const registerClosure = (entity, path, closures) => {
  if (entity.type === "closure") {
    closures.set(stringifyPosition(entity.position), path);
  }
  const { length } = entity.children;
  for (let index = 0; index < length; index += 1) {
    registerClosure(
      entity.children[index],
      `${path}/${String$3(index)}`,
      closures,
    );
  }
};

const registerClosureRoot = (entity) => {
  assert(
    entity.type === "file",
    "root entity should be a file",
    InternalAppmapError,
  );
  const closures = new Map$3();
  const { length } = entity.children;
  for (let index = 0; index < length; index += 1) {
    registerClosure(entity.children[index], String$3(index), closures);
  }
  return closures;
};

const createSource$1 = ({ url, content, program }) => {
  const entity = toEntity(program, getUrlBasename(url));
  return {
    url,
    content,
    program,
    root: entity,
    closures: registerClosureRoot(entity),
  };
};

/////////////
// Exclude //
/////////////

const excludeEntityDeeply = (entity, excluded) => {
  entity.excluded = excluded;
  for (const child of entity.children) {
    excludeEntityDeeply(child, excluded);
  }
};

const excludeEntity = (entity, parent, exclude) => {
  const { excluded, recursive } = exclude(entity, parent);
  if (recursive) {
    excludeEntityDeeply(entity, excluded);
  } else {
    entity.excluded = excluded;
    for (const child of entity.children) {
      excludeEntity(child, entity, exclude);
    }
  }
};

const applyExclusionCriteria = ({ root }, criteria) => {
  excludeEntity(root, null, compileCriteria(criteria));
};

///////////
// Query //
///////////

const LINE_WEIGHT = 1024;
const COLUMN_WEIGHT = 1;
const THRESHOLD = 10 * LINE_WEIGHT;

const DISTANCE_OPTIONS = {
  line_weight: LINE_WEIGHT,
  column_weight: COLUMN_WEIGHT,
  threshold: THRESHOLD,
};

const resolveClosurePosition = ({ closures }, position) =>
  resolvePosition(closures, position, DISTANCE_OPTIONS);

const isClosurePositionExcluded = ({ closures, root }, position) => {
  const key = stringifyPosition(position);
  assert(closures.has(key), "missing closure", InternalAppmapError);
  return closures.get(key).split("/").reduce(getChild, root).excluded;
};

const { Map: Map$2, RegExp: RegExp$1 } = globalThis;

const regexps = new Map$2();

const makeRegExp = (source, flags) => {
  try {
    return new RegExp$1(source, flags);
  } catch (error) {
    logError(
      "Failed to compile regexp source %j with flags %j >> %O",
      source,
      flags,
      error,
    );
    throw new ExternalAppmapError("Failed to compile matcher regexp");
  }
};

const makeRegExpCache = (source, flags) => {
  const key = `/${source}/${flags}`;
  if (regexps.has(key)) {
    return regexps.get(key);
  } else {
    const regexp = makeRegExp(source, flags);
    regexps.set(key, regexp);
    return regexp;
  }
};

// We escape as few character as possible to hide the fact that configuration fields are urls rather than paths.
const escaping = {
  __proto__: null,
  "/": "%2F",
  "?": "%3F",
  "#": "%23",
};

const escapeCharacter = (match) => escaping[match];

const escapeSegment = (segment) => segment.replace(/[/#?]/gu, escapeCharacter);

const matchUrl = (matcher, url) => {
  const { base, source, flags } = matcher;
  if (base === null) {
    const matched = makeRegExpCache(source, flags).test(url);
    logDebug(
      "url %j %s absolute regexp matcher %j with flags %j",
      url,
      matched ? "matched" : "did not match",
      source,
      flags,
    );
    return matched;
  } else {
    const relative = toRelativeUrl(url, base, escapeSegment);
    if (relative === null) {
      logDebug(
        "could not apply matcher %j because %j cannot be expressed relatively to %j, will treat it as not matched",
        source,
        url,
        base,
      );
      return false;
    } else {
      const matched = makeRegExpCache(source, flags).test(relative);
      logDebug(
        "url %j which resolves to %j relatively to %j %s relative regexp matcher %j with flags %j",
        url,
        relative,
        base,
        matched ? "matched" : "did not match",
        source,
        flags,
      );
      return matched;
    }
  }
};

const lookupUrl = (entries, url, default_value) => {
  for (const [matcher, value] of entries) {
    if (matchUrl(matcher, url)) {
      return value;
    }
  }
  return default_value;
};

const digest = (string) => {
  const hash = createHash("sha256");
  hash.update(string, "utf8");
  return hash.digest("base64");
};

const createSource = (
  { url, content },
  {
    packages: package_matcher_array,
    exclude: global_criteria,
    "default-package": default_package,
    "postmortem-function-exclusion": postmortem,
  },
) => {
  const {
    enabled,
    exclude: local_criteria,
    "source-type": source,
    parsing: plugins,
  } = lookupUrl(package_matcher_array, url, default_package);
  if (enabled) {
    return {
      postmortem,
      enabled: true,
      parsing: { source, plugins },
      criteria: [...local_criteria, ...global_criteria],
      url,
      content,
      hash: null,
      program: null,
      inner: null,
    };
  } else {
    return {
      postmortem,
      enabled: false,
      parsing: { source, plugins },
      criteria: [],
      url,
      content,
      hash: null,
      program: null,
      inner: null,
    };
  }
};

/////////////////////////
// Lazy Initialization //
/////////////////////////

const parseSource = (source) => {
  if (source.program === null) {
    const { url, content, parsing } = source;
    const program = parseEstree({ url, content }, parsing);
    source.program = program;
    return program;
  } else {
    return source.program;
  }
};

const digestSourceContent = (source) => {
  const { content } = source;
  if (source.hash === null && content !== null) {
    const hash = digest(content);
    source.hash = hash;
    return hash;
  } else {
    return source.hash;
  }
};

const toInnerSource = (source) => {
  if (source.inner === null) {
    const { url, content, criteria } = source;
    const program = parseSource(source);
    const inner = createSource$1({ url, content, program });
    applyExclusionCriteria(inner, criteria);
    source.inner = inner;
    return inner;
  } else {
    return source.inner;
  }
};

///////////
// Query //
///////////

const isSourceEnabled = ({ enabled }) => enabled;

const getSourceFile = ({ url, content }) => ({ url, content });

const isSourceContentRequired = ({ enabled, postmortem }) =>
  enabled && postmortem === false;

const isSourcePostmortemExclusion = ({
  postmortem,
  content,
  program,
}) => {
  if (content === null) {
    return true;
  } else if (typeof postmortem === "boolean") {
    return postmortem;
  } else {
    // If the program is already parsed,
    // it reduces of excluding functions here.
    return program === null;
  }
};

const resolveClosureLocation$1 = (source, position) => {
  const { enabled, url } = source;
  if (enabled) {
    if (isSourcePostmortemExclusion(source)) {
      return {
        url,
        hash: digestSourceContent(source),
        position,
      };
    } else {
      const maybe_resolved_position = resolveClosurePosition(
        toInnerSource(source),
        position,
      );
      if (
        maybe_resolved_position === null ||
        isClosurePositionExcluded(
          toInnerSource(source),
          maybe_resolved_position,
        )
      ) {
        return null;
      } else {
        return {
          url,
          hash: digestSourceContent(source),
          position: maybe_resolved_position,
        };
      }
    }
  } else {
    return null;
  }
};

const getUrl = ({ url }) => url;

const extractMissingUrlArray = (url, cache, configuration) => {
  if (cache.has(url)) {
    const content = cache.get(url);
    if (content === null) {
      return [];
    } else {
      const file = { url, content };
      const map_url = extractSourcemapUrl(file);
      if (map_url === null) {
        return [];
      } else {
        if (cache.has(map_url)) {
          const map_content = cache.get(map_url);
          if (map_content === null) {
            return [];
          } else {
            const map_file = {
              url: map_url,
              content: map_content,
            };
            const sourcemap = parseSourcemap(map_file, url);
            if (sourcemap === null) {
              return [];
            } else {
              const { sources } = sourcemap;
              return sources
                .filter(
                  ({ url, content }) =>
                    content === null &&
                    !cache.has(url) &&
                    isSourceContentRequired(
                      createSource({ url, content }, configuration),
                    ),
                )
                .map(getUrl);
            }
          }
        } else {
          return [map_url];
        }
      }
    }
  } else {
    return [url];
  }
};

const loadSourcemap = (file, cache, configuration) => {
  const map_url = extractSourcemapUrl(file);
  if (map_url === null) {
    return null;
  } else {
    const { url } = file;
    if (cache.has(map_url)) {
      const map_content = cache.get(map_url);
      if (map_content === null) {
        return null;
      } else {
        const map_file = {
          url: map_url,
          content: map_content,
        };
        const sourcemap = parseSourcemap(map_file, url);
        if (sourcemap === null) {
          return null;
        } else {
          const { sources, payload } = sourcemap;
          return {
            mapping: compileSourcemap(payload),
            sources: sources.map(({ url, content }) =>
              createSource(
                {
                  url,
                  content:
                    content === null && cache.has(url)
                      ? cache.get(url)
                      : content,
                },
                configuration,
              ),
            ),
          };
        }
      }
    } else {
      return null;
    }
  }
};

const createCodebase = (url, cache, configuration) => {
  assert(cache.has(url), "missing main content", InternalAppmapError);
  const content = cache.get(url);
  assert(
    !logErrorWhen(
      content === null,
      "Cannot not instrument file %j because it could not be loaded",
      url,
    ),
    "missing main content",
    ExternalAppmapError,
  );
  const file = { url, content };
  return {
    main: createSource(file, configuration),
    sourcemap: loadSourcemap(file, cache, configuration),
  };
};

const getEnabledSourceFileArray = ({ main, sourcemap }) =>
  (sourcemap === null ? [main] : sourcemap.sources)
    .filter(isSourceEnabled)
    .map(getSourceFile);

const getMainFile = ({ main }) => getSourceFile(main);

const parseMain = ({ main }) => parseSource(main);

const resolveClosureLocation = ({ main, sourcemap }, position) => {
  if (sourcemap === null) {
    return resolveClosureLocation$1(main, position);
  } else {
    const { sources, mapping } = sourcemap;
    const maybe_indexed_position = mapPosition(mapping, position);
    if (maybe_indexed_position === null) {
      // This is fine, it happens when compilation introduces new functions.
      // eg:
      // ```js
      //   var __importDefault = (this && this.__importDefault) || function (mod) {
      //     return (mod && mod.__esModule) ? mod : { "default": mod };
      //   };
      // ```
      return null;
    } else {
      const { index, position: mapped_position } = maybe_indexed_position;
      if (index >= 0 && index < sources.length) {
        return resolveClosureLocation$1(sources[index], mapped_position);
      } /* c8 ignore start */ else {
        logWarning(
          "Treating %j in %j as excluded because its mapped source index is out-of-range",
          position,
          getSourceFile(main).url,
        );
        return null;
      } /* c8 ignore stop */
    }
  }
};

const { String: String$2, parseInt, undefined: undefined$2 } = globalThis;

const stringifyLocation = ({
  url,
  hash,
  position: { line, column },
}) => {
  if (hash === null) {
    return `${url}:${String$2(line)}:${String$2(column)}`;
  } else {
    return `${hash}|${url}:${String$2(line)}:${String$2(column)}`;
  }
};

const {
  Error,
  String: String$1,
  Array: { isArray: isArray$2 },
  Object: { fromEntries: fromEntries$2 },
  Reflect: { ownKeys: ownKeys$1 },
} = globalThis;

//////////////////////////////
// Difficulties with groups //
//////////////////////////////

// import {createHook, executionAsyncId} from "async_hooks";
// createHook({}).enable();
// import {writeFileSync} from "fs";
// const {stdout:{fd}} = process;
// const log = (string) => writeFileSync(fd, `[${executionAsyncId()}] ${string}\n`);
// const logAwait = async (promise) => {
//   log("before");
//   try {
//     await promise;
//   } finally {
//     log("after");
//   }
// };
// const mainAsync = async () => {
//   log("begin");
//   try {
//     await logAwait(new Promise((resolve) => {
//       setTimeout(resolve, 1000, 123);
//     }));
//   } finally {
//     log("end");
//   }
// };
// await mainAsync();

// import {createHook, executionAsyncId} from "async_hooks";
// createHook({}).enable();
// import {writeFileSync} from "fs";
// const {stdout:{fd}} = process;
// const log = (string) => writeFileSync(fd, `[${executionAsyncId()}] ${string}\n`);
// function* logYield (result) {
//   log("before");
//   yield result;
//   log("after");
// };
// async function* main () {
//   log("begin");
//   yield* logYield(123);
//   log("end");
// }
// const iterator = main();
// iterator.next();
// iterator.next();

/////////////
// Builder //
/////////////

const makeProgram = (source, body) => ({
  type: "Program",
  sourceType: source,
  body,
});

const makeClosure = (
  type,
  asynchronous,
  generator,
  expression,
  id,
  params,
  body,
) => ({
  type,
  async: asynchronous,
  generator,
  expression,
  id,
  params,
  body,
});

const makeSequenceExpression = (nodes) => ({
  type: "SequenceExpression",
  expressions: nodes,
});

const makeStatement = (node) => ({
  type: "ExpressionStatement",
  expression: node,
});

const makeIfStatement = (node1, node2, node3) => ({
  type: "IfStatement",
  test: node1,
  consequent: node2,
  alternate: node3,
});

const makeBlockStatement = (nodes) => ({
  type: "BlockStatement",
  body: nodes,
});

const makeAwaitExpression = (node) => ({
  type: "AwaitExpression",
  argument: node,
});

const makeYieldExpression = (delegate, node) => ({
  type: "YieldExpression",
  delegate,
  argument: node,
});

const makeConditionalExpression = (node1, node2, node3) => ({
  type: "ConditionalExpression",
  test: node1,
  consequent: node2,
  alternate: node3,
});

const makeLogicalExpression = (operator, node1, node2) => ({
  type: "LogicalExpression",
  operator,
  left: node1,
  right: node2,
});

const makeCatchClause = (node1, node2) => ({
  type: "CatchClause",
  param: node1,
  body: node2,
});

const makeTryStatement = (node1, node2, node3) => ({
  type: "TryStatement",
  block: node1,
  handler: node2,
  finalizer: node3,
});

const makeRestElement = (node) => ({
  type: "RestElement",
  argument: node,
});

const makeUnaryExpression = (operator, node) => ({
  type: "UnaryExpression",
  prefix: true,
  operator,
  argument: node,
});

const makeBinaryExpression = (operator, node1, node2) => ({
  type: "BinaryExpression",
  operator,
  left: node1,
  right: node2,
});

const makeAssignmentExpression = (node1, node2) => ({
  type: "AssignmentExpression",
  operator: "=",
  left: node1,
  right: node2,
});

const makeArrayExpression = (nodes) => ({
  type: "ArrayExpression",
  elements: nodes,
});

const makeThisExpression = () => ({
  type: "ThisExpression",
});

const makeIdentifier = (name) => ({
  type: "Identifier",
  name,
});

const makeLiteral = (name) => ({
  type: "Literal",
  value: name,
});

const makeVariableDeclaration = (kind, nodes) => ({
  type: "VariableDeclaration",
  kind,
  declarations: nodes,
});

const makeThrowStatement = (node) => ({
  type: "ThrowStatement",
  argument: node,
});

const makeVariableDeclarator = (node1, node2) => ({
  type: "VariableDeclarator",
  id: node1,
  init: node2,
});

const makeCallExpression = (node, nodes) => ({
  type: "CallExpression",
  optional: false,
  callee: node,
  arguments: nodes,
});

const makeExpressionStatement = (node) => ({
  type: "ExpressionStatement",
  expression: node,
});

const makeRegularMemberExpression = (name1, name2) => ({
  type: "MemberExpression",
  optional: false,
  computed: false,
  object: makeIdentifier(name1),
  property: makeIdentifier(name2),
});

const makeReturnStatement = (argument) => ({
  type: "ReturnStatement",
  argument,
});

///////////////
// Component //
///////////////

const isJumpClosureNode = (node) => {
  if (node.type === "Program") {
    return node.sourceType === "module";
  } else if (
    node.type === "FunctionExpression" ||
    node.type === "FunctionDeclaration"
  ) {
    return node.async || node.generator;
  } else if (node.type === "ArrowFunctionExpression") {
    return node.async;
  } /* c8 ignore start */ else {
    throw new Error("unexpected closure node");
  } /* c8 ignore stop */
};

const isSubclassConstructor = (_node, parent, grand_parent) =>
  parent.type === "MethodDefinition" &&
  parent.kind === "constructor" &&
  grand_parent.superClass !== null;

const isEstreeKey = (key) => key !== "loc" && key !== "start" && key !== "end";

/* eslint-disable no-use-before-define */
const visitNode = (node, parent, grand_parent, closure, context) => {
  if (isArray$2(node)) {
    return node.map((node) =>
      visitNode(node, parent, grand_parent, closure, context),
    );
  } else if (
    typeof node === "object" &&
    node !== null &&
    hasOwnProperty(node, "type")
  ) {
    if (hasOwnProperty(instrumenters, node.type)) {
      const maybe_node = instrumenters[node.type](
        node,
        parent,
        grand_parent,
        closure,
        context,
      );
      return maybe_node === null
        ? visitGeneric(node, parent, grand_parent, closure, context)
        : maybe_node;
    } else {
      return visitGeneric(node, parent, grand_parent, closure, context);
    }
  } else {
    return node;
  }
};
/* eslint-enable no-use-before-define */

const visitGeneric = (node, parent, _grand_parent, closure, context) =>
  fromEntries$2(
    ownKeys$1(node)
      .filter(isEstreeKey)
      .map((key) => [
        key,
        visitNode(node[key], node, parent, closure, context),
      ]),
  );

const instrumentClosure = (node, parent, grand_parent, closure, context) => {
  const maybe_location = resolveClosureLocation(
    context.codebase,
    node.loc.start,
  );
  closure = {
    node,
    instrumented: context.apply !== null && maybe_location !== null,
  };
  if (closure.instrumented) {
    const location_string = stringifyLocation(maybe_location);
    return makeClosure(
      node.type,
      node.async,
      node.generator,
      false,
      mapMaybe(coalesce(node, "id", null), (child) =>
        visitNode(child, node, parent, closure, context),
      ),
      node.params.map((param, index) => {
        const pattern = makeIdentifier(
          `${context.apply}_ARGUMENT_${String$1(index)}`,
        );
        return param.type === "RestElement"
          ? makeRestElement(pattern)
          : pattern;
      }),
      makeBlockStatement([
        makeVariableDeclaration("var", [
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_BUNDLE_TAB`),
            makeCallExpression(
              makeRegularMemberExpression(context.apply, "getFreshTab"),
              [],
            ),
          ),
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_RESULT`),
            null,
          ),
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_DONE`),
            makeLiteral(false),
          ),
          ...(isJumpClosureNode(node)
            ? [
                makeVariableDeclarator(
                  makeIdentifier(`${context.apply}_JUMP`),
                  null,
                ),
                makeVariableDeclarator(
                  makeIdentifier(`${context.apply}_JUMP_TAB`),
                  makeLiteral(null),
                ),
              ]
            : []),
        ]),
        makeExpressionStatement(
          makeCallExpression(
            makeRegularMemberExpression(context.apply, "recordApply"),
            [
              makeIdentifier(`${context.apply}_BUNDLE_TAB`),
              makeLiteral(location_string),
              node.type === "ArrowFunctionExpression" ||
              isSubclassConstructor(node, parent, grand_parent)
                ? makeRegularMemberExpression(context.apply, "empty")
                : makeThisExpression(),
              makeArrayExpression(
                node.params.map((_param, index) =>
                  makeIdentifier(`${context.apply}_ARGUMENT_${String$1(index)}`),
                ),
              ),
            ],
          ),
        ),
        makeTryStatement(
          makeBlockStatement([
            ...(node.params.length === 0
              ? []
              : [
                  makeVariableDeclaration(
                    "var",
                    node.params.map((param, index) => {
                      if (param.type === "RestElement") {
                        param = param.argument;
                      }
                      // Special case for AssignmentPattern:
                      //
                      // function f (x = {}) {}
                      //
                      // function f (APPMAP_ARGUMENT_0) {
                      //   // does not work :(
                      //   var x = {} = APPMAP_ARGUMENT_0;
                      // }
                      if (param.type === "AssignmentPattern") {
                        return makeVariableDeclarator(
                          param.left,
                          makeConditionalExpression(
                            makeBinaryExpression(
                              "===",
                              makeIdentifier(
                                `${context.apply}_ARGUMENT_${String$1(index)}`,
                              ),
                              makeUnaryExpression("void", makeLiteral(0)),
                            ),
                            param.right,
                            makeIdentifier(
                              `${context.apply}_ARGUMENT_${String$1(index)}`,
                            ),
                          ),
                        );
                      } else {
                        return makeVariableDeclarator(
                          param,
                          makeIdentifier(
                            `${context.apply}_ARGUMENT_${String$1(index)}`,
                          ),
                        );
                      }
                    }),
                  ),
                ]),
            node.expression
              ? makeReturnStatement(
                  makeAssignmentExpression(
                    makeIdentifier(`${context.apply}_RESULT`),
                    visitNode(node.body, node, parent, closure, context),
                  ),
                )
              : visitNode(node.body, node, parent, closure, context),
          ]),
          makeCatchClause(
            makeIdentifier(`${context.apply}_ERROR`),
            makeBlockStatement([
              ...(isJumpClosureNode(node)
                ? [
                    makeIfStatement(
                      makeBinaryExpression(
                        "!==",
                        makeIdentifier(`${context.apply}_JUMP_TAB`),
                        makeLiteral(null),
                      ),
                      makeBlockStatement([
                        makeStatement(
                          makeCallExpression(
                            makeRegularMemberExpression(
                              context.apply,
                              "recordReject",
                            ),
                            [
                              makeIdentifier(`${context.apply}_JUMP_TAB`),
                              makeIdentifier(`${context.apply}_ERROR`),
                            ],
                          ),
                        ),
                        makeStatement(
                          makeAssignmentExpression(
                            makeIdentifier(`${context.apply}_JUMP_TAB`),
                            makeLiteral(null),
                          ),
                        ),
                      ]),
                      null,
                    ),
                  ]
                : []),
              makeExpressionStatement(
                makeAssignmentExpression(
                  makeIdentifier(`${context.apply}_DONE`),
                  makeLiteral(true),
                ),
              ),
              makeExpressionStatement(
                makeCallExpression(
                  makeRegularMemberExpression(context.apply, "recordThrow"),
                  [
                    makeIdentifier(`${context.apply}_BUNDLE_TAB`),
                    makeLiteral(location_string),
                    makeIdentifier(`${context.apply}_ERROR`),
                  ],
                ),
              ),
              makeThrowStatement(makeIdentifier(`${context.apply}_ERROR`)),
            ]),
          ),
          makeBlockStatement([
            ...(isJumpClosureNode(node)
              ? [
                  makeIfStatement(
                    makeBinaryExpression(
                      "!==",
                      makeIdentifier(`${context.apply}_JUMP_TAB`),
                      makeLiteral(null),
                    ),
                    makeBlockStatement([
                      makeStatement(
                        makeCallExpression(
                          makeRegularMemberExpression(
                            context.apply,
                            "recordResolve",
                          ),
                          [
                            makeIdentifier(`${context.apply}_JUMP_TAB`),
                            makeRegularMemberExpression(context.apply, "empty"),
                          ],
                        ),
                      ),
                      makeStatement(
                        makeAssignmentExpression(
                          makeIdentifier(`${context.apply}_JUMP_TAB`),
                          makeLiteral(null),
                        ),
                      ),
                    ]),
                    null,
                  ),
                ]
              : []),
            makeIfStatement(
              makeUnaryExpression("!", makeIdentifier(`${context.apply}_DONE`)),
              makeBlockStatement([
                makeExpressionStatement(
                  makeCallExpression(
                    makeRegularMemberExpression(context.apply, "recordReturn"),
                    [
                      makeIdentifier(`${context.apply}_BUNDLE_TAB`),
                      makeLiteral(location_string),
                      makeIdentifier(`${context.apply}_RESULT`),
                    ],
                  ),
                ),
              ]),
              null,
            ),
          ]),
        ),
      ]),
    );
  } else {
    return makeClosure(
      node.type,
      node.async,
      node.generator,
      node.expression,
      mapMaybe(node.id, (child) =>
        visitNode(child, node, parent, closure, context),
      ),
      node.params.map((param) =>
        visitNode(param, node, parent, closure, context),
      ),
      visitNode(node.body, node, parent, closure, context),
    );
  }
};

const compileInstrumentJumpExpression =
  (makeRecordJumpExpression, makeForwardJumpExpression) =>
  (node, parent, _grand_parent, closure, context) =>
    closure.instrumented
      ? makeSequenceExpression([
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP`),
            visitNode(node.argument, node, parent, closure, context),
          ),
          makeLogicalExpression(
            "||",
            makeBinaryExpression(
              "===",
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
            makeIdentifier(`${context.apply}_APPMAP_JUMP_ASSERTION_VIOLATION`),
          ),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP_TAB`),
            makeCallExpression(
              makeRegularMemberExpression(context.apply, "getFreshTab"),
              [],
            ),
          ),
          makeRecordJumpExpression(node, context.apply),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP`),
            makeForwardJumpExpression(node, context.apply),
          ),
          makeCallExpression(
            makeRegularMemberExpression(context.apply, "recordResolve"),
            [
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeIdentifier(`${context.apply}_JUMP`),
            ],
          ),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP_TAB`),
            makeLiteral(null),
          ),
          makeIdentifier(`${context.apply}_JUMP`),
        ])
      : null;

const instrumenters = {
  AwaitExpression: compileInstrumentJumpExpression(
    (_node, namespace) =>
      makeCallExpression(
        makeRegularMemberExpression(namespace, "recordAwait"),
        [
          makeIdentifier(`${namespace}_JUMP_TAB`),
          makeIdentifier(`${namespace}_JUMP`),
        ],
      ),
    (_node, namespace) =>
      makeAwaitExpression(makeIdentifier(`${namespace}_JUMP`)),
  ),
  YieldExpression: compileInstrumentJumpExpression(
    ({ delegate }, namespace) =>
      makeCallExpression(
        makeRegularMemberExpression(namespace, "recordYield"),
        [
          makeIdentifier(`${namespace}_JUMP_TAB`),
          makeLiteral(delegate),
          makeIdentifier(`${namespace}_JUMP`),
        ],
      ),
    ({ delegate }, namespace) =>
      makeYieldExpression(delegate, makeIdentifier(`${namespace}_JUMP`)),
  ),
  ReturnStatement: (node, parent, _grand_parent, closure, context) =>
    closure.instrumented && node.argument !== null
      ? makeReturnStatement(
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_RESULT`),
            visitNode(node.argument, node, parent, closure, context),
          ),
        )
      : null,
  CallExpression: (node, parent, _grand_parent, closure, context) => {
    if (
      node.callee.type === "Identifier" &&
      context.eval.aliases.includes(node.callee.name) &&
      node.arguments.length > 0
    ) {
      return makeCallExpression(makeIdentifier(node.callee.name), [
        makeCallExpression(makeIdentifier(context.eval.hidden), [
          makeLiteral(context.url),
          makeLiteral(
            `${String$1(node.loc.start.line)}-${String$1(node.loc.start.column)}`,
          ),
          visitNode(node.arguments[0], node, parent, closure, context),
        ]),
        ...node.arguments
          .slice(1)
          .map((argument) =>
            visitNode(argument, node, parent, closure, context),
          ),
      ]);
    } else {
      return null;
    }
  },
  TryStatement: (node, parent, _grand_parent, closure, context) => {
    if (closure.instrumented && isJumpClosureNode(closure.node)) {
      return makeTryStatement(
        visitNode(node.block, node, parent, closure, context),
        makeCatchClause(
          makeIdentifier(`${context.apply}_ERROR`),
          makeBlockStatement([
            makeIfStatement(
              makeBinaryExpression(
                "!==",
                makeIdentifier(`${context.apply}_JUMP_TAB`),
                makeLiteral(null),
              ),
              makeBlockStatement([
                makeStatement(
                  makeCallExpression(
                    makeRegularMemberExpression(context.apply, "recordReject"),
                    [
                      makeIdentifier(`${context.apply}_JUMP_TAB`),
                      makeIdentifier(`${context.apply}_ERROR`),
                    ],
                  ),
                ),
                makeStatement(
                  makeAssignmentExpression(
                    makeIdentifier(`${context.apply}_JUMP_TAB`),
                    makeLiteral(null),
                  ),
                ),
              ]),
              null,
            ),
            ...(node.handler === null
              ? []
              : [
                  ...(node.handler.param === null
                    ? []
                    : [
                        makeVariableDeclaration("let", [
                          makeVariableDeclarator(
                            visitNode(
                              node.handler.param,
                              node.handler,
                              node,
                              closure,
                              context,
                            ),
                            makeIdentifier(`${context.apply}_ERROR`),
                          ),
                        ]),
                      ]),
                  visitNode(
                    node.handler.body,
                    node.handler,
                    node,
                    closure,
                    context,
                  ),
                ]),
          ]),
        ),
        makeBlockStatement([
          makeIfStatement(
            makeBinaryExpression(
              "!==",
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
            makeBlockStatement([
              makeStatement(
                makeCallExpression(
                  makeRegularMemberExpression(context.apply, "recordResolve"),
                  [
                    makeIdentifier(`${context.apply}_JUMP_TAB`),
                    makeRegularMemberExpression(context.apply, "empty"),
                  ],
                ),
              ),
              makeStatement(
                makeAssignmentExpression(
                  makeIdentifier(`${context.apply}_JUMP_TAB`),
                  makeLiteral(null),
                ),
              ),
            ]),
            null,
          ),
          ...(node.finalizer === null
            ? []
            : [visitNode(node.finalizer, node, parent, closure, context)]),
        ]),
      );
    } else {
      return null;
    }
  },
  Identifier: (node, _parent, _grand_parent, _closure, context) => {
    assert(
      !logErrorWhen(
        node.name.startsWith(context.apply),
        "Identifier collision detected at %j line %j column %j >> identifier should not start with %j, got: %j",
        context.url,
        node.loc.start.line,
        node.loc.start.column,
        context.apply,
        node.name,
      ),
      "Identifier collision",
      ExternalAppmapError,
    );
    return null;
  },
  Program: (node, parent, _grand_parent, closure, context) =>
    closure.instrumented && node.sourceType === "module"
      ? makeProgram("module", [
          makeVariableDeclaration("let", [
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_BUNDLE_TAB`),
              makeCallExpression(
                makeRegularMemberExpression(context.apply, "getFreshTab"),
                [],
              ),
            ),
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_JUMP`),
              null,
            ),
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
          ]),
          ...node.body.map((child) =>
            visitNode(child, node, parent, closure, context),
          ),
        ])
      : null,
  FunctionExpression: instrumentClosure,
  FunctionDeclaration: instrumentClosure,
  ArrowFunctionExpression: instrumentClosure,
};

const initial_parent = { type: "File" };

const initial_grand_parent = { type: "Root" };

const visit = (node, context) => {
  assert(
    node.type === "Program",
    "expected program as top level estree node",
    InternalAppmapError,
  );
  // Top level async jump only present in module.
  // Avoid poluting global scope in script.
  return visitNode(
    node,
    initial_parent,
    initial_grand_parent,
    {
      node,
      instrumented: context.apply !== null && node.sourceType === "module",
    },
    context,
  );
};

const { generate: generateEstree } = Astring;

const instrument$1 = (url, cache, configuration) => {
  const codebase = createCodebase(url, cache, configuration);
  const files = getEnabledSourceFileArray(codebase);
  if (files.length === 0) {
    logDebug("*Not* recording file %j", url);
    return {
      ...getMainFile(codebase),
      sources: [],
    };
  } else {
    logDebug("Recording file %j", url);
    return {
      url,
      content: generateEstree(
        visit(parseMain(codebase), {
          url,
          eval: configuration.hooks.eval,
          apply: configuration.hooks.apply,
          codebase,
        }),
      ),
      sources: files,
    };
  }
};

const { Map: Map$1 } = globalThis;

const readFileSafe = (url, readFile) => {
  try {
    return readFile(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const instrumentInject = (url, content, configuration, readFile) => {
  const cache = new Map$1(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, readFileSafe(url, readFile));
      }
    }
  }
};

const {
  Reflect: { getOwnPropertyDescriptor, getPrototypeOf, ownKeys },
  Error: { prototype: error_prototype },
  Infinity,
  Symbol,
  Symbol: { keyFor, for: symbolFor },
  WeakMap,
  Map,
  Set,
  String,
  undefined: undefined$1,
  Math: { min },
  Object: { prototype: object_prototype, fromEntries: fromEntries$1 },
  Array: { isArray: isArray$1 },
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const empty = symbolFor("APPMAP_EMPTY_MARKER");

const isSymbol = (any) => typeof any === "symbol";

new Set(
  ownKeys(Symbol)
    .map((key) => Symbol[key])
    .filter(isSymbol),
);

const createSerialization = ({
  serialization: {
    "maximum-print-length": maximum_print_length,
    "maximum-properties-length": maximum_properties_length,
    "impure-printing": impure_printing,
    "impure-constructor-naming": impure_constructor_naming,
    "impure-array-inspection": impure_array_inspection,
    "impure-error-inspection": impure_error_inspection,
    "impure-hash-inspection": impure_hash_inspection,
  },
}) => ({
  counter: createCounter(0),
  empty,
  symbols: new Map(),
  references: new WeakMap(),
  maximum_print_length:
    maximum_print_length === null ? Infinity : maximum_print_length,
  maximum_properties_length,
  impure_printing,
  impure_constructor_naming,
  impure_array_inspection,
  impure_error_inspection,
  impure_hash_inspection,
});

const SOURCE = "SRC";

const SESSION_ASSIGNMENT = "SE!";
const GROUP_ASSIGNMENT = "GR!";

const {
  Array: { isArray, from: toArray },
  Object: { fromEntries, entries: toEntries$1 },
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const initializeBuffer = (buffer, session, { value: group }) => {
  buffer.push([SESSION_ASSIGNMENT, session], [GROUP_ASSIGNMENT, group]);
};

const createFrontend = (configuration) => {
  const { session } = configuration;
  assert(session !== null, "missing session", InternalAppmapError);
  const buffer = [];
  initializeBuffer(buffer, session, { value: 0 });
  return {
    enabled: { value: true },
    buffer,
    counter: createCounter(0),
    session,
    old_group: { value: 0 },
    serialization: createSerialization(configuration),
    configuration,
  };
};

const flushContent = ({ buffer, session, old_group }) => {
  if (buffer.length === 2) {
    return null;
  } else {
    const content = stringifyJSON$1(buffer);
    buffer.length = 0;
    initializeBuffer(buffer, session, old_group);
    return content;
  }
};

const instrument = (
  { enabled, buffer, configuration },
  url,
  content,
  readFile,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } = instrumentInject(
      url,
      content,
      configuration,
      readFile,
    );
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const { patch } = NetSocketMessaging;

const openSocket = ({ host, "trace-port": port }) => {
  const socket = new Socket();
  if (typeof port === "string") {
    socket.connect(toIpcPath(fileURLToPath(port)));
  } else {
    socket.connect(port, host);
  }
  patch(socket);
  socket.on("connect", () => {
    socket.unref();
  });
  return socket;
};

const addSocketListener = (socket, name, listener) => {
  socket.addListener(name === "open" ? "connect" : name, listener);
};

const isSocketReady = (socket) => !socket.pending && socket.writable;

const sendSocket = (socket, message) => {
  if (!socket.pending && socket.writable) {
    socket.send(message);
  } else {
    logWarning("Lost message >> %s", message);
  }
};

// https://github.com/facebook/jest/blob/ee63afcbe7904d18558d3cc40e0940804df3deb7/packages/jest-transform/src/ScriptTransformer.ts#L261

// TODO: Make a stateless agent.
// - counter to index references
// - counter to index events

const {
  RegExp,
  encodeURIComponent,
  Object: { entries: toEntries },
  JSON: { stringify: stringifyJSON },
} = globalThis;

const require = createRequire(toDirectoryUrl(convertPathToFileUrl(cwd())));

const flush = (frontend, socket) => {
  if (isSocketReady(socket)) {
    const content = flushContent(frontend);
    if (content !== null) {
      sendSocket(socket, content);
    }
  }
};

const loadTransformer = (specifier, options) => {
  let transformer = require(specifier);
  // This `default` indirection is not documented.
  // But some module bundlers (eg typescript)
  // wrap module exports in `default`.
  if (
    hasOwnProperty(transformer, "default") &&
    typeof transformer.default === "object" &&
    transformer.default !== null
  ) {
    transformer = transformer.default;
  }
  if (
    hasOwnProperty(transformer, "createTransformer") &&
    typeof transformer.createTransformer === "function"
  ) {
    transformer = transformer.createTransformer(options);
  }
  return transformer;
};

const loadDispatchingEntry = ([pattern, { specifier, options }]) => [
  new RegExp(pattern, "u"),
  {
    specifier,
    transformer: loadTransformer(specifier, options),
  },
];

const sanitizeSource = (source, specifier) => {
  // This is no documented by transformers can directly
  // return a string rather than an object.
  // This is the case for `ts-jest@27.1.4`.
  if (typeof source === "string") {
    return { code: source, map: null };
  } else {
    const { code = null, map = null } = source;
    assert(
      !logErrorWhen(
        typeof code !== "string",
        "Transformer at %j should return an object whose code property is a string, got: %o",
        specifier,
        code,
      ),
      "Transformer should return an object whose code property is a string",
      ExternalAppmapError,
    );
    return { code, map };
  }
};

const getSourceContent = ({ code: content, map: map_content = null }) =>
  map_content === null
    ? content
    : // Escaping `${"="}` to prevent c8 to choke on this literal.
      // https://github.com/bcoe/c8/blob/854f9f6c2ea36e583ea02fa3f8a850804e671df3/lib/source-map-from-file.js#L41
      // https://github.com/bcoe/c8/issues/467
      `${content}\n//# sourceMappingURL${"="}data:text/json,${encodeURIComponent(
        /* c8 ignore start */
        typeof map_content === "string"
          ? map_content
          : stringifyJSON(map_content),
        /* c8 ignore stop */
      )}`;

const transform = (
  frontend,
  socket,
  source,
  path,
  { supportsStaticESM: is_module },
  { hooks: { esm, cjs } },
) => {
  // Unfortunately, Jest does not provide definitive information
  // on the type of script that is being given.
  // Hence we mirror its strategy which is a simple path extension check.
  // https://github.com/facebook/jest/blob/836157f4807893bb23a4758a60998fbd61cb184c/packages/jest-runtime/src/index.ts#L1176
  if (path.endsWith(".json")) {
    return source;
  } else if (is_module ? esm : cjs) {
    const url = convertPathToFileUrl(path);
    const content1 = getSourceContent(source);
    const content2 = instrument(frontend, url, content1, readFile);
    flush(frontend, socket);
    return {
      code: content2,
      map: null,
    };
  } else {
    return source;
  }
};

const compileCreateTransformer = (configuration) => {
  // Only source messages will be send from the frontend.
  // As they are shared in the backend, session is a noop.
  const frontend = createFrontend({ ...configuration, session: "noop" });
  const socket = openSocket(configuration);
  addSocketListener(socket, "message", noop);
  addSocketListener(socket, "open", () => {
    flush(frontend, socket);
  });
  return (dispatching) => {
    const transformers = toEntries(dispatching).map(loadDispatchingEntry);
    return {
      canInstrument: false,
      process: (content, path, options) => {
        let source = { code: content, map: null };
        for (const [regexp, { specifier, transformer }] of transformers) {
          if (regexp.test(path)) {
            assert(
              !logErrorWhen(
                !hasOwnProperty(transformer, "process"),
                "Transformer at %j should export `process`",
                specifier,
              ),
              "Transformer should export process",
              ExternalAppmapError,
            );
            source = sanitizeSource(
              transformer.process(content, path, options),
              specifier,
            );
            break;
          }
        }
        return transform(
          frontend,
          socket,
          source,
          path,
          options,
          configuration,
        );
      },
      processAsync: async (content, path, options) => {
        let source = { code: content, map: null };
        for (const [regexp, { specifier, transformer }] of transformers) {
          if (regexp.test(path)) {
            assert(
              !logErrorWhen(
                !hasOwnProperty(transformer, "process"),
                "Transformer at %j should export either `process` or `processAsync`",
                specifier,
              ),
              "Transformer should export either process or processAsync",
              ExternalAppmapError,
            );
            source = sanitizeSource(
              await transformer[
                hasOwnProperty(transformer, "processAsync")
                  ? "processAsync"
                  : "process"
              ](content, path, options),
            );
            break;
          }
        }
        return transform(
          frontend,
          socket,
          source,
          path,
          options,
          configuration,
        );
      },
    };
  };
};

export { compileCreateTransformer };
