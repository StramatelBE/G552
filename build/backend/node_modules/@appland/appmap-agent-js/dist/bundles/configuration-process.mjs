import { openSync, writeSync, readFileSync, writeFileSync } from 'node:fs';
import minimist from 'minimist';
import YAML from 'yaml';
import { readFile } from 'node:fs/promises';
import { URL as URL$4, pathToFileURL } from 'node:url';
import { platform } from 'node:os';
import { win32, posix } from 'node:path';
import Treeify from 'treeify';
import AjvErrorTree from 'ajv-error-tree';
import Minimatch from 'minimatch';

const toAbsoluteUrl = (relative, base_url) =>
  new URL$4(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toDirectoryUrl = (url) => {
  const url_obj = new URL$4(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Alternatively:
//   url.match(/:\/{0,2}.*\/([^/#]+)(#.*)?$/)[1]
const getUrlFilename = (url) => {
  const { pathname } = new URL$4(url);
  if (pathname === "" || pathname.endsWith("/")) {
    return null;
  } else {
    return pathname.substring(pathname.lastIndexOf("/") + 1);
  }
};

// Alternatively:
//   url.match(/([^\/]+)(\.[^/#]*)(#.*)?$/)[2]
const getLastUrlExtension = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(filename.lastIndexOf("."));
  } else {
    return null;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$3,
  JSON: { parse: parseJSON$1 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$1(
  await readFile(
    new URL$3(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$4 } = globalThis;

class AppmapError extends Error$4 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const { Error: Error$3 } = globalThis;

class AssertionError extends Error$3 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const {
  Boolean,
  String: String$1,
  Number,
  parseInt,
  Array: { isArray: isArray$2 },
  Number: {
    isNaN,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER,
    MIN_SAFE_INTEGER,
  },
  Math: { round },
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const print = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$2(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$2(any);
  } else {
    return String$1(any);
  }
};

const {
  Error: Error$2,
  String,
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$1(value);
      }
      if (marker === "O") {
        try {
          return String(value);
        } catch {
          return print(value);
        }
      }
      if (marker === "o") {
        return print(value);
      }
      throw new Error$2("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const {
  Error: Error$1,
  Reflect: { apply },
  WeakMap,
} = globalThis;

new WeakMap();

const noop = () => {};
const identity = (x) => x;

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const {
  undefined: undefined$4,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2, ownKeys: ownKeys$2, defineProperty: defineProperty$1 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$2(Object$1, "hasOwn") === undefined$4
    ? (object, key) => getOwnPropertyDescriptor$2(object, key) !== undefined$4
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

const {
  undefined: undefined$3,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1 },
  Error,
  Set,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$1(obj, key) !== undefined$3,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$2,
  Reflect: { getOwnPropertyDescriptor },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor(obj, key) !== undefined$2,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const getCwdUrl = ({ cwd: getCwd }) =>
  convertPathToFileUrl(toDirectoryPath(getCwd()));

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$1,
  ReferenceError,
  Reflect: { defineProperty },
} = globalThis;

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$2 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$2(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$1 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$1(fd, "DEBUG"),
    logInfo: generateLog$1(fd, "INFO"),
    logWarning: generateLog$1(fd, "WARNING"),
    logError: generateLog$1(fd, "ERROR"),
  };
};

const { logDebug, logInfo: logInfo$1, logWarning, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

generateLog(
  "debug",
  logDebug,
);

const { log: logInfo, logWhen: logInfoWhen } = generateLog(
  "info",
  logInfo$1,
);

generateLog(
  "warning",
  logWarning,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const { URL: URL$1 } = globalThis;

const {
  validateSerial: validateAjvSerial,
  validatePayload: validateAjvPayload,
  validateExternalConfiguration: validateAjvExternalConfiguration,
  validateInternalConfiguration: validateAjvInternalConfiguration,
  validateMessage: validateAjvMessage,
  validateSourceMap: validateAjvSourceMap,
} = await import(new URL$1("dist/schema.mjs", self_directory));

const { asTree } = Treeify;

const generateValidate = (validateAjv, name, AppmapError) => (json) => {
  if (!validateAjv(json)) {
    const { errors } = validateAjv;
    const { length } = errors;
    assert(length > 0, "unexpected empty error array", InternalAppmapError);
    const tree1 = AjvErrorTree.structureAJVErrorArray(errors);
    const tree2 = AjvErrorTree.summarizeAJVErrorTree(tree1);
    logError(
      "invalid %s\n%s\n  Parameters = %j\n  Input = %j",
      name,
      typeof tree2 === "string" ? tree2 : asTree(tree2, true),
      errors.map((error) => coalesce(error, "params", null)),
      json,
    );
    throw new AppmapError("Failed to validate data against JSON schema");
  }
};

const validateExternalConfiguration = generateValidate(
  validateAjvExternalConfiguration,
  "user-defined configuration",
  ExternalAppmapError,
);

const { Minimatch: MinimatchClass } = Minimatch;

const compileGlob = (glob) => new MinimatchClass(glob).makeRe();

const { Map: Map$1, RegExp } = globalThis;

new Map$1();

const escape = (char) => `\\${char}`;

const sanitizeForRegExp = (string) =>
  string.replace(/[/\\+*?.^$()[\]{}|]/gu, escape);

// const sanitizeForGlob = (string) => string.replace(/[*?[\]]/g, escape);

const toTargetRegExp = (target, recursive) => {
  if (recursive) {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}`;
    } else {
      return `^${sanitizeForRegExp(target)}(/|$)`;
    }
  } else {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}[^/]*$`;
    } else {
      return `^${sanitizeForRegExp(target)}$`;
    }
  }
};

const createMatcher = (options, base) => {
  const {
    glob,
    url,
    path,
    dist,
    regexp,
    flags,
    recursive,
    external,
    relative,
  } = {
    glob: null,
    path: null,
    url: null,
    dist: null,
    regexp: null,
    flags: "",
    recursive: true,
    external: false,
    relative: true,
    ...options,
  };
  if (regexp !== null) {
    return {
      base: relative ? base : null,
      source: regexp,
      flags,
    };
  }
  if (glob !== null) {
    const { source, flags } = compileGlob(glob);
    return {
      base,
      source,
      flags,
    };
  }
  if (path !== null) {
    return {
      base,
      source: toTargetRegExp(path, recursive),
      flags: "",
    };
  }
  if (url !== null) {
    return {
      base: null,
      source: toTargetRegExp(url, recursive),
      flags: "",
    };
  }
  if (dist !== null) {
    assert(
      dist[dist.length - 1] !== "/",
      "package path should not end with a path separator",
      InternalAppmapError,
    );
    let source = `node_modules/${sanitizeForRegExp(dist)}/`;
    if (!external) {
      source = `^${source}`;
    }
    if (!recursive) {
      source = `${source}[^/]*$`;
    }
    return {
      base,
      source,
      flags: "",
    };
  }
  throw new InternalAppmapError("invalid matcher options");
};

const {
  Array: { isArray: isArray$1 },
  Reflect: { ownKeys: ownKeys$1 },
  Object: { entries: toEntries },
} = globalThis;

const HOOK_APPLY_GLOBAL = "APPMAP_HOOK_APPLY";

const HOOK_EVAL_GLOBAL = "APPMAP_HOOK_EVAL";

const EXPECTED_EXTRA_PROPERTIES = ["test_recording"];

////////////
// Extend //
////////////

const assign = (value1, value2) => ({ ...value1, ...value2 });

const overwrite = (_value1, value2) => value2;

// const append = (value1, value2) => [...value1, ...value2];

const prepend = (value1, value2) => [...value2, ...value1];

const extendCommandOptions = (options1, options2) => ({
  ...options1,
  ...options2,
  env: {
    ...coalesce(options1, "env", {}),
    ...coalesce(options2, "env", {}),
  },
});

///////////////
// Normalize //
///////////////

const normalizeDefaultProcess = (default_process, _base) => {
  if (typeof default_process === "boolean") {
    return { enabled: default_process };
  } else {
    return {
      enabled: false,
      ...default_process,
    };
  }
};

const normalizeExclusion = (exclusion, _base) => {
  if (typeof exclusion === "string") {
    exclusion = {
      "qualified-name": exclusion,
      recursive: true,
    };
  }
  const default_value = coalesce(exclusion, "combinator", "and") === "and";
  return {
    combinator: "and",
    "qualified-name": default_value,
    name: default_value,
    "every-label": default_value,
    "some-label": default_value,
    excluded: true,
    recursive: false,
    ...exclusion,
  };
};

const normalizeCommandOptions = (options, base) => ({
  shell: false,
  encoding: "utf8",
  env: {},
  stdio: "inherit",
  timeout: 0,
  killSignal: "SIGTERM",
  ...options,
  cwd: hasOwnProperty(options, "cwd")
    ? toDirectoryUrl(toAbsoluteUrl(options.cwd, base))
    : toAbsoluteUrl(".", base),
});

const normalizeHooks = (hooks, _base) => {
  if (hasOwnProperty(hooks, "eval")) {
    hooks.eval =
      typeof hooks.eval === "boolean"
        ? {
            hidden: HOOK_EVAL_GLOBAL,
            aliases: hooks.eval ? ["eval"] : [],
          }
        : hooks.eval;
  }
  if (hasOwnProperty(hooks, "apply")) {
    hooks.apply =
      typeof hooks.apply === "boolean"
        ? hooks.apply
          ? HOOK_APPLY_GLOBAL
          : null
        : hooks.apply;
  }
  return hooks;
};

const normalizeDefaultPackage = (package_, _base) => {
  if (typeof package_ === "boolean") {
    package_ = { enabled: package_ };
  }
  return {
    enabled: true,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
    ...package_,
  };
};

const normalizeAgent = ({ directory, package: _package }, base) => ({
  directory: toDirectoryUrl(toAbsoluteUrl(directory, base)),
  package: _package,
});

const normalizeDirectoryUrl = (url, base) =>
  toDirectoryUrl(toAbsoluteUrl(url, base));

const normalizeExclude = (exclusions, _base) =>
  exclusions.map(normalizeExclusion);

const normalizeCommand = (command, _base) => ({
  source: typeof command === "string" ? command : null,
  tokens: typeof command === "string" ? null : command,
});

const normalizeScenarios = (scenarios, base) =>
  toEntries(scenarios).map(([key, value]) => ({
    base,
    key,
    value,
  }));

const normalizeLog = (log, base) => {
  if (typeof log === "string") {
    log = { level: log };
  }
  if (hasOwnProperty(log, "file") && typeof log.file !== "number") {
    log.file = toAbsoluteUrl(log.file, base);
  }
  return log;
};

const normalizePort = (port, base) => {
  if (typeof port === "string" && port !== "") {
    port = toAbsoluteUrl(port, base);
  }
  return port;
};

const generateNormalizeSplit = (separator, key1, key2) => (value) => {
  if (typeof value === "string") {
    const segments = value.split(separator);
    return {
      [key1]: segments[0],
      [key2]: segments.length === 1 ? null : segments[1],
    };
  }
  return value;
};

const normalizeRecording = generateNormalizeSplit(
  ".",
  "defined-class",
  "method-id",
);

const normalizeFramework = generateNormalizeSplit("@", "name", "version");

const normalizeFrameworkArray = (frameworks) =>
  frameworks.map(normalizeFramework);

const normalizePackageMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const {
    enabled,
    shallow,
    "inline-source": inline_source,
    exclude,
    "source-type": source_type,
    parsing,
    ...rest
  } = {
    enabled: true,
    "inline-source": null,
    shallow: hasOwnProperty(matcher, "dist"),
    exclude: [],
    "source-type": null,
    parsing: null,
    ...matcher,
  };
  return [
    createMatcher(rest, base),
    {
      enabled,
      "inline-source": inline_source,
      shallow,
      exclude: exclude.map(normalizeExclusion),
      "source-type": source_type,
      parsing,
    },
  ];
};

const normalizePackageMatcherArray = (matchers, base) => {
  if (!isArray$1(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizePackageMatcher(matcher, base));
};

const normalizeProcessMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const { enabled, ...rest } = {
    enabled: true,
    ...matcher,
  };
  return [createMatcher(rest, base), { enabled }];
};

const normalizeProcesseMatcherArray = (matchers, base) => {
  if (!isArray$1(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizeProcessMatcher(matcher, base));
};

////////////
// fields //
////////////

const fields = {
  socket: {
    extend: overwrite,
    normalize: identity,
  },
  heartbeat: {
    extend: overwrite,
    normalize: identity,
  },
  threshold: {
    extend: overwrite,
    normalize: identity,
  },
  agent: {
    extend: overwrite,
    normalize: normalizeAgent,
  },
  repository: {
    extend: overwrite,
    normalize: identity,
  },
  scenario: {
    extend: overwrite,
    normalize: identity,
  },
  scenarios: {
    extend: overwrite,
    normalize: normalizeScenarios,
  },
  "recursive-process-recording": {
    extend: overwrite,
    normalize: identity,
  },
  "postmortem-function-exclusion": {
    extend: overwrite,
    normalize: identity,
  },
  command: {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-win32": {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-options": {
    extend: extendCommandOptions,
    normalize: normalizeCommandOptions,
  },
  validate: {
    extend: assign,
    normalize: identity,
  },
  log: {
    extend: assign,
    normalize: normalizeLog,
  },
  host: {
    extend: overwrite,
    normalize: identity,
  },
  session: {
    extend: overwrite,
    normalize: identity,
  },
  sessions: {
    extend: overwrite,
    normalize: identity,
  },
  "proxy-port": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "http-switch": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "track-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-port": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  enabled: {
    extend: overwrite,
    normalize: identity,
  },
  "default-process": {
    extend: overwrite,
    normalize: normalizeDefaultProcess,
  },
  processes: {
    extend: prepend,
    normalize: normalizeProcesseMatcherArray,
  },
  recorder: {
    extend: overwrite,
    normalize: identity,
  },
  "inline-source": {
    extend: overwrite,
    normalize: identity,
  },
  hooks: {
    extend: assign,
    normalize: normalizeHooks,
  },
  ordering: {
    extend: overwrite,
    normalize: identity,
  },
  "collapse-package-hierachy": {
    extend: overwrite,
    normalize: identity,
  },
  serialization: {
    extend: assign,
    normalize: identity,
  },
  main: {
    extend: overwrite,
    normalize: toAbsoluteUrl,
  },
  language: {
    extend: overwrite,
    normalize: identity,
  },
  engine: {
    extend: overwrite,
    normalize: identity,
  },
  "default-package": {
    extend: overwrite,
    normalize: normalizeDefaultPackage,
  },
  packages: {
    extend: prepend,
    normalize: normalizePackageMatcherArray,
  },
  exclude: {
    extend: prepend,
    normalize: normalizeExclude,
  },
  recording: {
    extend: overwrite,
    normalize: normalizeRecording,
  },
  appmap_dir: {
    extend: overwrite,
    normalize: normalizeDirectoryUrl,
  },
  appmap_file: {
    extend: overwrite,
    normalize: identity,
  },
  name: {
    extend: overwrite,
    normalize: identity,
  },
  "map-name": {
    extend: overwrite,
    normalize: identity,
  },
  pruning: {
    extend: overwrite,
    normalize: identity,
  },
  labels: {
    extend: prepend,
    normalize: identity,
  },
  feature: {
    extend: overwrite,
    normalize: identity,
    initial: null,
  },
  "feature-group": {
    extend: overwrite,
    normalize: identity,
  },
  frameworks: {
    extend: prepend,
    normalize: normalizeFrameworkArray,
  },
};

////////////
// export //
////////////

const createConfiguration = (home) => ({
  scenarios: [],
  scenario: "^",
  "recursive-process-recording": true,
  command: null,
  "command-win32": null,
  "command-options": {
    cwd: toAbsoluteUrl(".", home),
    shell: false,
    encoding: "utf8",
    env: {},
    stdio: "inherit",
    timeout: 0,
    killSignal: "SIGTERM",
  },
  // overwritten by the agent
  agent: null,
  repository: {
    directory: toAbsoluteUrl(".", home),
    history: null,
    package: null,
  },
  engine: null,
  labels: [],
  feature: null,
  "feature-group": null,
  frameworks: [],
  main: null,
  recording: null,
  // provided by the user
  socket: "net",
  heartbeat: 1000,
  threshold: 100,
  host: "localhost",
  session: null,
  sessions: "^",
  "proxy-port": null,
  "trace-port": 0, // possibly overwritten by the agent
  "http-switch": "__APPMAP__",
  "trace-protocol": "TCP",
  "track-port": 0, // possibly overwritten by the agent
  "track-protocol": "HTTP/1.1",
  "intercept-track-port": "^",
  "intercept-track-protocol": "HTTP/1.1",
  validate: {
    appmap: false,
    message: false,
  },
  log: {
    level: "error",
    file: 2,
  },
  appmap_dir: toAbsoluteUrl("tmp/appmap/", home),
  appmap_file: null,
  "default-process": { enabled: true },
  processes: [],
  recorder: null,
  "postmortem-function-exclusion": null,
  "inline-source": false,
  hooks: {
    apply: HOOK_APPLY_GLOBAL,
    eval: {
      hidden: HOOK_EVAL_GLOBAL,
      aliases: [],
    },
    esm: true,
    cjs: true,
    http: true,
    mysql: null,
    sqlite3: null,
    pg: null,
  },
  ordering: "causal",
  "collapse-package-hierachy": false,
  serialization: {
    "maximum-print-length": 100,
    "maximum-properties-length": 10,
    "impure-printing": true,
    "impure-constructor-naming": true,
    "impure-array-inspection": true,
    "impure-error-inspection": true,
    "impure-hash-inspection": true,
  },
  language: "javascript",
  "default-package": {
    enabled: false,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
  },
  packages: [],
  exclude: [
    {
      combinator: "or",
      name: true,
      "qualified-name": true,
      "every-label": true,
      "some-label": true,
      excluded: false,
      recursive: false,
    },
  ],
  pruning: true,
  name: null,
  "map-name": null,
});

const extendConfiguration = (
  internal_configuration,
  external_configuration,
  base,
) => {
  const extended_internal_configuration = { ...internal_configuration };
  validateExternalConfiguration(external_configuration);
  for (const key of ownKeys$1(external_configuration)) {
    if (hasOwnProperty(fields, key)) {
      const { normalize, extend } = fields[key];
      extended_internal_configuration[key] = extend(
        extended_internal_configuration[key],
        normalize(external_configuration[key], base),
      );
    } else {
      logInfoWhen(
        !EXPECTED_EXTRA_PROPERTIES.includes(key),
        "Configuration property not recognized by the agent: %j",
        key,
      );
    }
  }
  return extended_internal_configuration;
};

const {
  URL,
  Map,
  JSON: { parse: parseJSON, stringify: stringifyJSON },
  Reflect: { ownKeys },
  Array: { isArray },
} = globalThis;

const { parse: parseYAML, stringify: stringifyYAML } = YAML;

const parsers = new Map([
  [".json", parseJSON],
  [".yml", parseYAML],
  [".yaml", parseYAML],
]);

const stringifiers = new Map([
  [".json", stringifyJSON],
  [".yml", stringifyYAML],
  [".yaml", stringifyYAML],
]);

const default_external_configuration = {
  packages: [
    {
      regexp: "^../",
      enabled: false,
    },
    {
      regexp: "(^|/)node_modules/",
      enabled: false,
    },
    {
      regexp: "",
      enabled: true,
    },
  ],
  "default-package": {
    enabled: false,
  },
  exclude: [
    {
      combinator: "and",
      name: "^\\[anonymous\\]$",
      "every-label": "^\\b$",
      excluded: true,
      recursive: false,
    },
  ],
};

const parseConfigurationFile = (parse, content, url) => {
  try {
    return parse(content);
  } catch (error) {
    logError("Failed to parse configuration file at %j >> %O", url, error);
    throw new ExternalAppmapError("Failed to parse configuration file");
  }
};

const loadConfigFile = (url) => {
  const extension = getLastUrlExtension(url);
  assert(
    !logErrorWhen(
      !parsers.has(extension),
      "Unsupported configuration file extension %j from %j.",
      extension,
      url,
    ),
    "Unsupported configuration file extension",
    ExternalAppmapError,
  );
  const parse = parsers.get(extension);
  let content = null;
  try {
    content = readFileSync(new URL(url), "utf8");
  } catch (error) {
    const { code } = error;
    assert(
      !logErrorWhen(
        code !== "ENOENT",
        "Cannot read configuration file at %j >> %O",
        url,
        error,
      ),
      "Cannot read configuration file",
      ExternalAppmapError,
    );
    const stringify = stringifiers.get(extension);
    writeFileSync(
      new URL(url),
      stringify(default_external_configuration),
      "utf8",
    );
    return default_external_configuration;
  }
  return parseConfigurationFile(parse, content, url);
};

const aliases = new Map([
  ["appmap-dir", "appmap_dir"],
  ["app-port", "intercept-track-port"],
  ["alt-remote-port", "track-port"],
  ["package", "packages"],
  ["process", "processes"],
]);

const wrapArray = (value) => (isArray(value) ? value : [value]);

const transformers = new Map([
  ["packages", wrapArray],
  ["processes", wrapArray],
]);

const addOption = (options, key, value) => {
  if (hasOwnProperty(options, key)) {
    let existing_value = options[key];
    if (!isArray(existing_value)) {
      existing_value = [existing_value];
    }
    if (!isArray(value)) {
      value = [value];
    }
    options[key] = [...existing_value, ...value];
  } else {
    options[key] = value;
  }
};

const extractConfig = (argv) => {
  const { _: positional, ...config } = minimist(argv.slice(2));
  if (positional.length > 0) {
    assert(
      !logErrorWhen(
        hasOwnProperty(config, "command"),
        "The command should not be specified both as positional arguments and in --command",
      ),
      "Conflicting command arguments",
      ExternalAppmapError,
    );
    addOption(config, "command", positional);
  } else {
    assert(
      !logErrorWhen(
        hasOwnProperty(config, "command") && typeof config.command !== "string",
        "There should be only one --command argument",
      ),
      "Too many command arguments",
      ExternalAppmapError,
    );
  }
  for (const key of ownKeys(config)) {
    if (aliases.has(key)) {
      const value = config[key];
      delete config[key];
      addOption(config, aliases.get(key), value);
    }
  }
  for (const key of ownKeys(config)) {
    if (transformers.has(key)) {
      config[key] = transformers.get(key)(config[key]);
    }
  }
  config.log = {};
  if (hasOwnProperty(config, "log-level")) {
    config.log.level = config["log-level"];
    delete config["log-level"];
  }
  if (hasOwnProperty(config, "log-file")) {
    config.log.file = config["log-file"];
    delete config["log-file"];
  }
  return config;
};

const loadProcessConfiguration = (process) => {
  const cwd = getCwdUrl(process);
  const url = toAbsoluteUrl(
    coalesce(process.env, "APPMAP_CONFIGURATION_PATH", "appmap.yml"),
    cwd,
  );
  return extendConfiguration(
    extendConfiguration(
      createConfiguration(
        toDirectoryUrl(
          toAbsoluteUrl(
            coalesce(process.env, "APPMAP_REPOSITORY_DIRECTORY", "."),
            cwd,
          ),
        ),
      ),
      loadConfigFile(url),
      url,
    ),
    extractConfig(process.argv),
    cwd,
  );
};

export { loadProcessConfiguration };
