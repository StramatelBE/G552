import process from 'node:process';
import Http, { createServer } from 'node:http';
import { readFile as readFile$1 } from 'node:fs/promises';
import { URL as URL$4, pathToFileURL, fileURLToPath } from 'node:url';
import { performance } from 'node:perf_hooks';
import { executionAsyncId, createHook } from 'node:async_hooks';
import * as Astring from 'astring';
import { openSync, writeSync, readFileSync } from 'node:fs';
import { decode } from 'vlq';
import BabelParser from '@babel/parser';
import Minimatch from 'minimatch';
import { createHash } from 'node:crypto';
import Module, { createRequire } from 'node:module';
import { platform } from 'node:os';
import { win32, posix } from 'node:path';
import { Buffer as Buffer$1 } from 'node:buffer';
import { hooks, loadDefault, transformSourceDefault } from '../../lib/node/loader-esm.mjs';
import Https from 'node:https';
import 'node:child_process';
import { Socket } from 'node:net';
import NetSocketMessaging from 'net-socket-messaging';

const { decodeURIComponent: decodeURIComponent$1, encodeURIComponent } = globalThis;

const getDrive = (protocol, pathname) =>
  protocol.toLowerCase() === "file:"
    ? /^\/[a-zA-Z]:\//u.test(pathname)
      ? pathname[1].toLowerCase()
      : null
    : null;

const normalizeCase = (pathname, drive) =>
  drive === null ? pathname : pathname.toLowerCase();

const toAbsoluteUrl = (relative, base_url) =>
  new URL$4(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toRelativeUrl = (
  url,
  base_url,
  encodeSegment = encodeURIComponent,
) => {
  const { protocol, host, pathname, search, hash } = new URL$4(url);
  const {
    protocol: base_protocol,
    host: base_host,
    pathname: base_pathname,
  } = new URL$4(base_url);
  if (
    protocol.toLowerCase() !== base_protocol.toLowerCase() ||
    host.toLowerCase() !== base_host.toLowerCase()
  ) {
    return null;
  } else {
    const drive = getDrive(protocol, pathname);
    const base_drive = getDrive(base_protocol, base_pathname);
    if (drive !== base_drive) {
      return null;
    } else {
      const segments = normalizeCase(pathname, drive)
        .split("/")
        .map(decodeURIComponent$1);
      const base_segments = normalizeCase(base_pathname, base_drive)
        .split("/")
        .map(decodeURIComponent$1);
      base_segments.pop();
      while (
        segments.length > 0 &&
        base_segments.length > 0 &&
        segments[0] === base_segments[0]
      ) {
        segments.shift();
        base_segments.shift();
      }
      while (base_segments.length > 0) {
        base_segments.pop();
        segments.unshift("..");
      }
      if (segments.length > 0 && segments[0] !== "") {
        return `${segments.map(encodeSegment).join("/")}${search}${hash}`;
      } else {
        return `.${search}${hash}`;
      }
    }
  }
};

const toDirectoryUrl = (url) => {
  const url_obj = new URL$4(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Alternatively:
//   url.match(/:\/{0,2}.*\/([^/#]+)(#.*)?$/)[1]
const getUrlFilename = (url) => {
  const { pathname } = new URL$4(url);
  if (pathname === "" || pathname.endsWith("/")) {
    return null;
  } else {
    return pathname.substring(pathname.lastIndexOf("/") + 1);
  }
};

// Alternatively:
//   url.match(/([^.\/]+)(\.[^/#]*)(#.*)?$/)[1]
const getUrlBasename = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(0, filename.indexOf("."));
  } else {
    return filename;
  }
};

const prefixDot = (string) => `.${string}`;

const getUrlExtensionArray = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else {
    const extensions = filename.split(".");
    extensions.shift();
    return extensions.map(prefixDot);
  }
};

// Alternatively:
//   url.match(/([^\/]+)(\.[^/#]*)(#.*)?$/)[2]
const getLastUrlExtension = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(filename.lastIndexOf("."));
  } else {
    return null;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$3,
  JSON: { parse: parseJSON$3 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$3(
  await readFile$1(
    new URL$3(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$7 } = globalThis;

class AppmapError extends Error$7 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const { Error: Error$6 } = globalThis;

class AssertionError extends Error$6 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const createBox = (value) => ({ value });
const getBox = ({ value }) => value;
const setBox = (box, value) => {
  box.value = value;
};

const {
  Boolean,
  String: String$7,
  Number,
  parseInt: parseInt$2,
  Array: { isArray: isArray$7 },
  Number: {
    isNaN: isNaN$1,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
    MIN_SAFE_INTEGER,
  },
  Math: { round: round$2 },
  JSON: { stringify: stringifyJSON$4 },
} = globalThis;

const toInteger = (any) => {
  if (typeof any === "boolean") {
    return Number(any);
  } else if (typeof any === "number") {
    if (any < MIN_SAFE_INTEGER) {
      return NEGATIVE_INFINITY;
    } else if (any > MAX_SAFE_INTEGER$1) {
      return POSITIVE_INFINITY;
    } else {
      return round$2(any);
    }
  } else if (typeof any === "bigint") {
    if (any < MIN_SAFE_INTEGER) {
      return NEGATIVE_INFINITY;
    } else if (any > MAX_SAFE_INTEGER$1) {
      return POSITIVE_INFINITY;
    } else {
      return Number(any);
    }
  } else if (typeof any === "string") {
    return parseInt$2(any);
  } else {
    return NaN$1;
  }
};

const toNumber = (any) => {
  if (typeof any === "boolean") {
    return any ? 1 : 0;
  } else if (typeof any === "number") {
    return any;
  } else if (typeof any === "bigint") {
    return Number(any);
  } else if (typeof any === "string") {
    return Number(any);
  } else {
    return NaN$1;
  }
};

const toString = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$7(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else {
    return String$7(any);
  }
};

const print$1 = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$7(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$4(any);
  } else {
    return String$7(any);
  }
};

const jsonifyNumber = (number, replacements) => {
  if (number === NEGATIVE_INFINITY) {
    return replacements.NEGATIVE_INFINITY;
  } else if (number === POSITIVE_INFINITY) {
    return replacements.POSITIVE_INFINITY;
  } else if (isNaN$1(number)) {
    return replacements.NaN;
  } else {
    return number;
  }
};

const {
  Error: Error$5,
  String: String$6,
  JSON: { stringify: stringifyJSON$3 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$3(value);
      }
      if (marker === "O") {
        try {
          return String$6(value);
        } catch {
          return print$1(value);
        }
      }
      if (marker === "o") {
        return print$1(value);
      }
      throw new Error$5("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const createCounter = (value) => ({ value });
const incrementCounter = (counter) => (counter.value += 1);

const {
  Error: Error$4,
  Reflect: { apply: apply$7 },
  WeakMap: WeakMap$1,
} = globalThis;

new WeakMap$1();

const noop = () => {};
const identity = (x) => x;

const spyOnce = (spy, forward) => {
  let called = false;
  return function (...args) {
    if (!called) {
      called = true;
      apply$7(spy, this, args);
    }
    return apply$7(forward, this, args);
  };
};

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const fromMaybe = (maybe, recovery, transform) =>
  maybe === null ? recovery : transform(maybe);

const mapMaybe = (maybe, transform) =>
  maybe === null ? null : transform(maybe);

const {
  undefined: undefined$b,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$4, ownKeys: ownKeys$3, defineProperty: defineProperty$2 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$4(Object$1, "hasOwn") === undefined$b
    ? (object, key) => getOwnPropertyDescriptor$4(object, key) !== undefined$b
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const assignProperty = ({ object, key, value }) => {
  object[key] = value;
};

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$a,
  ReferenceError,
  Reflect: { defineProperty: defineProperty$1 },
} = globalThis;

const defineGlobal = (name, value, writable = false) => {
  if (!hasOwnProperty(globalThis, name)) {
    return defineProperty$1(globalThis, name, {
      __proto__: null,
      value,
      writable,
      configurable: false,
      enumerable: false,
    });
  } else {
    return false;
  }
};

const writeGlobal = (name, value) => {
  if (hasOwnProperty(globalThis, name)) {
    globalThis[name] = value;
    return undefined$a;
  } else {
    throw ReferenceError("missing global variable");
  }
};

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

const {
  Math: { round: round$1 },
} = globalThis;

const now$1 = () => round$1(1000 * performance.now()) / 1000;

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$2 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$2(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$1 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$1(fd, "DEBUG"),
    logInfo: generateLog$1(fd, "INFO"),
    logWarning: generateLog$1(fd, "WARNING"),
    logError: generateLog$1(fd, "ERROR"),
  };
};

const { logDebug: logDebug$1, logInfo: logInfo$1, logWarning: logWarning$1, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

const { log: logDebug, logWhen: logDebugWhen } = generateLog(
  "debug",
  logDebug$1,
);

const { log: logInfo, logWhen: logInfoWhen } = generateLog(
  "info",
  logInfo$1,
);

const { log: logWarning, logWhen: logWarningWhen } = generateLog(
  "warning",
  logWarning$1,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const validateSourceMap = noop;

const {
  JSON: { parse: parseJSON$2 },
} = globalThis;

const extractSourcemapUrl = ({ url, content }) => {
  const parts = /\/\/[#@] sourceMappingURL=(.*)[\s]*$/u.exec(content);
  if (parts === null) {
    return null;
  } else {
    return toAbsoluteUrl(parts[1], url);
  }
};

const parseSourcemapJson = ({ url, content }) => {
  try {
    return parseJSON$2(content);
  } catch (error) {
    logWarning("Could not parse source map at %j >> %O", url, error);
    return null;
  }
};

const isSourcemapValid = ({ url, data }) => {
  try {
    validateSourceMap(data);
    return true;
  } catch (error) {
    logWarning("Invalid source map at %j >> %O", url, error);
    return false;
  }
};

const parseSourcemap = (file, base) => {
  const { url } = file;
  const data = parseSourcemapJson(file);
  if (data === null || !isSourcemapValid({ url, data })) {
    return null;
  } else {
    const {
      sourceRoot: root,
      sources: relatives,
      sourcesContent: contents,
      mappings: payload,
    } = {
      sourceRoot: null,
      sourcesContent: null,
      ...data,
    };
    if (!url.startsWith("data:")) {
      base = url;
    }
    if (root !== null && root !== "") {
      base = toDirectoryUrl(toAbsoluteUrl(root, url));
    }
    return {
      sources: relatives.map((relative, index) => ({
        url: toAbsoluteUrl(relative, base),
        content:
          contents === null || index >= contents.length
            ? null
            : contents[index],
      })),
      payload,
    };
  }
};

const compileSourcemap = (payload) => {
  let source_index = 0;
  let source_line = 0;
  let source_column = 0;
  return payload.split(";").map((group) => {
    if (group === "") {
      return [];
    } else {
      let generated_column = 0;
      return group.split(",").map((segment) => {
        const fields = decode(segment);
        /* c8 ignore start */ if (fields.length === 1) {
          return [(generated_column += fields[0])];
        } /* c8 ignore stop */ else {
          return [
            (generated_column += fields[0]),
            (source_index += fields[1]),
            (source_line += fields[2]),
            (source_column += fields[3]),
          ];
        }
      });
    }
  });
};

const mapPosition = (mapping, { line, column }) => {
  if (line > 0 && line <= mapping.length) {
    for (const fields of mapping[line - 1]) {
      if (fields[0] === column && fields.length >= 4) {
        const [, source_index, mapped_line, mapped_column] = fields;
        return {
          index: source_index,
          position: {
            line: mapped_line + 1,
            column: mapped_column,
          },
        };
      }
    }
    return null;
  } else {
    return null;
  }
};

const { parse: parseBabel } = BabelParser;

const getLeadingCommentArray = (node) =>
  coalesce(node, "leadingComments", []);

const trimStartString = (string) => string.trimStart();

const extractLineLabel = (line) => {
  assert(line.startsWith("@label "), "invalid label line", InternalAppmapError);
  const maybe_tokens = line.substring("@label".length).match(/\s+\S+/gu);
  return maybe_tokens === null ? [] : maybe_tokens.map(trimStartString);
};

const extractCommentLabelArray = ({ value: text }) => {
  const maybe_lines = text.match(/@label .*/gu);
  return maybe_lines === null ? [] : maybe_lines.flatMap(extractLineLabel);
};

const resolveSource = (source, { url }) => {
  if (source === null) {
    const extension = getLastUrlExtension(url);
    if (extension === ".cjs" || extension === ".cts" || extension === ".node") {
      return "script";
    } else if (extension === ".mjs" || extension === ".mts") {
      return "module";
    } else {
      return "unambiguous";
    }
  } else {
    return source;
  }
};

const resolvePluginArray = (plugins, { url, content }) => {
  if (plugins === null) {
    const extensions = getUrlExtensionArray(url);
    const plugins = [];
    if (extensions.includes(".jsx")) {
      plugins.push(["jsx", {}]);
    }
    if (
      extensions.includes(".ts") ||
      extensions.includes(".mts") ||
      extensions.includes(".cts")
    ) {
      plugins.push(["typescript", {}]);
    }
    if (
      extensions.includes(".tsx") ||
      extensions.includes(".mtsx") ||
      extensions.includes(".ctsx")
    ) {
      plugins.push(["jsx", {}], ["typescript", {}]);
    }
    if (
      extensions.includes(".flow") ||
      /^[ \t\n]*\/(\/[ \t]*|\*[ \t\n]*)@flow/u.test(content)
    ) {
      plugins.push(["flow", {}]);
    }
    return plugins;
  } else {
    return plugins;
  }
};

const parseSafe = ({ url, content }, options) => {
  try {
    return parseBabel(content, options);
  } catch (error) {
    logError("Unrecoverable parsing error at file %j >> %O", url, error);
    const { sourceType: source_type } = options;
    return {
      errors: [],
      program: {
        type: "Program",
        body: [],
        sourceType: source_type === "unambiguous" ? "script" : source_type,
        loc: {
          start: { line: 0, column: 0 },
          end: { line: 0, column: 0 },
          filename: url,
        },
      },
    };
  }
};

const parseEstree = (file, { source, plugins }) => {
  const { url } = file;
  const { errors, program: node } = parseSafe(file, {
    sourceFilename: url,
    sourceType: resolveSource(source, file),
    plugins: [
      ["estree", { classFeatures: true }],
      ...resolvePluginArray(plugins, file),
    ],
    errorRecovery: true,
    attachComment: true,
  });
  for (const error of errors) {
    logWarning("Recoverable parsing error at file %j >> %O", url, error);
  }
  return node;
};

const {
  String: String$5,
  parseInt: parseInt$1,
  Infinity: Infinity$1,
  Math: { abs },
} = globalThis;

const stringifyPosition = ({ line, column }) =>
  `${String$5(line)}:${String$5(column)}`;

const parsePosition = (string) => {
  const parts = /^([0-9]+):([0-9]+)$/u.exec(string);
  assert(parts !== null, "invalid position format", InternalAppmapError);
  return {
    line: parseInt$1(parts[1]),
    column: parseInt$1(parts[2]),
  };
};

const measurePositionDistance = (
  { line: line1, column: column1 },
  { line: line2, column: column2 },
  { line_weight, column_weight },
) => line_weight * abs(line2 - line1) + column_weight * abs(column2 - column1);

const resolvePosition = (map, position1, options) => {
  const key1 = stringifyPosition(position1);
  if (map.has(key1)) {
    return position1;
  } else {
    let best_distance = Infinity$1;
    let best_position = null;
    for (const key2 of map.keys()) {
      const position2 = parsePosition(key2);
      const distance = measurePositionDistance(position1, position2, options);
      if (distance < best_distance) {
        best_distance = distance;
        best_position = position2;
      }
    }
    const { threshold } = options;
    return best_distance <= threshold ? best_position : null;
  }
};

/* eslint-disable no-use-before-define */

const {
  Object: { entries: toEntries$4 },
  Array: { isArray: isArray$6 },
} = globalThis;

const ANONYMOUS = "[anonymous]";

const DYNAMIC = "[dynamic]";

const getBoundary = ({ start, end }) => ({ start, end });

const getHead = ({ head }) => head;

const getRest = ({ rest }) => rest;

const combine$1 = (results) => ({
  head: results.flatMap(getHead),
  rest: results.flatMap(getRest),
});

const isContainerNodeType = (type) =>
  type === "FunctionExpression" ||
  type === "FunctionDeclaration" ||
  type === "ArrowFunctionExpression" ||
  type === "ClassExpression" ||
  type === "ClassDeclaration" ||
  type === "ObjectExpression";

const getContainerName = (node, name) => {
  if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
    return name === ANONYMOUS && node.id !== null ? node.id.name : name;
  } else if (
    node.type === "FunctionDeclaration" ||
    node.type === "ClassDeclaration"
  ) {
    return node.id === null ? "default" : node.id.name;
  } else if (
    node.type === "ArrowFunctionExpression" ||
    node.type === "ObjectExpression"
  ) {
    return name;
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid container node");
  } /* c8 ignore stop */
};

/////////////
// factory //
/////////////

const createFileEntity = (name, children, node) => ({
  type: "file",
  excluded: false,
  labels: getLeadingCommentArray(node).flatMap(extractCommentLabelArray),
  name,
  children,
});

const createClassEntity = (name, children, node) => ({
  type: "class",
  excluded: false,
  labels: getLeadingCommentArray(node).flatMap(extractCommentLabelArray),
  name,
  children,
});

const createClosureEntity = (name, children, node, is_static) => {
  const comments = getLeadingCommentArray(node);
  return {
    type: "closure",
    excluded: false,
    name,
    children,
    used: false,
    static: is_static,
    comments,
    labels: comments.flatMap(extractCommentLabelArray),
    parameters: node.params.map(getBoundary),
    boundary: getBoundary(node),
    position: { ...node.loc.start }, // cleanup prototype
  };
};

/////////////
// visitor //
/////////////

const visitProgram = (node, name) => {
  if (node.type === "Program") {
    return createFileEntity(
      name,
      node.body.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      node,
    );
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid program node");
  } /* c8 ignore stop */
};

const visitAny = (any) => {
  if (isArray$6(any)) {
    return any.flatMap(visitAny);
  } else if (
    typeof any === "object" &&
    any !== null &&
    hasOwnProperty(any, "type") &&
    typeof any.type === "string"
  ) {
    return visitNode$1(any, ANONYMOUS);
  } else {
    return [];
  }
};

const visitContainerNode = (node, name) => {
  if (
    node.type === "FunctionExpression" ||
    node.type === "FunctionDeclaration" ||
    node.type === "ArrowFunctionExpression"
  ) {
    return {
      head: [
        createClosureEntity(
          getContainerName(node, name),
          [
            ...node.params.flatMap((child) => visitNode$1(child, ANONYMOUS)),
            ...visitNode$1(node.body, ANONYMOUS),
          ],
          node,
          false,
        ),
      ],
      rest: [],
    };
  } else if (
    node.type === "ClassExpression" ||
    node.type === "ClassDeclaration"
  ) {
    const { head, rest } = visitClassBody(node.body);
    return {
      head: [createClassEntity(getContainerName(node, name), head, node)],
      rest: [
        ...(node.superClass === null
          ? []
          : visitNode$1(node.superClass, ANONYMOUS)),
        ...rest,
      ],
    };
  } else if (node.type === "ObjectExpression") {
    const { head, rest } = combine$1(node.properties.map(visitObjectProperty));
    return {
      head: [createClassEntity(getContainerName(node, name), head, node)],
      rest,
    };
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid container node type");
  } /* c8 ignore stop */
};

const visitEntry = ([key, value]) => {
  if (key === "type" || key === "start" || key === "end" || key === "loc") {
    return [];
  } else {
    return visitAny(value);
  }
};

const visitNode$1 = (node, name) => {
  if (node.type === "AssignmentExpression") {
    return [
      ...visitNode$1(node.left, ANONYMOUS),
      ...visitNode$1(
        node.right,
        node.left.type === "Identifier" ? node.left.name : ANONYMOUS,
      ),
    ];
  } else if (node.type === "VariableDeclarator") {
    return [
      ...visitNode$1(node.id, ANONYMOUS),
      ...(node.init === null
        ? []
        : visitNode$1(
            node.init,
            node.id.type === "Identifier" ? node.id.name : ANONYMOUS,
          )),
    ];
  } else if (node.type === "ConditionalExpression") {
    return [
      ...visitNode$1(node.test, ANONYMOUS),
      ...visitNode$1(node.consequent, name),
      ...visitNode$1(node.alternate, name),
    ];
  } else if (node.type === "SequenceExpression") {
    const children = node.expressions.slice();
    const last_child = children.pop();
    return [
      ...children.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      ...visitNode$1(last_child, name),
    ];
  } else if (node.type === "LogicalExpression") {
    return [...visitNode$1(node.left, name), ...visitNode$1(node.right, name)];
  } else if (isContainerNodeType(node.type)) {
    const { head, rest } = visitContainerNode(node, name);
    return [...head, ...rest];
  } else {
    return toEntries$4(node).flatMap(visitEntry);
  }
};

const visitClassBody = (node) => {
  if (node.type === "ClassBody") {
    return combine$1(node.body.map(visitClassProperty));
  } /* c8 ignore start */ else {
    logWarning("unrecognized class body node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitClassProperty = (node) => {
  if (node.type === "MethodDefinition") {
    return {
      rest: visitNode$1(node.key, ANONYMOUS),
      head: visitClassMethod(
        node.value,
        !node.computed && node.key.type === "Identifier"
          ? node.key.name
          : DYNAMIC,
        node.static,
      ),
    };
  } else if (node.type === "PropertyDefinition") {
    return combine$1([
      { head: [], rest: visitNode$1(node.key, ANONYMOUS) },
      node.value === null
        ? { head: [], rest: [] }
        : visitPropertyValue(
            node.value,
            !node.computed && node.key.type === "Identifier"
              ? node.key.name
              : DYNAMIC,
          ),
    ]);
  } /* c8 ignore start */ else {
    logWarning("unrecognized class property node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitClassMethod = (node, name, is_static) => {
  if (node.type === "FunctionExpression") {
    return createClosureEntity(
      name,
      [
        ...node.params.flatMap((child) => visitNode$1(child, ANONYMOUS)),
        .../* typescript abstract method */
        (hasOwnProperty(node, "body") && node.body !== null
          ? visitNode$1(node.body, ANONYMOUS)
          : []),
      ],
      node,
      is_static,
    );
  } /* c8 ignore start */ else {
    logWarning("unrecognized class method node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitObjectProperty = (node) => {
  if (node.type === "Property") {
    return combine$1([
      { head: [], rest: visitNode$1(node.key, ANONYMOUS) },
      visitPropertyValue(
        node.value,
        !node.computed && node.key.type === "Identifier"
          ? node.key.name
          : DYNAMIC,
      ),
    ]);
  } else if (node.type === "SpreadElement") {
    return {
      head: [],
      rest: visitNode$1(node.argument, ANONYMOUS),
    };
  } /* c8 ignore start */ else {
    logWarning("unrecognized object property node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitPropertyValue = (node, name) => {
  if (node.type === "LogicalExpression") {
    return combine$1([
      visitPropertyValue(node.left, name),
      visitPropertyValue(node.right, name),
    ]);
  } else if (node.type === "ConditionalExpression") {
    return combine$1([
      { head: [], rest: visitNode$1(node.test, ANONYMOUS) },
      visitPropertyValue(node.consequent, name),
      visitPropertyValue(node.alternate, name),
    ]);
  } else if (node.type === "SequenceExpression") {
    const children = node.expressions.slice();
    const last_child = children.pop();
    return combine$1([
      {
        head: [],
        rest: children.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      },
      visitPropertyValue(last_child, name),
    ]);
  } else if (isContainerNodeType(node.type)) {
    return visitContainerNode(node, name);
  } else {
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  }
};

////////////
// export //
////////////

const toEntity = visitProgram;

const {
  RegExp: RegExp$2,
  Object: { entries: toEntries$3 },
} = globalThis;

const compileClause = ([name, pattern]) => {
  if (typeof pattern === "boolean") {
    return (_node, _naming) => pattern;
  } else if (typeof pattern === "string") {
    const regexp = new RegExp$2(pattern, "u");
    const predicate = (string) => regexp.test(string);
    if (name === "name") {
      return (entity, _parent) => predicate(entity.name);
    } else if (name === "qualified-name") {
      return (entity, parent) =>
        predicate(
          entity.type === "closure"
            ? `${parent.name}${entity.static ? "#" : "."}${entity.name}`
            : entity.name,
        );
    } else if (name === "some-label") {
      return (entity, _parent) => entity.labels.some(predicate);
    } else if (name === "every-label") {
      return (entity, _parent) => entity.labels.every(predicate);
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid clause name");
    } /* c8 ignore stop */
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid clause pattern type");
  } /* c8 ignore stop */
};

const compileClauseArray = (combinator, clauses) => {
  const predicates = toEntries$3(clauses).map(compileClause);
  if (combinator === "and") {
    return (node, naming) =>
      predicates.every((predicate) => predicate(node, naming));
  } else if (combinator === "or") {
    return (node, naming) =>
      predicates.some((predicate) => predicate(node, naming));
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid exclusion combinator");
  } /* c8 ignore stop */
};

const compileCriterion = ({ combinator, excluded, recursive, ...clauses }) => {
  const predicate = compileClauseArray(combinator, clauses);
  const spec = { excluded, recursive };
  return (node, naming) => (predicate(node, naming) ? spec : null);
};

const compileCriteria = (criteria) => {
  const closures = criteria.map(compileCriterion);
  return (node, naming) => {
    for (const closure of closures) {
      const maybe_spec = closure(node, naming);
      if (maybe_spec !== null) {
        return maybe_spec;
      }
    }
    throw new InternalAppmapError("missing matching exclusion criterion");
  };
};

const { Map: Map$4, String: String$4 } = globalThis;

const getChild = (object, index) => object.children[index];

////////////
// Create //
////////////

const registerClosure = (entity, path, closures) => {
  if (entity.type === "closure") {
    closures.set(stringifyPosition(entity.position), path);
  }
  const { length } = entity.children;
  for (let index = 0; index < length; index += 1) {
    registerClosure(
      entity.children[index],
      `${path}/${String$4(index)}`,
      closures,
    );
  }
};

const registerClosureRoot = (entity) => {
  assert(
    entity.type === "file",
    "root entity should be a file",
    InternalAppmapError,
  );
  const closures = new Map$4();
  const { length } = entity.children;
  for (let index = 0; index < length; index += 1) {
    registerClosure(entity.children[index], String$4(index), closures);
  }
  return closures;
};

const createSource$1 = ({ url, content, program }) => {
  const entity = toEntity(program, getUrlBasename(url));
  return {
    url,
    content,
    program,
    root: entity,
    closures: registerClosureRoot(entity),
  };
};

/////////////
// Exclude //
/////////////

const excludeEntityDeeply = (entity, excluded) => {
  entity.excluded = excluded;
  for (const child of entity.children) {
    excludeEntityDeeply(child, excluded);
  }
};

const excludeEntity = (entity, parent, exclude) => {
  const { excluded, recursive } = exclude(entity, parent);
  if (recursive) {
    excludeEntityDeeply(entity, excluded);
  } else {
    entity.excluded = excluded;
    for (const child of entity.children) {
      excludeEntity(child, entity, exclude);
    }
  }
};

const applyExclusionCriteria = ({ root }, criteria) => {
  excludeEntity(root, null, compileCriteria(criteria));
};

///////////
// Query //
///////////

const LINE_WEIGHT = 1024;
const COLUMN_WEIGHT = 1;
const THRESHOLD = 10 * LINE_WEIGHT;

const DISTANCE_OPTIONS = {
  line_weight: LINE_WEIGHT,
  column_weight: COLUMN_WEIGHT,
  threshold: THRESHOLD,
};

const resolveClosurePosition = ({ closures }, position) =>
  resolvePosition(closures, position, DISTANCE_OPTIONS);

const isClosurePositionExcluded = ({ closures, root }, position) => {
  const key = stringifyPosition(position);
  assert(closures.has(key), "missing closure", InternalAppmapError);
  return closures.get(key).split("/").reduce(getChild, root).excluded;
};

const { Minimatch: MinimatchClass } = Minimatch;

const compileGlob = (glob) => new MinimatchClass(glob).makeRe();

const { Map: Map$3, RegExp: RegExp$1 } = globalThis;

const regexps = new Map$3();

const makeRegExp = (source, flags) => {
  try {
    return new RegExp$1(source, flags);
  } catch (error) {
    logError(
      "Failed to compile regexp source %j with flags %j >> %O",
      source,
      flags,
      error,
    );
    throw new ExternalAppmapError("Failed to compile matcher regexp");
  }
};

const makeRegExpCache = (source, flags) => {
  const key = `/${source}/${flags}`;
  if (regexps.has(key)) {
    return regexps.get(key);
  } else {
    const regexp = makeRegExp(source, flags);
    regexps.set(key, regexp);
    return regexp;
  }
};

const escape = (char) => `\\${char}`;

const sanitizeForRegExp = (string) =>
  string.replace(/[/\\+*?.^$()[\]{}|]/gu, escape);

// const sanitizeForGlob = (string) => string.replace(/[*?[\]]/g, escape);

const toTargetRegExp = (target, recursive) => {
  if (recursive) {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}`;
    } else {
      return `^${sanitizeForRegExp(target)}(/|$)`;
    }
  } else {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}[^/]*$`;
    } else {
      return `^${sanitizeForRegExp(target)}$`;
    }
  }
};

const createMatcher = (options, base) => {
  const {
    glob,
    url,
    path,
    dist,
    regexp,
    flags,
    recursive,
    external,
    relative,
  } = {
    glob: null,
    path: null,
    url: null,
    dist: null,
    regexp: null,
    flags: "",
    recursive: true,
    external: false,
    relative: true,
    ...options,
  };
  if (regexp !== null) {
    return {
      base: relative ? base : null,
      source: regexp,
      flags,
    };
  }
  if (glob !== null) {
    const { source, flags } = compileGlob(glob);
    return {
      base,
      source,
      flags,
    };
  }
  if (path !== null) {
    return {
      base,
      source: toTargetRegExp(path, recursive),
      flags: "",
    };
  }
  if (url !== null) {
    return {
      base: null,
      source: toTargetRegExp(url, recursive),
      flags: "",
    };
  }
  if (dist !== null) {
    assert(
      dist[dist.length - 1] !== "/",
      "package path should not end with a path separator",
      InternalAppmapError,
    );
    let source = `node_modules/${sanitizeForRegExp(dist)}/`;
    if (!external) {
      source = `^${source}`;
    }
    if (!recursive) {
      source = `${source}[^/]*$`;
    }
    return {
      base,
      source,
      flags: "",
    };
  }
  throw new InternalAppmapError("invalid matcher options");
};

// We escape as few character as possible to hide the fact that configuration fields are urls rather than paths.
const escaping = {
  __proto__: null,
  "/": "%2F",
  "?": "%3F",
  "#": "%23",
};

const escapeCharacter = (match) => escaping[match];

const escapeSegment = (segment) => segment.replace(/[/#?]/gu, escapeCharacter);

const matchUrl = (matcher, url) => {
  const { base, source, flags } = matcher;
  if (base === null) {
    const matched = makeRegExpCache(source, flags).test(url);
    logDebug(
      "url %j %s absolute regexp matcher %j with flags %j",
      url,
      matched ? "matched" : "did not match",
      source,
      flags,
    );
    return matched;
  } else {
    const relative = toRelativeUrl(url, base, escapeSegment);
    if (relative === null) {
      logDebug(
        "could not apply matcher %j because %j cannot be expressed relatively to %j, will treat it as not matched",
        source,
        url,
        base,
      );
      return false;
    } else {
      const matched = makeRegExpCache(source, flags).test(relative);
      logDebug(
        "url %j which resolves to %j relatively to %j %s relative regexp matcher %j with flags %j",
        url,
        relative,
        base,
        matched ? "matched" : "did not match",
        source,
        flags,
      );
      return matched;
    }
  }
};

const lookupUrl = (entries, url, default_value) => {
  for (const [matcher, value] of entries) {
    if (matchUrl(matcher, url)) {
      return value;
    }
  }
  return default_value;
};

const digest = (string) => {
  const hash = createHash("sha256");
  hash.update(string, "utf8");
  return hash.digest("base64");
};

const createSource = (
  { url, content },
  {
    packages: package_matcher_array,
    exclude: global_criteria,
    "default-package": default_package,
    "postmortem-function-exclusion": postmortem,
  },
) => {
  const {
    enabled,
    exclude: local_criteria,
    "source-type": source,
    parsing: plugins,
  } = lookupUrl(package_matcher_array, url, default_package);
  if (enabled) {
    return {
      postmortem,
      enabled: true,
      parsing: { source, plugins },
      criteria: [...local_criteria, ...global_criteria],
      url,
      content,
      hash: null,
      program: null,
      inner: null,
    };
  } else {
    return {
      postmortem,
      enabled: false,
      parsing: { source, plugins },
      criteria: [],
      url,
      content,
      hash: null,
      program: null,
      inner: null,
    };
  }
};

/////////////////////////
// Lazy Initialization //
/////////////////////////

const parseSource = (source) => {
  if (source.program === null) {
    const { url, content, parsing } = source;
    const program = parseEstree({ url, content }, parsing);
    source.program = program;
    return program;
  } else {
    return source.program;
  }
};

const digestSourceContent = (source) => {
  const { content } = source;
  if (source.hash === null && content !== null) {
    const hash = digest(content);
    source.hash = hash;
    return hash;
  } else {
    return source.hash;
  }
};

const toInnerSource = (source) => {
  if (source.inner === null) {
    const { url, content, criteria } = source;
    const program = parseSource(source);
    const inner = createSource$1({ url, content, program });
    applyExclusionCriteria(inner, criteria);
    source.inner = inner;
    return inner;
  } else {
    return source.inner;
  }
};

///////////
// Query //
///////////

const isSourceEnabled = ({ enabled }) => enabled;

const getSourceFile = ({ url, content }) => ({ url, content });

const isSourceContentRequired = ({ enabled, postmortem }) =>
  enabled && postmortem === false;

const isSourcePostmortemExclusion = ({
  postmortem,
  content,
  program,
}) => {
  if (content === null) {
    return true;
  } else if (typeof postmortem === "boolean") {
    return postmortem;
  } else {
    // If the program is already parsed,
    // it reduces of excluding functions here.
    return program === null;
  }
};

const resolveClosureLocation$1 = (source, position) => {
  const { enabled, url } = source;
  if (enabled) {
    if (isSourcePostmortemExclusion(source)) {
      return {
        url,
        hash: digestSourceContent(source),
        position,
      };
    } else {
      const maybe_resolved_position = resolveClosurePosition(
        toInnerSource(source),
        position,
      );
      if (
        maybe_resolved_position === null ||
        isClosurePositionExcluded(
          toInnerSource(source),
          maybe_resolved_position,
        )
      ) {
        return null;
      } else {
        return {
          url,
          hash: digestSourceContent(source),
          position: maybe_resolved_position,
        };
      }
    }
  } else {
    return null;
  }
};

const getUrl = ({ url }) => url;

const extractMissingUrlArray = (url, cache, configuration) => {
  if (cache.has(url)) {
    const content = cache.get(url);
    if (content === null) {
      return [];
    } else {
      const file = { url, content };
      const map_url = extractSourcemapUrl(file);
      if (map_url === null) {
        return [];
      } else {
        if (cache.has(map_url)) {
          const map_content = cache.get(map_url);
          if (map_content === null) {
            return [];
          } else {
            const map_file = {
              url: map_url,
              content: map_content,
            };
            const sourcemap = parseSourcemap(map_file, url);
            if (sourcemap === null) {
              return [];
            } else {
              const { sources } = sourcemap;
              return sources
                .filter(
                  ({ url, content }) =>
                    content === null &&
                    !cache.has(url) &&
                    isSourceContentRequired(
                      createSource({ url, content }, configuration),
                    ),
                )
                .map(getUrl);
            }
          }
        } else {
          return [map_url];
        }
      }
    }
  } else {
    return [url];
  }
};

const loadSourcemap = (file, cache, configuration) => {
  const map_url = extractSourcemapUrl(file);
  if (map_url === null) {
    return null;
  } else {
    const { url } = file;
    if (cache.has(map_url)) {
      const map_content = cache.get(map_url);
      if (map_content === null) {
        return null;
      } else {
        const map_file = {
          url: map_url,
          content: map_content,
        };
        const sourcemap = parseSourcemap(map_file, url);
        if (sourcemap === null) {
          return null;
        } else {
          const { sources, payload } = sourcemap;
          return {
            mapping: compileSourcemap(payload),
            sources: sources.map(({ url, content }) =>
              createSource(
                {
                  url,
                  content:
                    content === null && cache.has(url)
                      ? cache.get(url)
                      : content,
                },
                configuration,
              ),
            ),
          };
        }
      }
    } else {
      return null;
    }
  }
};

const createCodebase = (url, cache, configuration) => {
  assert(cache.has(url), "missing main content", InternalAppmapError);
  const content = cache.get(url);
  assert(
    !logErrorWhen(
      content === null,
      "Cannot not instrument file %j because it could not be loaded",
      url,
    ),
    "missing main content",
    ExternalAppmapError,
  );
  const file = { url, content };
  return {
    main: createSource(file, configuration),
    sourcemap: loadSourcemap(file, cache, configuration),
  };
};

const getEnabledSourceFileArray = ({ main, sourcemap }) =>
  (sourcemap === null ? [main] : sourcemap.sources)
    .filter(isSourceEnabled)
    .map(getSourceFile);

const getMainFile = ({ main }) => getSourceFile(main);

const parseMain = ({ main }) => parseSource(main);

const resolveClosureLocation = ({ main, sourcemap }, position) => {
  if (sourcemap === null) {
    return resolveClosureLocation$1(main, position);
  } else {
    const { sources, mapping } = sourcemap;
    const maybe_indexed_position = mapPosition(mapping, position);
    if (maybe_indexed_position === null) {
      // This is fine, it happens when compilation introduces new functions.
      // eg:
      // ```js
      //   var __importDefault = (this && this.__importDefault) || function (mod) {
      //     return (mod && mod.__esModule) ? mod : { "default": mod };
      //   };
      // ```
      return null;
    } else {
      const { index, position: mapped_position } = maybe_indexed_position;
      if (index >= 0 && index < sources.length) {
        return resolveClosureLocation$1(sources[index], mapped_position);
      } /* c8 ignore start */ else {
        logWarning(
          "Treating %j in %j as excluded because its mapped source index is out-of-range",
          position,
          getSourceFile(main).url,
        );
        return null;
      } /* c8 ignore stop */
    }
  }
};

const { String: String$3, parseInt, undefined: undefined$9 } = globalThis;

const stringifyLocation = ({
  url,
  hash,
  position: { line, column },
}) => {
  if (hash === null) {
    return `${url}:${String$3(line)}:${String$3(column)}`;
  } else {
    return `${hash}|${url}:${String$3(line)}:${String$3(column)}`;
  }
};

const {
  Error: Error$3,
  String: String$2,
  Array: { isArray: isArray$5 },
  Object: { fromEntries: fromEntries$3 },
  Reflect: { ownKeys: ownKeys$2 },
} = globalThis;

//////////////////////////////
// Difficulties with groups //
//////////////////////////////

// import {createHook, executionAsyncId} from "async_hooks";
// createHook({}).enable();
// import {writeFileSync} from "fs";
// const {stdout:{fd}} = process;
// const log = (string) => writeFileSync(fd, `[${executionAsyncId()}] ${string}\n`);
// const logAwait = async (promise) => {
//   log("before");
//   try {
//     await promise;
//   } finally {
//     log("after");
//   }
// };
// const mainAsync = async () => {
//   log("begin");
//   try {
//     await logAwait(new Promise((resolve) => {
//       setTimeout(resolve, 1000, 123);
//     }));
//   } finally {
//     log("end");
//   }
// };
// await mainAsync();

// import {createHook, executionAsyncId} from "async_hooks";
// createHook({}).enable();
// import {writeFileSync} from "fs";
// const {stdout:{fd}} = process;
// const log = (string) => writeFileSync(fd, `[${executionAsyncId()}] ${string}\n`);
// function* logYield (result) {
//   log("before");
//   yield result;
//   log("after");
// };
// async function* main () {
//   log("begin");
//   yield* logYield(123);
//   log("end");
// }
// const iterator = main();
// iterator.next();
// iterator.next();

/////////////
// Builder //
/////////////

const makeProgram = (source, body) => ({
  type: "Program",
  sourceType: source,
  body,
});

const makeClosure = (
  type,
  asynchronous,
  generator,
  expression,
  id,
  params,
  body,
) => ({
  type,
  async: asynchronous,
  generator,
  expression,
  id,
  params,
  body,
});

const makeSequenceExpression = (nodes) => ({
  type: "SequenceExpression",
  expressions: nodes,
});

const makeStatement = (node) => ({
  type: "ExpressionStatement",
  expression: node,
});

const makeIfStatement = (node1, node2, node3) => ({
  type: "IfStatement",
  test: node1,
  consequent: node2,
  alternate: node3,
});

const makeBlockStatement = (nodes) => ({
  type: "BlockStatement",
  body: nodes,
});

const makeAwaitExpression = (node) => ({
  type: "AwaitExpression",
  argument: node,
});

const makeYieldExpression = (delegate, node) => ({
  type: "YieldExpression",
  delegate,
  argument: node,
});

const makeConditionalExpression = (node1, node2, node3) => ({
  type: "ConditionalExpression",
  test: node1,
  consequent: node2,
  alternate: node3,
});

const makeLogicalExpression = (operator, node1, node2) => ({
  type: "LogicalExpression",
  operator,
  left: node1,
  right: node2,
});

const makeCatchClause = (node1, node2) => ({
  type: "CatchClause",
  param: node1,
  body: node2,
});

const makeTryStatement = (node1, node2, node3) => ({
  type: "TryStatement",
  block: node1,
  handler: node2,
  finalizer: node3,
});

const makeRestElement = (node) => ({
  type: "RestElement",
  argument: node,
});

const makeUnaryExpression = (operator, node) => ({
  type: "UnaryExpression",
  prefix: true,
  operator,
  argument: node,
});

const makeBinaryExpression = (operator, node1, node2) => ({
  type: "BinaryExpression",
  operator,
  left: node1,
  right: node2,
});

const makeAssignmentExpression = (node1, node2) => ({
  type: "AssignmentExpression",
  operator: "=",
  left: node1,
  right: node2,
});

const makeArrayExpression = (nodes) => ({
  type: "ArrayExpression",
  elements: nodes,
});

const makeThisExpression = () => ({
  type: "ThisExpression",
});

const makeIdentifier = (name) => ({
  type: "Identifier",
  name,
});

const makeLiteral = (name) => ({
  type: "Literal",
  value: name,
});

const makeVariableDeclaration = (kind, nodes) => ({
  type: "VariableDeclaration",
  kind,
  declarations: nodes,
});

const makeThrowStatement = (node) => ({
  type: "ThrowStatement",
  argument: node,
});

const makeVariableDeclarator = (node1, node2) => ({
  type: "VariableDeclarator",
  id: node1,
  init: node2,
});

const makeCallExpression = (node, nodes) => ({
  type: "CallExpression",
  optional: false,
  callee: node,
  arguments: nodes,
});

const makeExpressionStatement = (node) => ({
  type: "ExpressionStatement",
  expression: node,
});

const makeRegularMemberExpression = (name1, name2) => ({
  type: "MemberExpression",
  optional: false,
  computed: false,
  object: makeIdentifier(name1),
  property: makeIdentifier(name2),
});

const makeReturnStatement = (argument) => ({
  type: "ReturnStatement",
  argument,
});

///////////////
// Component //
///////////////

const isJumpClosureNode = (node) => {
  if (node.type === "Program") {
    return node.sourceType === "module";
  } else if (
    node.type === "FunctionExpression" ||
    node.type === "FunctionDeclaration"
  ) {
    return node.async || node.generator;
  } else if (node.type === "ArrowFunctionExpression") {
    return node.async;
  } /* c8 ignore start */ else {
    throw new Error$3("unexpected closure node");
  } /* c8 ignore stop */
};

const isSubclassConstructor = (_node, parent, grand_parent) =>
  parent.type === "MethodDefinition" &&
  parent.kind === "constructor" &&
  grand_parent.superClass !== null;

const isEstreeKey = (key) => key !== "loc" && key !== "start" && key !== "end";

/* eslint-disable no-use-before-define */
const visitNode = (node, parent, grand_parent, closure, context) => {
  if (isArray$5(node)) {
    return node.map((node) =>
      visitNode(node, parent, grand_parent, closure, context),
    );
  } else if (
    typeof node === "object" &&
    node !== null &&
    hasOwnProperty(node, "type")
  ) {
    if (hasOwnProperty(instrumenters, node.type)) {
      const maybe_node = instrumenters[node.type](
        node,
        parent,
        grand_parent,
        closure,
        context,
      );
      return maybe_node === null
        ? visitGeneric(node, parent, grand_parent, closure, context)
        : maybe_node;
    } else {
      return visitGeneric(node, parent, grand_parent, closure, context);
    }
  } else {
    return node;
  }
};
/* eslint-enable no-use-before-define */

const visitGeneric = (node, parent, _grand_parent, closure, context) =>
  fromEntries$3(
    ownKeys$2(node)
      .filter(isEstreeKey)
      .map((key) => [
        key,
        visitNode(node[key], node, parent, closure, context),
      ]),
  );

const instrumentClosure = (node, parent, grand_parent, closure, context) => {
  const maybe_location = resolveClosureLocation(
    context.codebase,
    node.loc.start,
  );
  closure = {
    node,
    instrumented: context.apply !== null && maybe_location !== null,
  };
  if (closure.instrumented) {
    const location_string = stringifyLocation(maybe_location);
    return makeClosure(
      node.type,
      node.async,
      node.generator,
      false,
      mapMaybe(coalesce(node, "id", null), (child) =>
        visitNode(child, node, parent, closure, context),
      ),
      node.params.map((param, index) => {
        const pattern = makeIdentifier(
          `${context.apply}_ARGUMENT_${String$2(index)}`,
        );
        return param.type === "RestElement"
          ? makeRestElement(pattern)
          : pattern;
      }),
      makeBlockStatement([
        makeVariableDeclaration("var", [
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_BUNDLE_TAB`),
            makeCallExpression(
              makeRegularMemberExpression(context.apply, "getFreshTab"),
              [],
            ),
          ),
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_RESULT`),
            null,
          ),
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_DONE`),
            makeLiteral(false),
          ),
          ...(isJumpClosureNode(node)
            ? [
                makeVariableDeclarator(
                  makeIdentifier(`${context.apply}_JUMP`),
                  null,
                ),
                makeVariableDeclarator(
                  makeIdentifier(`${context.apply}_JUMP_TAB`),
                  makeLiteral(null),
                ),
              ]
            : []),
        ]),
        makeExpressionStatement(
          makeCallExpression(
            makeRegularMemberExpression(context.apply, "recordApply"),
            [
              makeIdentifier(`${context.apply}_BUNDLE_TAB`),
              makeLiteral(location_string),
              node.type === "ArrowFunctionExpression" ||
              isSubclassConstructor(node, parent, grand_parent)
                ? makeRegularMemberExpression(context.apply, "empty")
                : makeThisExpression(),
              makeArrayExpression(
                node.params.map((_param, index) =>
                  makeIdentifier(`${context.apply}_ARGUMENT_${String$2(index)}`),
                ),
              ),
            ],
          ),
        ),
        makeTryStatement(
          makeBlockStatement([
            ...(node.params.length === 0
              ? []
              : [
                  makeVariableDeclaration(
                    "var",
                    node.params.map((param, index) => {
                      if (param.type === "RestElement") {
                        param = param.argument;
                      }
                      // Special case for AssignmentPattern:
                      //
                      // function f (x = {}) {}
                      //
                      // function f (APPMAP_ARGUMENT_0) {
                      //   // does not work :(
                      //   var x = {} = APPMAP_ARGUMENT_0;
                      // }
                      if (param.type === "AssignmentPattern") {
                        return makeVariableDeclarator(
                          param.left,
                          makeConditionalExpression(
                            makeBinaryExpression(
                              "===",
                              makeIdentifier(
                                `${context.apply}_ARGUMENT_${String$2(index)}`,
                              ),
                              makeUnaryExpression("void", makeLiteral(0)),
                            ),
                            param.right,
                            makeIdentifier(
                              `${context.apply}_ARGUMENT_${String$2(index)}`,
                            ),
                          ),
                        );
                      } else {
                        return makeVariableDeclarator(
                          param,
                          makeIdentifier(
                            `${context.apply}_ARGUMENT_${String$2(index)}`,
                          ),
                        );
                      }
                    }),
                  ),
                ]),
            node.expression
              ? makeReturnStatement(
                  makeAssignmentExpression(
                    makeIdentifier(`${context.apply}_RESULT`),
                    visitNode(node.body, node, parent, closure, context),
                  ),
                )
              : visitNode(node.body, node, parent, closure, context),
          ]),
          makeCatchClause(
            makeIdentifier(`${context.apply}_ERROR`),
            makeBlockStatement([
              ...(isJumpClosureNode(node)
                ? [
                    makeIfStatement(
                      makeBinaryExpression(
                        "!==",
                        makeIdentifier(`${context.apply}_JUMP_TAB`),
                        makeLiteral(null),
                      ),
                      makeBlockStatement([
                        makeStatement(
                          makeCallExpression(
                            makeRegularMemberExpression(
                              context.apply,
                              "recordReject",
                            ),
                            [
                              makeIdentifier(`${context.apply}_JUMP_TAB`),
                              makeIdentifier(`${context.apply}_ERROR`),
                            ],
                          ),
                        ),
                        makeStatement(
                          makeAssignmentExpression(
                            makeIdentifier(`${context.apply}_JUMP_TAB`),
                            makeLiteral(null),
                          ),
                        ),
                      ]),
                      null,
                    ),
                  ]
                : []),
              makeExpressionStatement(
                makeAssignmentExpression(
                  makeIdentifier(`${context.apply}_DONE`),
                  makeLiteral(true),
                ),
              ),
              makeExpressionStatement(
                makeCallExpression(
                  makeRegularMemberExpression(context.apply, "recordThrow"),
                  [
                    makeIdentifier(`${context.apply}_BUNDLE_TAB`),
                    makeLiteral(location_string),
                    makeIdentifier(`${context.apply}_ERROR`),
                  ],
                ),
              ),
              makeThrowStatement(makeIdentifier(`${context.apply}_ERROR`)),
            ]),
          ),
          makeBlockStatement([
            ...(isJumpClosureNode(node)
              ? [
                  makeIfStatement(
                    makeBinaryExpression(
                      "!==",
                      makeIdentifier(`${context.apply}_JUMP_TAB`),
                      makeLiteral(null),
                    ),
                    makeBlockStatement([
                      makeStatement(
                        makeCallExpression(
                          makeRegularMemberExpression(
                            context.apply,
                            "recordResolve",
                          ),
                          [
                            makeIdentifier(`${context.apply}_JUMP_TAB`),
                            makeRegularMemberExpression(context.apply, "empty"),
                          ],
                        ),
                      ),
                      makeStatement(
                        makeAssignmentExpression(
                          makeIdentifier(`${context.apply}_JUMP_TAB`),
                          makeLiteral(null),
                        ),
                      ),
                    ]),
                    null,
                  ),
                ]
              : []),
            makeIfStatement(
              makeUnaryExpression("!", makeIdentifier(`${context.apply}_DONE`)),
              makeBlockStatement([
                makeExpressionStatement(
                  makeCallExpression(
                    makeRegularMemberExpression(context.apply, "recordReturn"),
                    [
                      makeIdentifier(`${context.apply}_BUNDLE_TAB`),
                      makeLiteral(location_string),
                      makeIdentifier(`${context.apply}_RESULT`),
                    ],
                  ),
                ),
              ]),
              null,
            ),
          ]),
        ),
      ]),
    );
  } else {
    return makeClosure(
      node.type,
      node.async,
      node.generator,
      node.expression,
      mapMaybe(node.id, (child) =>
        visitNode(child, node, parent, closure, context),
      ),
      node.params.map((param) =>
        visitNode(param, node, parent, closure, context),
      ),
      visitNode(node.body, node, parent, closure, context),
    );
  }
};

const compileInstrumentJumpExpression =
  (makeRecordJumpExpression, makeForwardJumpExpression) =>
  (node, parent, _grand_parent, closure, context) =>
    closure.instrumented
      ? makeSequenceExpression([
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP`),
            visitNode(node.argument, node, parent, closure, context),
          ),
          makeLogicalExpression(
            "||",
            makeBinaryExpression(
              "===",
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
            makeIdentifier(`${context.apply}_APPMAP_JUMP_ASSERTION_VIOLATION`),
          ),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP_TAB`),
            makeCallExpression(
              makeRegularMemberExpression(context.apply, "getFreshTab"),
              [],
            ),
          ),
          makeRecordJumpExpression(node, context.apply),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP`),
            makeForwardJumpExpression(node, context.apply),
          ),
          makeCallExpression(
            makeRegularMemberExpression(context.apply, "recordResolve"),
            [
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeIdentifier(`${context.apply}_JUMP`),
            ],
          ),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP_TAB`),
            makeLiteral(null),
          ),
          makeIdentifier(`${context.apply}_JUMP`),
        ])
      : null;

const instrumenters = {
  AwaitExpression: compileInstrumentJumpExpression(
    (_node, namespace) =>
      makeCallExpression(
        makeRegularMemberExpression(namespace, "recordAwait"),
        [
          makeIdentifier(`${namespace}_JUMP_TAB`),
          makeIdentifier(`${namespace}_JUMP`),
        ],
      ),
    (_node, namespace) =>
      makeAwaitExpression(makeIdentifier(`${namespace}_JUMP`)),
  ),
  YieldExpression: compileInstrumentJumpExpression(
    ({ delegate }, namespace) =>
      makeCallExpression(
        makeRegularMemberExpression(namespace, "recordYield"),
        [
          makeIdentifier(`${namespace}_JUMP_TAB`),
          makeLiteral(delegate),
          makeIdentifier(`${namespace}_JUMP`),
        ],
      ),
    ({ delegate }, namespace) =>
      makeYieldExpression(delegate, makeIdentifier(`${namespace}_JUMP`)),
  ),
  ReturnStatement: (node, parent, _grand_parent, closure, context) =>
    closure.instrumented && node.argument !== null
      ? makeReturnStatement(
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_RESULT`),
            visitNode(node.argument, node, parent, closure, context),
          ),
        )
      : null,
  CallExpression: (node, parent, _grand_parent, closure, context) => {
    if (
      node.callee.type === "Identifier" &&
      context.eval.aliases.includes(node.callee.name) &&
      node.arguments.length > 0
    ) {
      return makeCallExpression(makeIdentifier(node.callee.name), [
        makeCallExpression(makeIdentifier(context.eval.hidden), [
          makeLiteral(context.url),
          makeLiteral(
            `${String$2(node.loc.start.line)}-${String$2(node.loc.start.column)}`,
          ),
          visitNode(node.arguments[0], node, parent, closure, context),
        ]),
        ...node.arguments
          .slice(1)
          .map((argument) =>
            visitNode(argument, node, parent, closure, context),
          ),
      ]);
    } else {
      return null;
    }
  },
  TryStatement: (node, parent, _grand_parent, closure, context) => {
    if (closure.instrumented && isJumpClosureNode(closure.node)) {
      return makeTryStatement(
        visitNode(node.block, node, parent, closure, context),
        makeCatchClause(
          makeIdentifier(`${context.apply}_ERROR`),
          makeBlockStatement([
            makeIfStatement(
              makeBinaryExpression(
                "!==",
                makeIdentifier(`${context.apply}_JUMP_TAB`),
                makeLiteral(null),
              ),
              makeBlockStatement([
                makeStatement(
                  makeCallExpression(
                    makeRegularMemberExpression(context.apply, "recordReject"),
                    [
                      makeIdentifier(`${context.apply}_JUMP_TAB`),
                      makeIdentifier(`${context.apply}_ERROR`),
                    ],
                  ),
                ),
                makeStatement(
                  makeAssignmentExpression(
                    makeIdentifier(`${context.apply}_JUMP_TAB`),
                    makeLiteral(null),
                  ),
                ),
              ]),
              null,
            ),
            ...(node.handler === null
              ? []
              : [
                  ...(node.handler.param === null
                    ? []
                    : [
                        makeVariableDeclaration("let", [
                          makeVariableDeclarator(
                            visitNode(
                              node.handler.param,
                              node.handler,
                              node,
                              closure,
                              context,
                            ),
                            makeIdentifier(`${context.apply}_ERROR`),
                          ),
                        ]),
                      ]),
                  visitNode(
                    node.handler.body,
                    node.handler,
                    node,
                    closure,
                    context,
                  ),
                ]),
          ]),
        ),
        makeBlockStatement([
          makeIfStatement(
            makeBinaryExpression(
              "!==",
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
            makeBlockStatement([
              makeStatement(
                makeCallExpression(
                  makeRegularMemberExpression(context.apply, "recordResolve"),
                  [
                    makeIdentifier(`${context.apply}_JUMP_TAB`),
                    makeRegularMemberExpression(context.apply, "empty"),
                  ],
                ),
              ),
              makeStatement(
                makeAssignmentExpression(
                  makeIdentifier(`${context.apply}_JUMP_TAB`),
                  makeLiteral(null),
                ),
              ),
            ]),
            null,
          ),
          ...(node.finalizer === null
            ? []
            : [visitNode(node.finalizer, node, parent, closure, context)]),
        ]),
      );
    } else {
      return null;
    }
  },
  Identifier: (node, _parent, _grand_parent, _closure, context) => {
    assert(
      !logErrorWhen(
        node.name.startsWith(context.apply),
        "Identifier collision detected at %j line %j column %j >> identifier should not start with %j, got: %j",
        context.url,
        node.loc.start.line,
        node.loc.start.column,
        context.apply,
        node.name,
      ),
      "Identifier collision",
      ExternalAppmapError,
    );
    return null;
  },
  Program: (node, parent, _grand_parent, closure, context) =>
    closure.instrumented && node.sourceType === "module"
      ? makeProgram("module", [
          makeVariableDeclaration("let", [
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_BUNDLE_TAB`),
              makeCallExpression(
                makeRegularMemberExpression(context.apply, "getFreshTab"),
                [],
              ),
            ),
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_JUMP`),
              null,
            ),
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
          ]),
          ...node.body.map((child) =>
            visitNode(child, node, parent, closure, context),
          ),
        ])
      : null,
  FunctionExpression: instrumentClosure,
  FunctionDeclaration: instrumentClosure,
  ArrowFunctionExpression: instrumentClosure,
};

const initial_parent = { type: "File" };

const initial_grand_parent = { type: "Root" };

const visit = (node, context) => {
  assert(
    node.type === "Program",
    "expected program as top level estree node",
    InternalAppmapError,
  );
  // Top level async jump only present in module.
  // Avoid poluting global scope in script.
  return visitNode(
    node,
    initial_parent,
    initial_grand_parent,
    {
      node,
      instrumented: context.apply !== null && node.sourceType === "module",
    },
    context,
  );
};

const { generate: generateEstree } = Astring;

const instrument$1 = (url, cache, configuration) => {
  const codebase = createCodebase(url, cache, configuration);
  const files = getEnabledSourceFileArray(codebase);
  if (files.length === 0) {
    logDebug("*Not* recording file %j", url);
    return {
      ...getMainFile(codebase),
      sources: [],
    };
  } else {
    logDebug("Recording file %j", url);
    return {
      url,
      content: generateEstree(
        visit(parseMain(codebase), {
          url,
          eval: configuration.hooks.eval,
          apply: configuration.hooks.apply,
          codebase,
        }),
      ),
      sources: files,
    };
  }
};

const { Map: Map$2 } = globalThis;

const readFileSafe = (url, readFile) => {
  try {
    return readFile(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const readFileSafeAsync = async (url, readFileAsync) => {
  try {
    return await readFileAsync(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const instrumentInject = (url, content, configuration, readFile) => {
  const cache = new Map$2(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, readFileSafe(url, readFile));
      }
    }
  }
};

const instrumentInjectAsync = async (
  url,
  content,
  configuration,
  readFileAsync,
) => {
  const cache = new Map$2(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, await readFileSafeAsync(url, readFileAsync));
      }
    }
  }
};

const {
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$3, getPrototypeOf: getPrototypeOf$1, ownKeys: ownKeys$1 },
  Error: { prototype: error_prototype },
  Infinity,
  Symbol,
  Symbol: { keyFor, for: symbolFor },
  WeakMap,
  Map: Map$1,
  Set: Set$3,
  String: String$1,
  undefined: undefined$8,
  Math: { min },
  Object: { prototype: object_prototype, fromEntries: fromEntries$2 },
  Array: { isArray: isArray$4 },
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const empty = symbolFor("APPMAP_EMPTY_MARKER");

const isSymbol = (any) => typeof any === "symbol";

const isString = (any) => typeof any === "string";

const wellknown = new Set$3(
  ownKeys$1(Symbol)
    .map((key) => Symbol[key])
    .filter(isSymbol),
);

////////////////////
// Reflect Helper //
////////////////////
const getOwnKeyArrayImpure = (object) => {
  try {
    return ownKeys$1(object);
  } catch (error) {
    logDebug(
      "Reflect.ownKeys(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return [];
  }
};
const getPrototypeImpure = (object) => {
  try {
    return getPrototypeOf$1(object);
  } catch (error) {
    logDebug(
      "Reflect.getPrototypeOf(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return null;
  }
};
const getOwnPropertyDescriptorImpure = (object, key) => {
  try {
    return getOwnPropertyDescriptor$3(object, key);
  } catch (error) {
    logDebug(
      "Reflect.getOwnPropertyDescriptor(%o, %j) threw %O (this should only happen when the object is a proxy)",
      object,
      key,
      error,
    );
    return undefined$8;
  }
};
const hasPrototypeImpure = (object, prototype) => {
  while (object !== null) {
    if (object === prototype) {
      return true;
    }
    object = getPrototypeImpure(object);
  }
  return false;
};
const getDataPropertyImpure = (object, key) => {
  while (object !== null) {
    const descriptor = getOwnPropertyDescriptorImpure(object, key);
    if (descriptor !== undefined$8 && hasOwnProperty(descriptor, "value")) {
      return descriptor.value;
    }
    object = getPrototypeImpure(object);
  }
  return undefined$8;
};
const toStringImpure = (object) => {
  try {
    return object.toString();
  } catch (error) {
    logDebug("%o.toString() failure >> %O", object, error);
    return undefined$8;
  }
};
///////////
// Index //
///////////
const generateGetIndex =
  (name) =>
  ({ [name]: map, counter }, value) => {
    const index = map.get(value);
    if (index !== undefined$8) {
      return index;
    } else {
      const new_index = incrementCounter(counter);
      map.set(value, new_index);
      return new_index;
    }
  };
const getSymbolIndex = generateGetIndex("symbols");
const getReferenceIndex = generateGetIndex("references");
////////////////////////
// getConstructorName //
////////////////////////
const getConstructorName = ({ impure_constructor_naming }, object) => {
  if (impure_constructor_naming) {
    const _constructor = getDataPropertyImpure(object, "constructor");
    if (typeof _constructor === "function") {
      const name = getDataPropertyImpure(_constructor, "name");
      logDebugWhen(
        typeof name !== "string",
        "Constructor name of %o is not a string: %o",
        object,
        name,
      );
      return typeof name === "string" ? name : typeof object;
    } else {
      return typeof object;
    }
  } else {
    return typeof object;
  }
};
///////////////
// stringify //
///////////////
const generatePrint =
  (printString) =>
  ({ impure_printing }, any) => {
    if (
      any === null ||
      any === undefined$8 ||
      typeof any === "boolean" ||
      typeof any === "number"
    ) {
      return String$1(any);
    } else if (typeof any === "string") {
      return printString(any);
    } else if (typeof any === "bigint") {
      return `${String$1(any)}n`;
    } else if (typeof any === "symbol") {
      if (wellknown.has(any)) {
        return `well-known ${String$1(any)}`;
      } else if (keyFor(any) !== undefined$8) {
        return `global ${String$1(any)}`;
      } else {
        return String$1(any);
      }
    } else if (typeof any === "function") {
      if (impure_printing) {
        const name = getDataPropertyImpure(any, "name");
        if (getOwnPropertyDescriptorImpure(any, "prototype") !== undefined$8) {
          if (typeof name === "string" && name !== "") {
            return `function ${name} (...) { ... }`;
          } else {
            return `function (...) { ... }`;
          }
        } else {
          if (typeof name === "string" && name !== "") {
            return `${name} = (...) => { ... }`;
          } else {
            return `(...) => { ... }`;
          }
        }
      } else {
        return "function";
      }
    } else if (typeof any === "object") {
      if (impure_printing) {
        const representation = toStringImpure(any);
        logDebugWhen(
          typeof representation !== "string",
          "%o.toString() did not return a string, got: %o",
          any,
          representation,
        );
        return typeof representation === "string" ? representation : "object";
      } else {
        return "object";
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("unknown type");
    } /* c8 ignore stop */
  };
const print = generatePrint(stringifyJSON$2);
const show = generatePrint(identity);
//////////////////
// getSpecific  //
//////////////////
const getSpecific = (serialization, object) => {
  if (
    serialization.impure_error_inspection &&
    hasPrototypeImpure(object, error_prototype)
  ) {
    return {
      type: "error",
      name: show(serialization, getDataPropertyImpure(object, "name")),
      message: show(serialization, getDataPropertyImpure(object, "message")),
      stack: show(serialization, getDataPropertyImpure(object, "stack")),
    };
  } else if (serialization.impure_array_inspection && isArray$4(object)) {
    // Proxies cannot change array's length so we know it will be a number.
    return { type: "array", length: getDataPropertyImpure(object, "length") };
  } else if (
    serialization.impure_hash_inspection &&
    (getPrototypeImpure(object) === null ||
      getPrototypeImpure(object) === object_prototype)
  ) {
    const keys = getOwnKeyArrayImpure(object).filter(isString);
    const entries = [];
    const length = min(keys.length, serialization.maximum_properties_length);
    for (let index = 0; index < length; index += 1) {
      const key = keys[index];
      entries.push([key, typeof getDataPropertyImpure(object, key)]);
    }
    return {
      type: "hash",
      length,
      properties: fromEntries$2(entries),
    };
  } else {
    return null;
  }
};
const serializeNonEmpty = (serialization, value) => {
  const type = value === null ? "null" : typeof value;
  const representation = print(serialization, value);
  if (
    type === "null" ||
    type === "undefined" ||
    type === "boolean" ||
    type === "number" ||
    type === "string" ||
    type === "bigint"
  ) {
    return { type, print: representation };
  } else if (type === "symbol") {
    return {
      type,
      print: representation,
      index: getSymbolIndex(serialization, value),
    };
  } else {
    return {
      type,
      print: representation,
      index: getReferenceIndex(serialization, value),
      constructor: getConstructorName(serialization, value),
      specific: getSpecific(serialization, value),
    };
  }
};

const createSerialization = ({
  serialization: {
    "maximum-print-length": maximum_print_length,
    "maximum-properties-length": maximum_properties_length,
    "impure-printing": impure_printing,
    "impure-constructor-naming": impure_constructor_naming,
    "impure-array-inspection": impure_array_inspection,
    "impure-error-inspection": impure_error_inspection,
    "impure-hash-inspection": impure_hash_inspection,
  },
}) => ({
  counter: createCounter(0),
  empty,
  symbols: new Map$1(),
  references: new WeakMap(),
  maximum_print_length:
    maximum_print_length === null ? Infinity : maximum_print_length,
  maximum_properties_length,
  impure_printing,
  impure_constructor_naming,
  impure_array_inspection,
  impure_error_inspection,
  impure_hash_inspection,
});

const getSerializationEmptyValue$1 = ({ empty }) => empty;

const serialize$1 = (serialization, value) => {
  if (value === serialization.empty) {
    return null;
  } else {
    const serial = serializeNonEmpty(serialization, value);
    if (serial.print.length > serialization.maximum_print_length) {
      return {
        ...serial,
        print: `${serial.print.substring(
          0,
          serialization.maximum_print_length - 4,
        )} ...`,
      };
    } else {
      return serial;
    }
  }
};

const START = "TR?";
const STOP = "TR!";
const ERROR = "ERR";
const SOURCE = "SRC";
const BEGIN_REQUEST_AMEND = "RQ.";

const SESSION_ASSIGNMENT = "SE!";

const GROUP_DEFINITION = "GR?";
const GROUP_ASSIGNMENT = "GR!";

const BEGIN_BUNDLE_EVENT = "BD>";
const END_BUNDLE_EVENT = "BD<";

const BEFORE_JUMP_EVENT = "JP?";
const AFTER_JUMP_EVENT = "JP!";

const BEGIN_APPLY_EVENT = "APP";
const END_RETURN_EVENT = "RET";
const END_THROW_EVENT = "TRW";

const BEFORE_AWAIT_EVENT = "AWT";
const BEFORE_YIELD_EVENT = "YLD";
const AFTER_RESOLVE_EVENT = "RES";
const AFTER_REJECT_EVENT = "REJ";

const BEGIN_REQUEST_EVENT = "RQ>";
const END_RESPONSE_EVENT = "RS<";
const BEFORE_REQUEST_EVENT = "RQ?";
const AFTER_RESPONSE_EVENT = "RS!";

const BEFORE_QUERY_EVENT = "QRY";
const AFTER_ANSWER_EVENT = "ASW";

const {
  Array: { isArray: isArray$3, from: toArray$1 },
  Object: { fromEntries: fromEntries$1, entries: toEntries$2 },
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const serialize = (serialization, enabled, value) => {
  enabled.value = false;
  try {
    return serialize$1(serialization, value);
  } finally {
    enabled.value = true;
  }
};

const updateGroup = (buffer, old_group, new_group) => {
  if (old_group.value !== new_group) {
    buffer.push([GROUP_ASSIGNMENT, new_group]);
    old_group.value = new_group;
  }
};

const initializeBuffer = (buffer, session, { value: group }) => {
  buffer.push([SESSION_ASSIGNMENT, session], [GROUP_ASSIGNMENT, group]);
};

const createFrontend = (configuration) => {
  const { session } = configuration;
  assert(session !== null, "missing session", InternalAppmapError);
  const buffer = [];
  initializeBuffer(buffer, session, { value: 0 });
  return {
    enabled: { value: true },
    buffer,
    counter: createCounter(0),
    session,
    old_group: { value: 0 },
    serialization: createSerialization(configuration),
    configuration,
  };
};

const flushContent = ({ buffer, session, old_group }) => {
  if (buffer.length === 2) {
    return null;
  } else {
    const content = stringifyJSON$1(buffer);
    buffer.length = 0;
    initializeBuffer(buffer, session, old_group);
    return content;
  }
};
/* c8 ignore stop */

const getFreshTab = ({ counter }) => incrementCounter(counter);

const getSerializationEmptyValue = ({ serialization }) =>
  getSerializationEmptyValue$1(serialization);

const instrument = (
  { enabled, buffer, configuration },
  url,
  content,
  readFile,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } = instrumentInject(
      url,
      content,
      configuration,
      readFile,
    );
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const instrumentAsync = async (
  { enabled, buffer, configuration },
  url,
  content,
  readFileAsync,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } =
      await instrumentInjectAsync(url, content, configuration, readFileAsync);
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const recordError = ({ enabled, buffer, serialization }, error) => {
  if (enabled.value) {
    buffer.push([ERROR, serialize(serialization, enabled, error)]);
  }
};

const recordStartTrack = ({ enabled, buffer }, track, configuration) => {
  if (enabled.value) {
    buffer.push([START, track, configuration]);
  }
};

const recordStopTrack = ({ enabled, buffer }, track, termination) => {
  if (enabled.value) {
    buffer.push([STOP, track, termination]);
  }
};

const recordGroup = ({ enabled, buffer }, group, child, description) => {
  if (enabled.value) {
    buffer.push([GROUP_DEFINITION, group, child, description]);
  }
};

// jump && bundle //

const compileRecordEmpty =
  (head) =>
  ({ enabled, buffer, old_group }, tab, group, time) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([head, tab, time]);
    }
  };

const recordBeforeJumpEvent = compileRecordEmpty(BEFORE_JUMP_EVENT);

const recordAfterJumpEvent = compileRecordEmpty(AFTER_JUMP_EVENT);

const recordBeginBundleEvent = compileRecordEmpty(BEGIN_BUNDLE_EVENT);

const recordEndBundleEvent = compileRecordEmpty(END_BUNDLE_EVENT);

// function //

const recordBeginApplyEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  this_,
  arguments_,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEGIN_APPLY_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, this_),
      arguments_.map((argument) => serialize(serialization, enabled, argument)),
    ]);
  }
};

const recordEndReturnEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_RETURN_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordEndThrowEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_THROW_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, error),
    ]);
  }
};

// promise && iterator //

const recordBeforeAwaitEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  promise,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_AWAIT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, promise),
    ]);
  }
};

const recordBeforeYieldEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  iterator,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_YIELD_EVENT,
      tab,
      time,
      serialize(serialization, enabled, iterator),
    ]);
  }
};

const recordAfterResolveEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_RESOLVE_EVENT,
      tab,
      time,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordAfterRejectEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_REJECT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, error),
    ]);
  }
};

// client && server //

const compileRecordRequest =
  (head) =>
  (
    { enabled, buffer, serialization, old_group },
    tab,
    group,
    time,
    protocol,
    method,
    url,
    route,
    headers,
    body,
  ) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([
        head,
        tab,
        time,
        protocol,
        method,
        url,
        route,
        headers,
        serialize(serialization, enabled, body),
      ]);
    }
  };

const compileRecordResponse =
  (head) =>
  (
    { enabled, buffer, serialization, old_group },
    tab,
    group,
    time,
    status,
    message,
    headers,
    body,
  ) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([
        head,
        tab,
        time,
        status,
        message,
        headers,
        serialize(serialization, enabled, body),
      ]);
    }
  };

const recordBeforeRequestEvent =
  compileRecordRequest(BEFORE_REQUEST_EVENT);

const recordAfterResponseEvent =
  compileRecordResponse(AFTER_RESPONSE_EVENT);

const recordBeginRequestEvent =
  compileRecordRequest(BEGIN_REQUEST_EVENT);

const recordBeginRequestAmend = (
  { enabled, buffer, serialization },
  tab,
  protocol,
  method,
  url,
  route,
  headers,
  body,
) => {
  if (enabled.value) {
    buffer.push([
      BEGIN_REQUEST_AMEND,
      tab,
      protocol,
      method,
      url,
      route,
      headers,
      serialize(serialization, enabled, body),
    ]);
  }
};

const recordEndResponseEvent = compileRecordResponse(END_RESPONSE_EVENT);

// database //

const recordBeforeQueryEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  database,
  version,
  sql,
  parameters,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_QUERY_EVENT,
      tab,
      time,
      database,
      version,
      sql,
      isArray$3(parameters)
        ? parameters.map((parameter) =>
            serialize(serialization, enabled, parameter),
          )
        : fromEntries$1(
            toArray$1(toEntries$2(parameters)).map(([name, parameter]) => [
              name,
              serialize(serialization, enabled, parameter),
            ]),
          ),
    ]);
  }
};

const recordAfterAnswerEvent = compileRecordEmpty(AFTER_ANSWER_EVENT);

const unhook$d = (backup) => {
  backup.forEach(assignProperty);
};

const hook$e = (frontend, { hooks: { apply: apply_hook_variable } }) => {
  if (apply_hook_variable === null) {
    return [];
  } else {
    const runtime = {
      empty: getSerializationEmptyValue(frontend),
      getFreshTab: () => getFreshTab(frontend),
      recordApply: (tab, function_, this_, arguments_) => {
        recordBeginApplyEvent(
          frontend,
          tab,
          executionAsyncId(),
          now$1(),
          function_,
          this_,
          arguments_,
        );
      },
      recordReturn: (tab, function_, result) => {
        recordEndReturnEvent(
          frontend,
          tab,
          executionAsyncId(),
          now$1(),
          function_,
          result,
        );
      },
      recordThrow: (tab, function_, error) => {
        recordEndThrowEvent(
          frontend,
          tab,
          executionAsyncId(),
          now$1(),
          function_,
          error,
        );
      },
      recordAwait: (tab, promise) => {
        recordBeforeAwaitEvent(
          frontend,
          tab,
          executionAsyncId(),
          now$1(),
          promise,
        );
      },
      recordYield: (tab, iterator) => {
        recordBeforeYieldEvent(
          frontend,
          tab,
          executionAsyncId(),
          now$1(),
          iterator,
        );
      },
      recordResolve: (tab, result) => {
        recordAfterResolveEvent(
          frontend,
          tab,
          executionAsyncId(),
          now$1(),
          result,
        );
      },
      recordReject: (tab, error) => {
        recordAfterRejectEvent(frontend, tab, executionAsyncId(), now$1(), error);
      },
    };
    assert(
      defineGlobal(apply_hook_variable, runtime),
      "global apply hook variable already defined",
      InternalAppmapError,
    );
    return [
      "getFreshTab",
      "recordApply",
      "recordReturn",
      "recordThrow",
      "recordAwait",
      "recordResolve",
      "recordReject",
      "recordYield",
    ].map((key) => ({
      object: runtime,
      key,
      value: noop,
    }));
  }
};

var HookApply = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$d,
  hook: hook$e
});

const {
  Set: Set$2,
  Number: { isInteger, MAX_SAFE_INTEGER },
} = globalThis;

// NB: current execution id when called from C++ is 0
const isGroup = (group) =>
  isInteger(group) && group >= 0 && group < MAX_SAFE_INTEGER;

const hook$d = (frontend, { ordering }) => {
  if (ordering !== "causal") {
    return null;
  } else {
    const groups = new Set$2();
    const hook = createHook({
      init: (id, description, origin) => {
        if (isGroup(id) && isGroup(origin)) {
          // In the presence of a debugger, the init hook may be called multiple times for the same asyncId.
          // However, the asyncId is guaranteed to be unique so we should be able to safely ignore it if it's
          // already been seen.
          if (!groups.has(id)) {
            groups.add(id);
            recordGroup(frontend, origin, id, toString(description));
          }
        } /* c8 ignore start */ else {
          logWarning("Invalid group id for id = %o or origin = %o", id, origin);
        } /* c8 ignore stop */
      },
    });
    hook.enable();
    return hook;
  }
};

const unhook$c = (hook) => {
  if (hook !== null) {
    hook.disable();
  }
};

var HookGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$d,
  unhook: unhook$c
});

const {
  undefined: undefined$7,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2 },
  Error: Error$2,
  Set: Set$1,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$2(obj, key) !== undefined$7,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set$1([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error$2("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$6,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1 },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor$1(obj, key) !== undefined$6,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const { Error: Error$1, decodeURIComponent, URL: URL$1 } = globalThis;

const { from: toBuffer$3 } = Buffer$1;

const splitDataPath = (path) => {
  const index = path.indexOf(",");
  return {
    head: path.substring(0, index),
    body: path.substring(index + 1),
  };
};

const generateReadFile = (readFile) => (url) => {
  const url_obj = new URL$1(url);
  if (url_obj.protocol === "file:") {
    return readFile(url_obj, "utf8");
  } else if (url_obj.protocol === "data:") {
    const { head, body } = splitDataPath(url_obj.pathname);
    if (head.endsWith(";base64")) {
      logDebugWhen(
        !head.toLowerCase().includes(";charset=utf-8;") &&
          !head.toLowerCase().includes(";charset=utf8;"),
        "Data url is encoded as base64 and does not declare UTF-8 as its character encoding, will try to use UTF-8 anyway >> %s",
        url,
      );
      return toBuffer$3(body, "base64").toString("utf8");
    } else {
      return decodeURIComponent(body);
    }
  } else {
    // This file is meant to be used at the same
    //   abstraction level as a node library.
    // Hence, this is delibearately left as an unknown error.
    // ie: not an External/Internal AppmapError.
    throw new Error$1("unsupported protocol");
  }
};

const readFile = generateReadFile(readFileSync);

const readFileAsync = generateReadFile(readFile$1);

const {
  Reflect: { apply: apply$6 },
} = globalThis;

const { prototype } = Module;

const unhook$b = (backup) => {
  backup.forEach(assignProperty);
};

const hook$c = (frontend, { hooks: { cjs } }) => {
  if (!cjs) {
    return [];
  } else {
    const { _compile: original } = prototype;
    prototype._compile = function _compile(content, path) {
      return apply$6(original, this, [
        instrument(
          frontend,
          convertPathToFileUrl(toString(path)),
          content,
          readFile,
        ),
        path,
      ]);
    };
    return [{ object: prototype, key: "_compile", value: original }];
  }
};

const {
  Buffer,
  Buffer: { from: toBuffer$2 },
  ArrayBuffer,
  SharedArrayBuffer,
  Uint8Array,
} = globalThis;

const stringifyContent = (content) => {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof Uint8Array) {
    content = content.buffer;
  }
  if (content instanceof SharedArrayBuffer || content instanceof ArrayBuffer) {
    content = toBuffer$2(content);
  }
  if (content instanceof Buffer) {
    // We assume utf8 encoding as node does:
    // https://github.com/nodejs/node/blob/c200106305f4367ba9ad8987af5139979c6cc40c/lib/internal/modules/cjs/loader.js#L1136
    //
    // Module._extensions['.js'] = function(module, filename) {
    //   // If already analyzed the source, then it will be cached.
    //   const cached = cjsParseCache.get(module);
    //   let content;
    //   if (cached?.source) {
    //     content = cached.source;
    //     cached.source = undefined;
    //   } else {
    //     content = fs.readFileSync(filename, 'utf8');
    //   }
    return content.toString("utf8");
  } else {
    logError(
      "Expected module content to be either: a string, a UintArray, a ArrayBuffer, a SharedArrayBuffer, or a Buffer. Got: %o",
      content,
    );
    throw new ExternalAppmapError("Invalid module content");
  }
};

/* eslint-disable no-import-assign */

let hooked = false;

const unhook$a = (esm) => {
  if (esm) {
    assert(hooked, "esm not yet hooked", InternalAppmapError);
    hooks.load = loadDefault;
    hooks.transformSourceDefault = transformSourceDefault;
    hooked = false;
  }
};

const hook$b = (frontend, { hooks: { esm } }) => {
  if (esm) {
    assert(!hooked, "esm already hooked", InternalAppmapError);
    hooked = esm;
    const transformModuleAsync = async (url, format, content) => {
      // We do not want to intrument commonjs here
      // because cjs has its own hook mechanism.
      if (format === "module") {
        return await instrumentAsync(
          frontend,
          url,
          stringifyContent(content),
          readFileAsync,
        );
      } else {
        return content;
      }
    };
    hooks.load = async (url, context, nextAsync) => {
      const { format, source } = await nextAsync(url, context, nextAsync);
      return {
        format,
        source: await transformModuleAsync(url, format, source),
      };
    };
    hooks.transformSource = async (content, context, nextAsync) => {
      const { format, url } = context;
      const { source } = await nextAsync(content, context, nextAsync);
      return {
        source: await transformModuleAsync(url, format, source),
      };
    };
  }
  return esm;
};

const unhook$9 = (backup) => {
  if (backup !== null) {
    unhook$b(backup.cjs);
    unhook$a(backup.esm);
  }
};

const hook$a = (frontend, configuration) => {
  if (configuration.recorder === "jest") {
    return null;
  } else {
    return {
      cjs: hook$c(frontend, configuration),
      esm: hook$b(frontend, configuration),
    };
  }
};

var HookModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$9,
  hook: hook$a
});

// TODO: detect if preloaded with `--experimental-loader`

const forward = (_url, _location, content) => content;

const unhook$8 = (maybe_hidden) => {
  if (maybe_hidden !== null) {
    writeGlobal(maybe_hidden, forward);
  }
};

const hook$9 = (
  frontend,
  {
    hooks: {
      eval: { hidden, aliases },
    },
  },
) => {
  const enabled = aliases.length > 0;
  if (enabled) {
    assert(
      defineGlobal(
        hidden,
        (url, position, content) =>
          instrument(
            frontend,
            toAbsoluteUrl(`eval-${position}.js`, toDirectoryUrl(url)),
            toString(content),
            readFile,
          ),
        true,
      ),
      "global eval hook variable already defined",
      InternalAppmapError,
    );
  }
  return enabled ? hidden : null;
};

var HookEval = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$8,
  hook: hook$9
});

const hook$8 = (frontend, _configuration) => {
  const listener = (error) => {
    recordError(frontend, error);
  };
  process.addListener("uncaughtExceptionMonitor", listener);
  return listener;
};

const unhook$7 = (listener) => {
  process.removeListener("uncaughtExceptionMonitor", listener);
};

var HookError = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$8,
  unhook: unhook$7
});

const {
  Number: { isNaN },
} = globalThis;

const toStatus = (any) => {
  const integer = toInteger(any);
  if (isNaN(integer) || integer < 0 || integer > 255) {
    return 1;
  } else {
    return integer;
  }
};

const hook$7 = (frontend, _configuration) => {
  const listener = (status) => {
    recordStopTrack(frontend, null, {
      type: "exit",
      status: toStatus(status),
    });
  };
  process.addListener("beforeExit", listener);
  process.addListener("exit", listener);
  return listener;
};

const unhook$6 = (listener) => {
  process.removeListener("beforeExit", listener);
  process.removeListener("exit", listener);
};

var HookExit = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$7,
  unhook: unhook$6
});

const { URL } = globalThis;

const requirePeerDependency = (specifier, { directory, strict }) => {
  const require = createRequire(new URL(directory));
  try {
    return require(specifier);
  } catch (error) {
    if (strict) {
      logError(
        "Could not load peer dependency %j from %j >> %O",
        specifier,
        directory,
        error,
      );
      throw new ExternalAppmapError("Could not load peer dependency");
    } else {
      logDebug(
        "Could not load peer dependency %j from %j >> %O",
        specifier,
        directory,
        error,
      );
      return null;
    }
  }
};

const {
  Set,
  Map,
  Array: { isArray: isArray$2, from: toArray },
  Object: toObject,
  Object: { entries: toEntryArray, fromEntries: fromEntryArray },
} = globalThis;

const isStringEntry = ([key]) => typeof key === "string";

const toParameterCollection = (parameters) => {
  if (parameters instanceof Set) {
    return toArray(parameters.values());
  } else if (parameters instanceof Map) {
    return fromEntryArray(toArray(parameters.entries()).filter(isStringEntry));
  } else if (isArray$2(parameters)) {
    return toArray(parameters);
  } else {
    return fromEntryArray(toEntryArray(toObject(parameters)));
  }
};

/* c8 ignore start */

const {
  Reflect: { apply: apply$5 },
} = globalThis;

const DATABASE$2 = "mysql";
const VERSION$2 = null;

const unhook$5 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$6 = (
  frontend,
  { repository: { directory }, hooks: { mysql } },
) => {
  if (mysql === false) {
    return [];
  } else {
    const Mysql = requirePeerDependency("mysql", {
      directory,
      strict: mysql === true,
    });
    if (Mysql === null) {
      return [];
    } else {
      const { createConnection, createQuery } = Mysql;
      const { __proto__: prototype } = createConnection({});
      const { query: original } = prototype;
      prototype.query = function query(sql, values, callback) {
        const query = createQuery(sql, values, callback);
        const bundle_tab = getFreshTab(frontend);
        const jump_tab = getFreshTab(frontend);
        recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now$1());
        recordBeforeQueryEvent(
          frontend,
          jump_tab,
          executionAsyncId(),
          now$1(),
          DATABASE$2,
          VERSION$2,
          toString(query.sql),
          toParameterCollection(query.values),
        );
        const { _callback: query_callback } = query;
        query._callback = spyOnce((_error, _result, _field) => {
          recordAfterAnswerEvent(frontend, jump_tab, executionAsyncId(), now$1());
          recordEndBundleEvent(frontend, bundle_tab, executionAsyncId(), now$1());
        }, query_callback);
        return apply$5(original, this, [query]);
      };
      return [{ object: prototype, key: "query", value: original }];
    }
  }
};

/* c8 ignore start */

const {
  undefined: undefined$5,
  Reflect: { apply: apply$4 },
  Promise: Promise$3,
  TypeError: TypeError$1,
} = globalThis;

const VERSION$1 = null;
const DATABASE$1 = "postgres";

const unhook$4 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$5 = (
  frontend,
  { repository: { directory }, hooks: { pg } },
) => {
  if (pg === false) {
    return [];
  } else {
    const Postgres = requirePeerDependency("pg", {
      directory,
      strict: pg === true,
    });
    if (Postgres === null) {
      return [];
    } else {
      const { Client, Query } = Postgres;
      const { prototype } = Client;
      const { query: original } = prototype;
      const { query } = {
        // We use the method syntax to create a function that is not constructor.
        query(query, values, callback) {
          if (query === null || query === undefined$5) {
            throw new TypeError$1("Client was passed a null or undefined query");
          }
          let result = undefined$5;
          if (typeof query.submit === "function") {
            result = query;
            if (!query.callback) {
              if (typeof values === "function") {
                query.callback = values;
              } else {
                query.callback = (error, _result) => {
                  if (error !== null) {
                    query.emit("error", error);
                  }
                };
              }
            }
          } else {
            query = new Query(query, values, callback);
            if (!query.callback) {
              result = new Promise$3((resolve, reject) => {
                query.callback = (error, result) => {
                  error ? reject(error) : resolve(result);
                };
              });
            }
          }
          const bundle_tab = getFreshTab(frontend);
          const jump_tab = getFreshTab(frontend);
          recordBeginBundleEvent(
            frontend,
            bundle_tab,
            executionAsyncId(),
            now$1(),
          );
          recordBeforeQueryEvent(
            frontend,
            jump_tab,
            executionAsyncId(),
            now$1(),
            DATABASE$1,
            VERSION$1,
            toString(query.text),
            toParameterCollection(query.values),
          );
          const { callback: query_callback } = query;
          query.callback = spyOnce((_error, _result) => {
            recordAfterAnswerEvent(
              frontend,
              jump_tab,
              executionAsyncId(),
              now$1(),
            );
            recordEndBundleEvent(
              frontend,
              bundle_tab,
              executionAsyncId(),
              now$1(),
            );
          }, query_callback);
          apply$4(original, this, [query]);
          return result;
        },
      };
      prototype.query = query;
      return [{ object: prototype, key: "query", value: original }];
    }
  }
};

const {
  Array: { isArray: isArray$1 },
  Object: { assign: assign$1 },
  Reflect: { apply: apply$3 },
  TypeError,
} = globalThis;

const throwIfNotNull = (error) => {
  /* c8 ignore start */
  if (error !== null) {
    throw error;
  }
  /* c8 ignore stop */
};

const DATABASE = "sqlite3";
const VERSION = null;

const extractEach = (args) => {
  let each = throwIfNotNull;
  if (args.length > 0 && typeof args[args.length - 1] === "function") {
    if (args.length > 1 && typeof args[args.length - 2] === "function") {
      each = args[args.length - 2];
      args[args.length - 2] = args[args.length - 1];
    } else {
      each = args[args.length - 1];
    }
    args.length -= 1;
  }
  return each;
};

const normalizeStatementArguments = (args) => {
  if (args.length === 0 || typeof args[args.length - 1] !== "function") {
    args[args.length] = throwIfNotNull;
  }
  if (args.length === 1) {
    args = [[], args[0]];
  } else if (args.length > 2) {
    const parameters = [];
    for (let index = 0; index < args.length - 1; index += 1) {
      parameters[parameters.length] = args[index];
    }
    args = [parameters, args[args.length - 1]];
  }
  let [parameters, callback] = args;
  if (typeof parameters !== "object" || parameters === null) {
    parameters = [parameters];
  }
  return {
    parameters,
    callback,
  };
};

const normalizeDatabaseArguments = (args) => {
  if (args.length === 0) {
    throw new TypeError("missing sql query string");
  }
  const sql = args[0];
  if (typeof sql !== "string") {
    throw new TypeError("first argument is expected to be a sql query string");
  }
  for (let index = 1; index < args.length; index += 1) {
    args[index - 1] = args[index];
  }
  args.length -= 1;
  const { parameters, callback } = normalizeStatementArguments(args);
  return { sql, parameters, callback };
};

const combine = (parameters1, parameters2) => {
  if (isArray$1(parameters1) && parameters1.length === 0) {
    return parameters2;
  }
  if (isArray$1(parameters2) && parameters2.length === 0) {
    return parameters1;
  }
  if (isArray$1(parameters1) && isArray$1(parameters2)) {
    return [...parameters1, ...parameters2];
  }
  return { ...parameters1, ...parameters2 };
};

const unhook$3 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$4 = (
  frontend,
  { repository: { directory }, hooks: { sqlite3 } },
) => {
  if (sqlite3 === false) {
    return [];
  } else {
    const Sqlite3 = requirePeerDependency("sqlite3", {
      directory,
      strict: sqlite3 === true,
    });
    /* c8 ignore start */ if (Sqlite3 === null) {
      return [];
    } /* c8 ignore stop */ else {
      const { Database } = Sqlite3;
      const { prototype: database_prototype } = Database;
      const backup = ["run", "get", "all", "each", "prepare"].map((key) => ({
        object: database_prototype,
        key,
        value: database_prototype[key],
      }));
      const copy = { ...database_prototype };
      const recordQuery = (sql, parameters, callback) => {
        const bundle_tab = getFreshTab(frontend);
        const jump_tab = getFreshTab(frontend);
        recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now$1());
        recordBeforeQueryEvent(
          frontend,
          jump_tab,
          executionAsyncId(),
          now$1(),
          DATABASE,
          VERSION,
          toString(sql),
          toParameterCollection(parameters),
        );
        return spyOnce(() => {
          recordAfterAnswerEvent(frontend, jump_tab, executionAsyncId(), now$1());
          recordEndBundleEvent(frontend, bundle_tab, executionAsyncId(), now$1());
        }, callback);
      };
      /////////////////////////////////
      // Direct Database method call //
      /////////////////////////////////
      database_prototype.each = function each(...args) {
        const each = extractEach(args);
        const { sql, parameters, callback } = normalizeDatabaseArguments(args);
        return apply$3(copy.each, this, [
          sql,
          parameters,
          each,
          recordQuery(sql, parameters, callback),
        ]);
      };
      for (const key of ["run", "all", "get"]) {
        database_prototype[key] = function (...args) {
          const { sql, parameters, callback } =
            normalizeDatabaseArguments(args);
          return apply$3(copy[key], this, [
            sql,
            parameters,
            recordQuery(sql, parameters, callback),
          ]);
        };
      }
      // Database.prototype.exec is immutable :(
      // database_prototype.exec = function exec (...args) {
      //   const {sql, callback} = normalizeDatabaseArguments(args);
      //   return apply(
      //     save.exec,
      //     this,
      //     [sql, recordQuery(sql, null, callback)]
      //   );
      // }
      ////////////////////////
      // Prepared Statement //
      ////////////////////////
      // NB: Statement.prototype is largely immutable, that is why we need
      // to perform object composition instead of simple prototype assignments.
      function Statement(database, sql, parameters, callback) {
        const statement = apply$3(copy.prepare, database, [sql, callback]);
        statement._appmap_statement = this;
        this._appmap_statement = statement;
        this._appmap_sql = sql;
        this._appmap_parameters = parameters;
      }
      const { prototype: statement_prototype } = Statement;
      assign$1(statement_prototype, {
        run: null,
        all: null,
        get: null,
        each: function each(...args) {
          const each = extractEach(args);
          let { parameters, callback } = normalizeStatementArguments(args);
          parameters = combine(this._appmap_parameters, parameters);
          this._appmap_statement.each(
            parameters,
            each,
            recordQuery(this._appmap_sql, parameters, callback),
          );
          return this;
        },
        bind: function bind(...args) {
          const { parameters, callback } = normalizeStatementArguments(args);
          this._appmap_parameters = parameters;
          this._appmap_statement.reset(callback);
          return this;
        },
        reset: function reset(callback) {
          this._appmap_statement.reset(callback);
          return this;
        },
        finalize: function finalize(callback) {
          this._appmap_statement.finalize(callback);
          return this;
        },
      });
      for (const key of ["run", "all", "get"]) {
        statement_prototype[key] = function (...args) {
          let { parameters, callback } = normalizeStatementArguments(args);
          parameters = combine(this._appmap_parameters, parameters);
          this._appmap_statement[key](
            parameters,
            recordQuery(this._appmap_sql, parameters, callback),
          );
          return this;
        };
      }
      database_prototype.prepare = function (...args) {
        const { sql, parameters, callback } = normalizeDatabaseArguments(args);
        return new Statement(this, sql, parameters, callback);
      };
      return backup;
    }
  }
};

const hook$3 = (frontend, socket, configuration) => ({
  mysql: hook$6(frontend, socket),
  pg: hook$5(frontend, socket),
  sqlite3: hook$4(frontend, socket),
});

const unhook$2 = ({ mysql, pg, sqlite3 }) => {
  unhook$5(mysql);
  unhook$4(pg);
  unhook$3(sqlite3);
};

var HookQuery = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$3,
  unhook: unhook$2
});

const {
  Reflect: { getPrototypeOf, defineProperty, getOwnPropertyDescriptor },
  undefined: undefined$4,
} = globalThis;

const patch$1 = (object, key, makePatch) => {
  if (hasOwnProperty(object, key)) {
    const descriptor = getOwnPropertyDescriptor(object, key);
    assert(
      !logErrorWhen(
        !hasOwnProperty(descriptor, "value"),
        "Cannot monkey-patch accessor property %j of object %o",
        key,
        object,
      ),
      "Cannot monkey-patch accessor property",
      ExternalAppmapError,
    );
    assert(
      !logErrorWhen(
        !descriptor.configurable && !descriptor.writable,
        "Cannot monkey-patch constant data property %j of object %o",
        key,
        object,
      ),
      "Cannot monkey-patch constant data property",
      ExternalAppmapError,
    );
    defineProperty(object, key, {
      __proto__: descriptor,
      value: makePatch(descriptor.value),
    });
  } else {
    let prototype = getPrototypeOf(object);
    let existing_value = undefined$4;
    while (prototype !== null) {
      if (hasOwnProperty(prototype, key)) {
        const descriptor = getOwnPropertyDescriptor(prototype, key);
        assert(
          !logErrorWhen(
            !hasOwnProperty(descriptor, "value"),
            "Cannot monkey-patch accessor property %j of prototype %o",
            key,
            prototype,
          ),
          "Cannot monkey-patch accessor property on prototype",
          ExternalAppmapError,
        );
        existing_value = descriptor.value;
        prototype = null;
      } else {
        prototype = getPrototypeOf(prototype);
      }
    }
    defineProperty(object, key, {
      __proto__: null,
      writable: true,
      enumerable: false,
      value: makePatch(existing_value),
      configurable: true,
    });
  }
};

const {
  Buffer: { from: toBuffer$1, concat: concatBuffer$1 },
  Object: { fromEntries, entries: toEntries$1 },
  TextDecoder,
  Reflect: { apply: apply$2 },
  JSON: { parse: parseJSON$1 },
  Math: { round },
  undefined: undefined$3,
} = globalThis;

const normalizeChunk = (chunk, encoding) =>
  typeof chunk === "string" ? toBuffer$1(chunk, encoding) : chunk;

const spyReadable = (readable, callback) => {
  const buffers = [];
  patch$1(
    readable,
    "push",
    (original_push) =>
      function (chunk, encoding) {
        if (chunk === null) {
          callback(concatBuffer$1(buffers));
        } else {
          buffers.push(normalizeChunk(chunk, encoding));
        }
        return apply$2(original_push, this, [chunk, encoding]);
      },
  );
};

const spyWritable = (writable, callback1) => {
  const buffers = [];
  patch$1(
    writable,
    "write",
    (original_write) =>
      function (chunk, encoding, callback2) {
        buffers.push(normalizeChunk(chunk, encoding));
        return apply$2(original_write, this, [chunk, encoding, callback2]);
      },
  );
  patch$1(
    writable,
    "end",
    (original_end) =>
      function (chunk, encoding, callback2) {
        if (chunk !== null && chunk !== undefined$3) {
          buffers.push(normalizeChunk(chunk, encoding));
        }
        callback1(concatBuffer$1(buffers));
        return apply$2(original_end, this, [chunk, encoding, callback2]);
      },
  );
};

const parseJSONSafe = (string, recovery) => {
  try {
    return parseJSON$1(string);
  } catch (error) {
    logWarning("Could not parse as JSON %j >> %O", string, error);
    return recovery;
  }
};

const decodeSafe = (buffer, encoding, recovery) => {
  try {
    return new TextDecoder(encoding).decode(buffer);
  } catch (error) {
    logWarning("Could not decode as %j buffer >> %O", encoding, error);
    return recovery;
  }
};

const parseContentTypeHead = (head) => {
  const parts = /^ *([a-zA-Z-]+) *\/ *([a-zA-Z-]+) *$/u.exec(head);
  if (parts === null) {
    logWarning("Could not parse content-type head %j", head);
    return { type: "text", subtype: "plain" };
  } else {
    return { type: parts[1], subtype: parts[2] };
  }
};

const parseContentTypeParameter = (parameter) => {
  const parts = /^ *([a-zA-Z0-9-]+) *= *([a-zA-Z0-9-]+) *$/u.exec(parameter);
  if (parts === null) {
    logWarning("Could not parse content-type parameter %j", parameter);
    return [];
  } else {
    return [[parts[1], parts[2]]];
  }
};

const parseContentType = (content_type) => {
  const segments = content_type.toLowerCase().split(";");
  const { type, subtype } = parseContentTypeHead(segments.shift());
  return {
    type,
    subtype,
    parameters: fromEntries(segments.flatMap(parseContentTypeParameter)),
  };
};

const isStringKeyEntry = ({ 0: key }) => typeof key === "string";

const toStringValueEntry = ({ 0: key, 1: value }) => [key, toString(value)];

const formatHeaders = (headers) =>
  fromEntries(
    toEntries$1(headers).filter(isStringKeyEntry).map(toStringValueEntry),
  );

const replacements = {
  NaN: 0,
  NEGATIVE_INFINITY: 0,
  POSITIVE_INFINITY: 0,
};

const formatStatus = (any) =>
  round(jsonifyNumber(toNumber(any), replacements));

const {
  Reflect: { apply: apply$1, construct: construct$1 },
  Proxy: Proxy$1,
} = globalThis;

const unhook$1 = (backup) => backup.forEach(assignProperty);

const hook$2 = (frontend, { hooks: { http } }) => {
  if (!http) {
    return [];
  } else {
    const empty = getSerializationEmptyValue(frontend);
    const backup = [
      ...["ClientRequest", "request", "get"].map((key) => ({
        object: Http,
        key,
      })),
      ...["request", "get"].map((key) => ({ object: Https, key })),
    ].map(({ object, key }) => ({ object, key, value: object[key] }));
    const spyRequest = (request) => {
      const bundle_tab = getFreshTab(frontend);
      const jump_tab = getFreshTab(frontend);
      recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now$1());
      recordBeforeRequestEvent(
        frontend,
        jump_tab,
        executionAsyncId(),
        now$1(),
        "HTTP/1.1",
        toString(request.method),
        toString(request.path),
        null,
        formatHeaders(request.getHeaders()),
        empty,
      );
      request.on("response", (response) => {
        const {
          headers,
          statusCode: status,
          statusMessage: message,
        } = response;
        let body = empty;
        const { type, subtype, parameters } = parseContentType(
          getOwnProperty(headers, "content-type", "text/plain"),
        );
        const compression = getOwnProperty(
          headers,
          "content-encoding",
          "identity",
        );
        if (
          type === "application" &&
          subtype === "json" &&
          compression === "identity"
        ) {
          spyReadable(response, (buffer) => {
            const maybe = decodeSafe(
              buffer,
              getOwnProperty(parameters, "charset", "utf-8"),
              null,
            );
            if (maybe !== null) {
              body = parseJSONSafe(maybe, empty);
            }
          });
        }
        response.once(
          "end",
          spyOnce(() => {
            recordAfterResponseEvent(
              frontend,
              jump_tab,
              executionAsyncId(),
              now$1(),
              formatStatus(status),
              toString(message),
              formatHeaders(headers),
              body,
            );
            recordEndBundleEvent(
              frontend,
              bundle_tab,
              executionAsyncId(),
              now$1(),
            );
          }, identity),
        );
      });
    };
    const traps = {
      __proto__: null,
      apply: (target, context, values) => {
        const request = apply$1(target, context, values);
        spyRequest(request);
        return request;
      },
      construct: (target, values, newtarget) => {
        const request = construct$1(target, values, newtarget);
        spyRequest(request);
        return request;
      },
    };
    for (const { object, key, value } of backup) {
      object[key] = new Proxy$1(value, traps);
    }
    return backup;
  }
};

var HookHttpClient = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$1,
  hook: hook$2
});

const {
  Buffer: { from: toBuffer, concat: concatBuffer },
  Promise: Promise$2,
  Error,
  JSON: { parse: parseJSON, stringify: stringifyJSON },
} = globalThis;

const { request: createRequest } = Http;

const INVALID_HEADERS_MESSAGE =
  "in the presence of a body, 'content-type' should be 'application/json; charset=UTF-8'";

const parse = (body) => {
  if (body === "") {
    return null;
  }
  return parseJSON(body);
};

const stringify = (data) => {
  if (data === null) {
    return "";
  }
  return stringifyJSON(data);
};

const areValidHeaders = (headers) =>
  !hasOwnProperty(headers, "content-length") ||
  headers["content-length"] === "0" ||
  (hasOwnProperty(headers, "content-type") &&
    headers["content-type"] === "application/json; charset=UTF-8");

const empty_headers = {
  "content-length": 0,
};

const createHeaders = ({ length }) => {
  if (length === 0) {
    return empty_headers;
  }
  return {
    "content-type": "application/json; charset=UTF-8",
    "content-length": length,
  };
};

const requestAsync = (host, port, method, path, data) =>
  new Promise$2((resolve, reject) => {
    const buffer = toBuffer(stringify(data), "utf8");
    const request = createRequest({
      host,
      port: typeof port === "number" ? port : null,
      socketPath:
        typeof port === "string" ? toIpcPath(fileURLToPath(port)) : null,
      method,
      path,
      headers: createHeaders(buffer),
    });
    request.end(buffer);
    request.on("error", reject);
    request.on("response", (response) => {
      response.on("error", reject);
      if (areValidHeaders(response.headers)) {
        const buffers = [];
        response.on("data", (buffer) => {
          buffers.push(buffer);
        });
        response.on("end", () => {
          resolve({
            code: response.statusCode,
            message: response.statusMessage,
            body: parse(concatBuffer(buffers).toString("utf8")),
          });
        });
      } else {
        reject(new Error(INVALID_HEADERS_MESSAGE));
      }
    });
  });

const generateRespond = (respondAsync) => (request, response) => {
  if (areValidHeaders(request.headers)) {
    const buffers = [];
    request.on("data", (buffer) => {
      buffers.push(buffer);
    });
    request.on("end", async () => {
      const { code, message, body } = await respondAsync(
        request.method,
        request.url,
        parse(concatBuffer(buffers).toString("utf8")),
      );
      const buffer = toBuffer(stringify(body), "utf8");
      response.writeHead(code, message, createHeaders(buffer));
      response.end(buffer);
    });
  } else {
    request.on("data", noop);
    request.on("end", noop);
    response.writeHead(400, INVALID_HEADERS_MESSAGE, empty_headers);
    response.end();
  }
};

const {
  RegExp,
  String,
  process: { nextTick },
  Reflect: { apply, construct },
  Proxy,
  undefined: undefined$2,
} = globalThis;

// TODO: improve test coverage

/* c8 ignore start */
const getStringPort = (server) => {
  const address = server.address();
  return typeof address === "string" ? address : String(address.port);
};

const interceptTraffic = (
  { host, track_port, recorder, regexp },
  server,
  request,
  response,
) => {
  if (
    recorder === "remote" &&
    request.url.startsWith("/_appmap/") &&
    regexp.test(getStringPort(server))
  ) {
    request.url = request.url.substring("/_appmap".length);
    generateRespond((method, path, body) =>
      requestAsync(host, track_port, method, `/_appmap${path}`, body),
    )(request, response);
    return true;
  } else {
    return false;
  }
};

/* c8 ignore stop */

const recordBegin = ({ frontend, empty }, tab, request) => {
  const { httpVersion: version, method, url, headers } = request;
  const protocol = `HTTP/${version}`;
  recordBeginRequestEvent(
    frontend,
    tab,
    executionAsyncId(),
    now$1(),
    toString(protocol),
    toString(method),
    toString(url),
    null,
    formatHeaders(headers),
    empty,
  );
  // Give time for express to populate the request
  nextTick(() => {
    if (
      typeof coalesce(request, "baseUrl", undefined$2) === "string" &&
      typeof coalesce(request, "route", undefined$2) === "object" &&
      typeof coalesce(request.route, "path", undefined$2) === "string"
    ) {
      recordBeginRequestAmend(
        frontend,
        tab,
        toString(protocol),
        toString(method),
        toString(url),
        `${request.baseUrl}${request.route.path}`,
        formatHeaders(headers),
        empty,
      );
    }
  });
};

const recordEnd = ({ frontend }, tab, response, body) => {
  recordEndResponseEvent(
    frontend,
    tab,
    executionAsyncId(),
    now$1(),
    formatStatus(response.statusCode),
    toString(response.statusMessage),
    formatHeaders(response.getHeaders()),
    body,
  );
};

const serializeResponseBody = ({ empty }, response, buffer) => {
  const headers = response.getHeaders();
  const { type, subtype, parameters } = parseContentType(
    getOwnProperty(headers, "content-type", "text/plain"),
  );
  const compression = getOwnProperty(headers, "content-encoding", "identity");
  if (
    type === "application" &&
    subtype === "json" &&
    compression === "identity"
  ) {
    return fromMaybe(
      decodeSafe(buffer, getOwnProperty(parameters, "charset", "utf-8"), null),
      empty,
      (string) => parseJSONSafe(string, empty),
    );
  } /* c8 ignore start */ else {
    return empty;
  } /* c8 ignore stop */
};

const trackJump = ({ frontend }, box, emitter) => {
  const tracking = createBox(true);
  patch$1(
    emitter,
    "emit",
    (original_emit) =>
      function emit(...args) {
        if (getBox(tracking)) {
          recordAfterJumpEvent(frontend, getBox(box), executionAsyncId(), now$1());
          setBox(box, getFreshTab(frontend));
          try {
            return apply(original_emit, this, args);
          } finally {
            recordBeforeJumpEvent(
              frontend,
              getBox(box),
              executionAsyncId(),
              now$1(),
            );
          }
        } else {
          return apply(original_emit, this, args);
        }
      },
  );
  return tracking;
};

const forwardTraffic = (
  _state,
  original_server_emit,
  server,
  request,
  response,
) => apply(original_server_emit, server, ["request", request, response]);

const spyTraffic = (state, original_server_emit, server, request, response) => {
  const { frontend, empty } = state;
  const bundle_tab = getFreshTab(frontend);
  const jump_box = createBox(getFreshTab(frontend));
  const request_tracking = trackJump(state, jump_box, request);
  const response_tracking = trackJump(state, jump_box, response);
  let body = empty;
  spyWritable(response, (buffer) => {
    body = serializeResponseBody(state, response, buffer);
  });
  const generateStopTracking = (box, peer_box) => () => {
    setBox(box, false);
    if (!getBox(peer_box)) {
      // make sure the end event is the last of the tab
      nextTick(() => {
        recordAfterJumpEvent(
          state.frontend,
          getBox(jump_box),
          executionAsyncId(),
          now$1(),
        );
        recordEnd(state, bundle_tab, response, body);
      });
    }
  };
  request.once(
    "close",
    spyOnce(
      generateStopTracking(request_tracking, response_tracking),
      identity,
    ),
  );
  response.once(
    "close",
    spyOnce(
      generateStopTracking(response_tracking, request_tracking),
      identity,
    ),
  );
  recordBegin(state, bundle_tab, request);
  try {
    return forwardTraffic(
      state,
      original_server_emit,
      server,
      request,
      response,
    );
  } finally {
    recordBeforeJumpEvent(frontend, getBox(jump_box), executionAsyncId(), now$1());
  }
};

const spyServer = (state, server, handleTraffic) => {
  patch$1(
    server,
    "emit",
    (original_server_emit) =>
      function emit(name, ...args) {
        if (name !== "request") {
          return apply(original_server_emit, this, [name, ...args]);
        } else {
          assert(
            !logErrorWhen(
              args.length !== 2,
              "Expected exactly two arguments for `request` event listener on `node:http.Server`",
            ),
            "Unexpected argument number on 'request' event listener",
            ExternalAppmapError,
          );
          const [request, response] = args;
          if (!interceptTraffic(state, this, request, response)) {
            handleTraffic(state, original_server_emit, this, request, response);
          }
          return true;
        }
      },
  );
};

const unhook = (backup) => {
  backup.forEach(assignProperty);
};

const compileInterceptTrackPort = (source) => {
  try {
    return new RegExp(source, "u");
  } catch (error) {
    logError(
      "Failed to compile the 'intercept-track-port' configuration field %j as regexp >> %O",
      source,
      error,
    );
    throw new ExternalAppmapError("intercept-track-port is not a regexp");
  }
};

const hook$1 = (
  frontend,
  {
    recorder,
    host,
    "intercept-track-port": intercept_track_port,
    "track-port": track_port,
    hooks: { http },
  },
) => {
  if (!http && recorder !== "remote") {
    return [];
  } else {
    const handleTraffic = http ? spyTraffic : forwardTraffic;
    const backup = [Http, Https].flatMap((object) =>
      ["Server", "createServer"].map((key) => ({
        object,
        key,
        value: object[key],
      })),
    );
    const state = {
      frontend,
      recorder,
      track_port,
      host,
      empty: getSerializationEmptyValue(frontend),
      regexp: compileInterceptTrackPort(intercept_track_port),
    };
    const traps = {
      __proto__: null,
      apply: (target, context, values) => {
        const server = apply(target, context, values);
        spyServer(state, server, handleTraffic);
        return server;
      },
      construct: (target, values, newtarget) => {
        const server = construct(target, values, newtarget);
        spyServer(state, server, handleTraffic);
        return server;
      },
    };
    for (const { object, key, value } of backup) {
      object[key] = new Proxy(value, traps);
    }
    return backup;
  }
};

var HookHttpServer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook,
  hook: hook$1
});

const Hooks = [
  HookApply,
  HookGroup,
  HookModule,
  HookEval,
  HookError,
  HookExit,
  HookQuery,
  HookHttpClient,
  HookHttpServer,
];

const generateHookSingle = (frontend, configuration) => (_, index) =>
  Hooks[index].hook(frontend, configuration);

const hook = (frontend, configuration) =>
  Hooks.map(generateHookSingle(frontend, configuration));

const {
  Date: { now },
  Math: { random },
} = globalThis;

const getUuid = () =>
  `${now().toString(32).substr(-4)}${random().toString(32).substr(-4)}`;

const {
  Array: { isArray },
  Reflect: { ownKeys },
  Object: { entries: toEntries },
} = globalThis;

const HOOK_APPLY_GLOBAL = "APPMAP_HOOK_APPLY";

const HOOK_EVAL_GLOBAL = "APPMAP_HOOK_EVAL";

const EXPECTED_EXTRA_PROPERTIES = ["test_recording"];

////////////
// Extend //
////////////

const assign = (value1, value2) => ({ ...value1, ...value2 });

const overwrite = (_value1, value2) => value2;

// const append = (value1, value2) => [...value1, ...value2];

const prepend = (value1, value2) => [...value2, ...value1];

const extendCommandOptions = (options1, options2) => ({
  ...options1,
  ...options2,
  env: {
    ...coalesce(options1, "env", {}),
    ...coalesce(options2, "env", {}),
  },
});

///////////////
// Normalize //
///////////////

const normalizeDefaultProcess = (default_process, _base) => {
  if (typeof default_process === "boolean") {
    return { enabled: default_process };
  } else {
    return {
      enabled: false,
      ...default_process,
    };
  }
};

const normalizeExclusion = (exclusion, _base) => {
  if (typeof exclusion === "string") {
    exclusion = {
      "qualified-name": exclusion,
      recursive: true,
    };
  }
  const default_value = coalesce(exclusion, "combinator", "and") === "and";
  return {
    combinator: "and",
    "qualified-name": default_value,
    name: default_value,
    "every-label": default_value,
    "some-label": default_value,
    excluded: true,
    recursive: false,
    ...exclusion,
  };
};

const normalizeCommandOptions = (options, base) => ({
  shell: false,
  encoding: "utf8",
  env: {},
  stdio: "inherit",
  timeout: 0,
  killSignal: "SIGTERM",
  ...options,
  cwd: hasOwnProperty(options, "cwd")
    ? toDirectoryUrl(toAbsoluteUrl(options.cwd, base))
    : toAbsoluteUrl(".", base),
});

const normalizeHooks = (hooks, _base) => {
  if (hasOwnProperty(hooks, "eval")) {
    hooks.eval =
      typeof hooks.eval === "boolean"
        ? {
            hidden: HOOK_EVAL_GLOBAL,
            aliases: hooks.eval ? ["eval"] : [],
          }
        : hooks.eval;
  }
  if (hasOwnProperty(hooks, "apply")) {
    hooks.apply =
      typeof hooks.apply === "boolean"
        ? hooks.apply
          ? HOOK_APPLY_GLOBAL
          : null
        : hooks.apply;
  }
  return hooks;
};

const normalizeDefaultPackage = (package_, _base) => {
  if (typeof package_ === "boolean") {
    package_ = { enabled: package_ };
  }
  return {
    enabled: true,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
    ...package_,
  };
};

const normalizeAgent = ({ directory, package: _package }, base) => ({
  directory: toDirectoryUrl(toAbsoluteUrl(directory, base)),
  package: _package,
});

const normalizeDirectoryUrl = (url, base) =>
  toDirectoryUrl(toAbsoluteUrl(url, base));

const normalizeExclude = (exclusions, _base) =>
  exclusions.map(normalizeExclusion);

const normalizeCommand = (command, _base) => ({
  source: typeof command === "string" ? command : null,
  tokens: typeof command === "string" ? null : command,
});

const normalizeScenarios = (scenarios, base) =>
  toEntries(scenarios).map(([key, value]) => ({
    base,
    key,
    value,
  }));

const normalizeLog = (log, base) => {
  if (typeof log === "string") {
    log = { level: log };
  }
  if (hasOwnProperty(log, "file") && typeof log.file !== "number") {
    log.file = toAbsoluteUrl(log.file, base);
  }
  return log;
};

const normalizePort = (port, base) => {
  if (typeof port === "string" && port !== "") {
    port = toAbsoluteUrl(port, base);
  }
  return port;
};

const generateNormalizeSplit = (separator, key1, key2) => (value) => {
  if (typeof value === "string") {
    const segments = value.split(separator);
    return {
      [key1]: segments[0],
      [key2]: segments.length === 1 ? null : segments[1],
    };
  }
  return value;
};

const normalizeRecording = generateNormalizeSplit(
  ".",
  "defined-class",
  "method-id",
);

const normalizeFramework = generateNormalizeSplit("@", "name", "version");

const normalizeFrameworkArray = (frameworks) =>
  frameworks.map(normalizeFramework);

const normalizePackageMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const {
    enabled,
    shallow,
    "inline-source": inline_source,
    exclude,
    "source-type": source_type,
    parsing,
    ...rest
  } = {
    enabled: true,
    "inline-source": null,
    shallow: hasOwnProperty(matcher, "dist"),
    exclude: [],
    "source-type": null,
    parsing: null,
    ...matcher,
  };
  return [
    createMatcher(rest, base),
    {
      enabled,
      "inline-source": inline_source,
      shallow,
      exclude: exclude.map(normalizeExclusion),
      "source-type": source_type,
      parsing,
    },
  ];
};

const normalizePackageMatcherArray = (matchers, base) => {
  if (!isArray(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizePackageMatcher(matcher, base));
};

const normalizeProcessMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const { enabled, ...rest } = {
    enabled: true,
    ...matcher,
  };
  return [createMatcher(rest, base), { enabled }];
};

const normalizeProcesseMatcherArray = (matchers, base) => {
  if (!isArray(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizeProcessMatcher(matcher, base));
};

////////////
// fields //
////////////

const fields = {
  socket: {
    extend: overwrite,
    normalize: identity,
  },
  heartbeat: {
    extend: overwrite,
    normalize: identity,
  },
  threshold: {
    extend: overwrite,
    normalize: identity,
  },
  agent: {
    extend: overwrite,
    normalize: normalizeAgent,
  },
  repository: {
    extend: overwrite,
    normalize: identity,
  },
  scenario: {
    extend: overwrite,
    normalize: identity,
  },
  scenarios: {
    extend: overwrite,
    normalize: normalizeScenarios,
  },
  "recursive-process-recording": {
    extend: overwrite,
    normalize: identity,
  },
  "postmortem-function-exclusion": {
    extend: overwrite,
    normalize: identity,
  },
  command: {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-win32": {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-options": {
    extend: extendCommandOptions,
    normalize: normalizeCommandOptions,
  },
  validate: {
    extend: assign,
    normalize: identity,
  },
  log: {
    extend: assign,
    normalize: normalizeLog,
  },
  host: {
    extend: overwrite,
    normalize: identity,
  },
  session: {
    extend: overwrite,
    normalize: identity,
  },
  sessions: {
    extend: overwrite,
    normalize: identity,
  },
  "proxy-port": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "http-switch": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "track-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-port": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  enabled: {
    extend: overwrite,
    normalize: identity,
  },
  "default-process": {
    extend: overwrite,
    normalize: normalizeDefaultProcess,
  },
  processes: {
    extend: prepend,
    normalize: normalizeProcesseMatcherArray,
  },
  recorder: {
    extend: overwrite,
    normalize: identity,
  },
  "inline-source": {
    extend: overwrite,
    normalize: identity,
  },
  hooks: {
    extend: assign,
    normalize: normalizeHooks,
  },
  ordering: {
    extend: overwrite,
    normalize: identity,
  },
  "collapse-package-hierachy": {
    extend: overwrite,
    normalize: identity,
  },
  serialization: {
    extend: assign,
    normalize: identity,
  },
  main: {
    extend: overwrite,
    normalize: toAbsoluteUrl,
  },
  language: {
    extend: overwrite,
    normalize: identity,
  },
  engine: {
    extend: overwrite,
    normalize: identity,
  },
  "default-package": {
    extend: overwrite,
    normalize: normalizeDefaultPackage,
  },
  packages: {
    extend: prepend,
    normalize: normalizePackageMatcherArray,
  },
  exclude: {
    extend: prepend,
    normalize: normalizeExclude,
  },
  recording: {
    extend: overwrite,
    normalize: normalizeRecording,
  },
  appmap_dir: {
    extend: overwrite,
    normalize: normalizeDirectoryUrl,
  },
  appmap_file: {
    extend: overwrite,
    normalize: identity,
  },
  name: {
    extend: overwrite,
    normalize: identity,
  },
  "map-name": {
    extend: overwrite,
    normalize: identity,
  },
  pruning: {
    extend: overwrite,
    normalize: identity,
  },
  labels: {
    extend: prepend,
    normalize: identity,
  },
  feature: {
    extend: overwrite,
    normalize: identity,
    initial: null,
  },
  "feature-group": {
    extend: overwrite,
    normalize: identity,
  },
  frameworks: {
    extend: prepend,
    normalize: normalizeFrameworkArray,
  },
};

const extendConfiguration = (
  internal_configuration,
  external_configuration,
  base,
) => {
  const extended_internal_configuration = { ...internal_configuration };
  for (const key of ownKeys(external_configuration)) {
    if (hasOwnProperty(fields, key)) {
      const { normalize, extend } = fields[key];
      extended_internal_configuration[key] = extend(
        extended_internal_configuration[key],
        normalize(external_configuration[key], base),
      );
    } else {
      logInfoWhen(
        !EXPECTED_EXTRA_PROPERTIES.includes(key),
        "Configuration property not recognized by the agent: %j",
        key,
      );
    }
  }
  return extended_internal_configuration;
};

const extendConfigurationNode = (
  configuration,
  { version, argv, cwd },
) => {
  assert(argv.length >= 2, "expected at least two argv", InternalAppmapError);
  const [, main] = argv;
  assert(
    version.startsWith("v"),
    "expected version to start with v",
    InternalAppmapError,
  );
  return {
    ...configuration,
    engine: `node@${version.substring(1)}`,
    main: convertPathToFileUrl(toAbsolutePath(main, toDirectoryPath(cwd()))),
  };
};

const isConfigurationEnabled = ({
  processes,
  main,
  "default-process": default_process,
}) => main === null || lookupUrl(processes, main, default_process).enabled;

const { patch } = NetSocketMessaging;

const openSocket = ({ host, "trace-port": port }) => {
  const socket = new Socket();
  if (typeof port === "string") {
    socket.connect(toIpcPath(fileURLToPath(port)));
  } else {
    socket.connect(port, host);
  }
  patch(socket);
  socket.on("connect", () => {
    socket.unref();
  });
  return socket;
};

const addSocketListener = (socket, name, listener) => {
  socket.addListener(name === "open" ? "connect" : name, listener);
};

const isSocketReady = (socket) => !socket.pending && socket.writable;

const sendSocket = (socket, message) => {
  if (!socket.pending && socket.writable) {
    socket.send(message);
  } else {
    logWarning("Lost message >> %s", message);
  }
};

const { Promise: Promise$1, setInterval, undefined: undefined$1 } = globalThis;

const recordAsync = (configuration) => {
  configuration = extendConfigurationNode(configuration, process);
  if (isConfigurationEnabled(configuration)) {
    if (configuration.session === null) {
      configuration = { ...configuration, session: getUuid() };
    }
    const {
      session,
      recorder,
      heartbeat,
      host,
      "frontend-track-port": frontend_track_port,
      "track-port": backend_track_port,
    } = configuration;
    const frontend = createFrontend(configuration);
    hook(frontend, configuration);
    const socket = openSocket(configuration);
    const flush = () => {
      if (isSocketReady(socket)) {
        const content = flushContent(frontend);
        if (content !== null) {
          sendSocket(socket, content);
        }
      }
    };
    if (heartbeat !== null) {
      setInterval(flush, heartbeat).unref();
    }
    process.once("beforeExit", flush);
    process.on("exit", flush);
    process.on("uncaughtExceptionMonitor", flush);
    addSocketListener(socket, "open", flush);
    if (recorder === "remote") {
      logInfo(
        "Enabling remote recording on process #%j -- %j",
        process.pid,
        process.argv,
      );
      logInfo(
        "Remote recording api documention: https://appmap.io/docs/reference/remote-recording-api.html",
      );
      if (frontend_track_port !== null) {
        const server = createServer();
        server.unref();
        /* c8 ignore start */
        server.on(
          "request",
          generateRespond((method, path, body) =>
            requestAsync(
              host,
              backend_track_port,
              method,
              `/_appmap${path}`,
              body,
            ),
          ),
        );
        /* c8 ignore start */
        server.listen(frontend_track_port);
      }
    } else if (recorder === "process") {
      logInfo(
        "Recording the entire process #%j -- %j",
        process.pid,
        process.argv,
      );
      recordStartTrack(
        frontend,
        `process-${getUuid()}`,
        extendConfiguration(configuration, { sessions: session }, null),
      );
    } else {
      throw new InternalAppmapError("invalid node recorder");
    }
    return new Promise$1((resolve, reject) => {
      addSocketListener(socket, "error", reject);
      addSocketListener(socket, "open", resolve);
    });
  } /* c8 ignore start */ else {
    logInfo("Not recording process #%j -- %j", process.pid, process.argv);
    return Promise$1.resolve(undefined$1);
  } /* c8 ignore stop */
};

export { recordAsync };
