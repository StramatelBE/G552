import { readFile as readFile$2 } from 'node:fs/promises';
import { URL as URL$6, pathToFileURL, fileURLToPath, URLSearchParams } from 'node:url';
import { openSync, writeSync, readFileSync } from 'node:fs';
import { runInThisContext } from 'node:vm';
import Treeify from 'treeify';
import AjvErrorTree from 'ajv-error-tree';
import Minimatch from 'minimatch';
import { platform } from 'node:os';
import { win32, posix } from 'node:path';
import 'node:child_process';
import { performance } from 'node:perf_hooks';
import { executionAsyncId, createHook } from 'node:async_hooks';
import * as Astring from 'astring';
import { decode } from 'vlq';
import BabelParser from '@babel/parser';
import { createHash } from 'node:crypto';
import Module, { createRequire } from 'node:module';
import { Buffer as Buffer$1 } from 'node:buffer';
import { hooks, loadDefault, transformSourceDefault } from '../../lib/node/loader-esm.mjs';
import process from 'node:process';
import Http from 'node:http';
import Https from 'node:https';

const { decodeURIComponent: decodeURIComponent$1, encodeURIComponent: encodeURIComponent$1 } = globalThis;

const getDrive = (protocol, pathname) =>
  protocol.toLowerCase() === "file:"
    ? /^\/[a-zA-Z]:\//u.test(pathname)
      ? pathname[1].toLowerCase()
      : null
    : null;

const normalizeCase = (pathname, drive) =>
  drive === null ? pathname : pathname.toLowerCase();

const toAbsoluteUrl = (relative, base_url) =>
  new URL$6(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toRelativeUrl = (
  url,
  base_url,
  encodeSegment = encodeURIComponent$1,
) => {
  const { protocol, host, pathname, search, hash } = new URL$6(url);
  const {
    protocol: base_protocol,
    host: base_host,
    pathname: base_pathname,
  } = new URL$6(base_url);
  if (
    protocol.toLowerCase() !== base_protocol.toLowerCase() ||
    host.toLowerCase() !== base_host.toLowerCase()
  ) {
    return null;
  } else {
    const drive = getDrive(protocol, pathname);
    const base_drive = getDrive(base_protocol, base_pathname);
    if (drive !== base_drive) {
      return null;
    } else {
      const segments = normalizeCase(pathname, drive)
        .split("/")
        .map(decodeURIComponent$1);
      const base_segments = normalizeCase(base_pathname, base_drive)
        .split("/")
        .map(decodeURIComponent$1);
      base_segments.pop();
      while (
        segments.length > 0 &&
        base_segments.length > 0 &&
        segments[0] === base_segments[0]
      ) {
        segments.shift();
        base_segments.shift();
      }
      while (base_segments.length > 0) {
        base_segments.pop();
        segments.unshift("..");
      }
      if (segments.length > 0 && segments[0] !== "") {
        return `${segments.map(encodeSegment).join("/")}${search}${hash}`;
      } else {
        return `.${search}${hash}`;
      }
    }
  }
};

const toDirectoryUrl = (url) => {
  const url_obj = new URL$6(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Alternatively:
//   url.match(/:\/{0,2}.*\/([^/#]+)(#.*)?$/)[1]
const getUrlFilename = (url) => {
  const { pathname } = new URL$6(url);
  if (pathname === "" || pathname.endsWith("/")) {
    return null;
  } else {
    return pathname.substring(pathname.lastIndexOf("/") + 1);
  }
};

// Alternatively:
//   url.match(/([^.\/]+)(\.[^/#]*)(#.*)?$/)[1]
const getUrlBasename = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(0, filename.indexOf("."));
  } else {
    return filename;
  }
};

const prefixDot = (string) => `.${string}`;

const getUrlExtensionArray = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else {
    const extensions = filename.split(".");
    extensions.shift();
    return extensions.map(prefixDot);
  }
};

// Alternatively:
//   url.match(/([^\/]+)(\.[^/#]*)(#.*)?$/)[2]
const getLastUrlExtension = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(filename.lastIndexOf("."));
  } else {
    return null;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$5,
  JSON: { parse: parseJSON$3 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$3(
  await readFile$2(
    new URL$5(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$7 } = globalThis;

class AppmapError extends Error$7 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const { Error: Error$6 } = globalThis;

class AssertionError extends Error$6 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const {
  Array,
  Math: { min: min$1 },
} = globalThis;

const zip = (array1, array2) => {
  const length = min$1(array1.length, array2.length);
  const pairs = new Array(length);
  for (let index = 0; index < length; index += 1) {
    pairs[index] = [array1[index], array2[index]];
  }
  return pairs;
};

const createBox = (value) => ({ value });
const getBox = ({ value }) => value;
const setBox = (box, value) => {
  box.value = value;
};

const {
  Boolean: Boolean$1,
  String: String$d,
  Number,
  parseInt: parseInt$2,
  Array: { isArray: isArray$7 },
  Number: {
    isNaN: isNaN$1,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
    MIN_SAFE_INTEGER,
  },
  Math: { round: round$3 },
  JSON: { stringify: stringifyJSON$4 },
} = globalThis;

const toInteger = (any) => {
  if (typeof any === "boolean") {
    return Number(any);
  } else if (typeof any === "number") {
    if (any < MIN_SAFE_INTEGER) {
      return NEGATIVE_INFINITY;
    } else if (any > MAX_SAFE_INTEGER$1) {
      return POSITIVE_INFINITY;
    } else {
      return round$3(any);
    }
  } else if (typeof any === "bigint") {
    if (any < MIN_SAFE_INTEGER) {
      return NEGATIVE_INFINITY;
    } else if (any > MAX_SAFE_INTEGER$1) {
      return POSITIVE_INFINITY;
    } else {
      return Number(any);
    }
  } else if (typeof any === "string") {
    return parseInt$2(any);
  } else {
    return NaN$1;
  }
};

const toNumber = (any) => {
  if (typeof any === "boolean") {
    return any ? 1 : 0;
  } else if (typeof any === "number") {
    return any;
  } else if (typeof any === "bigint") {
    return Number(any);
  } else if (typeof any === "string") {
    return Number(any);
  } else {
    return NaN$1;
  }
};

const toString = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$7(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else {
    return String$d(any);
  }
};

const print$1 = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$7(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$4(any);
  } else {
    return String$d(any);
  }
};

const jsonifyNumber = (number, replacements) => {
  if (number === NEGATIVE_INFINITY) {
    return replacements.NEGATIVE_INFINITY;
  } else if (number === POSITIVE_INFINITY) {
    return replacements.POSITIVE_INFINITY;
  } else if (isNaN$1(number)) {
    return replacements.NaN;
  } else {
    return number;
  }
};

const {
  Error: Error$5,
  String: String$c,
  JSON: { stringify: stringifyJSON$3 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$3(value);
      }
      if (marker === "O") {
        try {
          return String$c(value);
        } catch {
          return print$1(value);
        }
      }
      if (marker === "o") {
        return print$1(value);
      }
      throw new Error$5("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const createCounter = (value) => ({ value });
const incrementCounter = (counter) => (counter.value += 1);

const {
  Error: Error$4,
  Reflect: { apply: apply$7 },
  WeakMap: WeakMap$1,
} = globalThis;

new WeakMap$1();

const noop = () => {};
const identity = (x) => x;

const spyOnce = (spy, forward) => {
  let called = false;
  return function (...args) {
    if (!called) {
      called = true;
      apply$7(spy, this, args);
    }
    return apply$7(forward, this, args);
  };
};

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const fromMaybe = (maybe, recovery, transform) =>
  maybe === null ? recovery : transform(maybe);

const mapMaybe = (maybe, transform) =>
  maybe === null ? null : transform(maybe);

const recoverMaybe = (maybe, recovery) =>
  maybe === null ? recovery : maybe;

const {
  undefined: undefined$c,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$4, ownKeys: ownKeys$3, defineProperty: defineProperty$2 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$4(Object$1, "hasOwn") === undefined$c
    ? (object, key) => getOwnPropertyDescriptor$4(object, key) !== undefined$c
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const assignProperty = ({ object, key, value }) => {
  object[key] = value;
};

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

const coalesceCaseInsensitive = (value, key1, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    key1 = key1.toLowerCase();
    for (const key2 of ownKeys$3(value)) {
      if (key2.toLowerCase() === key1) {
        return getOwnProperty(value, key2, _default);
      }
    }
  }
  return _default;
};

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$b,
  ReferenceError,
  Reflect: { defineProperty: defineProperty$1 },
} = globalThis;

const defineGlobal = (name, value, writable = false) => {
  if (!hasOwnProperty(globalThis, name)) {
    return defineProperty$1(globalThis, name, {
      __proto__: null,
      value,
      writable,
      configurable: false,
      enumerable: false,
    });
  } else {
    return false;
  }
};

const writeGlobal = (name, value) => {
  if (hasOwnProperty(globalThis, name)) {
    globalThis[name] = value;
    return undefined$b;
  } else {
    throw ReferenceError("missing global variable");
  }
};

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$4 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$4(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$1 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$1(fd, "DEBUG"),
    logInfo: generateLog$1(fd, "INFO"),
    logWarning: generateLog$1(fd, "WARNING"),
    logError: generateLog$1(fd, "ERROR"),
  };
};

const { logDebug: logDebug$1, logInfo: logInfo$1, logWarning: logWarning$1, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

const { log: logDebug, logWhen: logDebugWhen } = generateLog(
  "debug",
  logDebug$1,
);

const { log: logInfo, logWhen: logInfoWhen } = generateLog(
  "info",
  logInfo$1,
);

const { log: logWarning, logWhen: logWarningWhen } = generateLog(
  "warning",
  logWarning$1,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const {
  Date: { now: now$1 },
  Math: { random },
} = globalThis;

const getUuid = () =>
  `${now$1().toString(32).substr(-4)}${random().toString(32).substr(-4)}`;

const runScript = (content, url) =>
  runInThisContext(content, { filename: url });

const { URL: URL$3 } = globalThis;

const {
  validateSerial: validateAjvSerial,
  validatePayload: validateAjvPayload,
  validateExternalConfiguration: validateAjvExternalConfiguration,
  validateInternalConfiguration: validateAjvInternalConfiguration,
  validateMessage: validateAjvMessage,
  validateSourceMap: validateAjvSourceMap,
} = await import(new URL$3("dist/schema.mjs", self_directory));

const { asTree } = Treeify;

const generateValidate = (validateAjv, name, AppmapError) => (json) => {
  if (!validateAjv(json)) {
    const { errors } = validateAjv;
    const { length } = errors;
    assert(length > 0, "unexpected empty error array", InternalAppmapError);
    const tree1 = AjvErrorTree.structureAJVErrorArray(errors);
    const tree2 = AjvErrorTree.summarizeAJVErrorTree(tree1);
    logError(
      "invalid %s\n%s\n  Parameters = %j\n  Input = %j",
      name,
      typeof tree2 === "string" ? tree2 : asTree(tree2, true),
      errors.map((error) => coalesce(error, "params", null)),
      json,
    );
    throw new AppmapError("Failed to validate data against JSON schema");
  }
};

const validateMessage = generateValidate(
  validateAjvMessage,
  "message",
  InternalAppmapError,
);

const validateExternalConfiguration = generateValidate(
  validateAjvExternalConfiguration,
  "user-defined configuration",
  ExternalAppmapError,
);

const validateSourceMap = generateValidate(
  validateAjvSourceMap,
  "source-map",
  ExternalAppmapError,
);

const { Minimatch: MinimatchClass } = Minimatch;

const compileGlob = (glob) => new MinimatchClass(glob).makeRe();

const { Map: Map$a, RegExp: RegExp$3 } = globalThis;

const regexps = new Map$a();

const makeRegExp = (source, flags) => {
  try {
    return new RegExp$3(source, flags);
  } catch (error) {
    logError(
      "Failed to compile regexp source %j with flags %j >> %O",
      source,
      flags,
      error,
    );
    throw new ExternalAppmapError("Failed to compile matcher regexp");
  }
};

const makeRegExpCache = (source, flags) => {
  const key = `/${source}/${flags}`;
  if (regexps.has(key)) {
    return regexps.get(key);
  } else {
    const regexp = makeRegExp(source, flags);
    regexps.set(key, regexp);
    return regexp;
  }
};

const escape = (char) => `\\${char}`;

const sanitizeForRegExp = (string) =>
  string.replace(/[/\\+*?.^$()[\]{}|]/gu, escape);

// const sanitizeForGlob = (string) => string.replace(/[*?[\]]/g, escape);

const toTargetRegExp = (target, recursive) => {
  if (recursive) {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}`;
    } else {
      return `^${sanitizeForRegExp(target)}(/|$)`;
    }
  } else {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}[^/]*$`;
    } else {
      return `^${sanitizeForRegExp(target)}$`;
    }
  }
};

const createMatcher = (options, base) => {
  const {
    glob,
    url,
    path,
    dist,
    regexp,
    flags,
    recursive,
    external,
    relative,
  } = {
    glob: null,
    path: null,
    url: null,
    dist: null,
    regexp: null,
    flags: "",
    recursive: true,
    external: false,
    relative: true,
    ...options,
  };
  if (regexp !== null) {
    return {
      base: relative ? base : null,
      source: regexp,
      flags,
    };
  }
  if (glob !== null) {
    const { source, flags } = compileGlob(glob);
    return {
      base,
      source,
      flags,
    };
  }
  if (path !== null) {
    return {
      base,
      source: toTargetRegExp(path, recursive),
      flags: "",
    };
  }
  if (url !== null) {
    return {
      base: null,
      source: toTargetRegExp(url, recursive),
      flags: "",
    };
  }
  if (dist !== null) {
    assert(
      dist[dist.length - 1] !== "/",
      "package path should not end with a path separator",
      InternalAppmapError,
    );
    let source = `node_modules/${sanitizeForRegExp(dist)}/`;
    if (!external) {
      source = `^${source}`;
    }
    if (!recursive) {
      source = `${source}[^/]*$`;
    }
    return {
      base,
      source,
      flags: "",
    };
  }
  throw new InternalAppmapError("invalid matcher options");
};

// We escape as few character as possible to hide the fact that configuration fields are urls rather than paths.
const escaping = {
  __proto__: null,
  "/": "%2F",
  "?": "%3F",
  "#": "%23",
};

const escapeCharacter = (match) => escaping[match];

const escapeSegment = (segment) => segment.replace(/[/#?]/gu, escapeCharacter);

const matchUrl = (matcher, url) => {
  const { base, source, flags } = matcher;
  if (base === null) {
    const matched = makeRegExpCache(source, flags).test(url);
    logDebug(
      "url %j %s absolute regexp matcher %j with flags %j",
      url,
      matched ? "matched" : "did not match",
      source,
      flags,
    );
    return matched;
  } else {
    const relative = toRelativeUrl(url, base, escapeSegment);
    if (relative === null) {
      logDebug(
        "could not apply matcher %j because %j cannot be expressed relatively to %j, will treat it as not matched",
        source,
        url,
        base,
      );
      return false;
    } else {
      const matched = makeRegExpCache(source, flags).test(relative);
      logDebug(
        "url %j which resolves to %j relatively to %j %s relative regexp matcher %j with flags %j",
        url,
        relative,
        base,
        matched ? "matched" : "did not match",
        source,
        flags,
      );
      return matched;
    }
  }
};

const lookupUrl = (entries, url, default_value) => {
  for (const [matcher, value] of entries) {
    if (matchUrl(matcher, url)) {
      return value;
    }
  }
  return default_value;
};

const {
  Array: { isArray: isArray$6 },
  Reflect: { ownKeys: ownKeys$2 },
  Object: { entries: toEntries$5 },
} = globalThis;

const HOOK_APPLY_GLOBAL = "APPMAP_HOOK_APPLY";

const HOOK_EVAL_GLOBAL = "APPMAP_HOOK_EVAL";

const EXPECTED_EXTRA_PROPERTIES = ["test_recording"];

////////////
// Extend //
////////////

const assign$1 = (value1, value2) => ({ ...value1, ...value2 });

const overwrite = (_value1, value2) => value2;

// const append = (value1, value2) => [...value1, ...value2];

const prepend = (value1, value2) => [...value2, ...value1];

const extendCommandOptions = (options1, options2) => ({
  ...options1,
  ...options2,
  env: {
    ...coalesce(options1, "env", {}),
    ...coalesce(options2, "env", {}),
  },
});

///////////////
// Normalize //
///////////////

const normalizeDefaultProcess = (default_process, _base) => {
  if (typeof default_process === "boolean") {
    return { enabled: default_process };
  } else {
    return {
      enabled: false,
      ...default_process,
    };
  }
};

const normalizeExclusion = (exclusion, _base) => {
  if (typeof exclusion === "string") {
    exclusion = {
      "qualified-name": exclusion,
      recursive: true,
    };
  }
  const default_value = coalesce(exclusion, "combinator", "and") === "and";
  return {
    combinator: "and",
    "qualified-name": default_value,
    name: default_value,
    "every-label": default_value,
    "some-label": default_value,
    excluded: true,
    recursive: false,
    ...exclusion,
  };
};

const normalizeCommandOptions = (options, base) => ({
  shell: false,
  encoding: "utf8",
  env: {},
  stdio: "inherit",
  timeout: 0,
  killSignal: "SIGTERM",
  ...options,
  cwd: hasOwnProperty(options, "cwd")
    ? toDirectoryUrl(toAbsoluteUrl(options.cwd, base))
    : toAbsoluteUrl(".", base),
});

const normalizeHooks = (hooks, _base) => {
  if (hasOwnProperty(hooks, "eval")) {
    hooks.eval =
      typeof hooks.eval === "boolean"
        ? {
            hidden: HOOK_EVAL_GLOBAL,
            aliases: hooks.eval ? ["eval"] : [],
          }
        : hooks.eval;
  }
  if (hasOwnProperty(hooks, "apply")) {
    hooks.apply =
      typeof hooks.apply === "boolean"
        ? hooks.apply
          ? HOOK_APPLY_GLOBAL
          : null
        : hooks.apply;
  }
  return hooks;
};

const normalizeDefaultPackage = (package_, _base) => {
  if (typeof package_ === "boolean") {
    package_ = { enabled: package_ };
  }
  return {
    enabled: true,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
    ...package_,
  };
};

const normalizeAgent = ({ directory, package: _package }, base) => ({
  directory: toDirectoryUrl(toAbsoluteUrl(directory, base)),
  package: _package,
});

const normalizeDirectoryUrl = (url, base) =>
  toDirectoryUrl(toAbsoluteUrl(url, base));

const normalizeExclude = (exclusions, _base) =>
  exclusions.map(normalizeExclusion);

const normalizeCommand = (command, _base) => ({
  source: typeof command === "string" ? command : null,
  tokens: typeof command === "string" ? null : command,
});

const normalizeScenarios = (scenarios, base) =>
  toEntries$5(scenarios).map(([key, value]) => ({
    base,
    key,
    value,
  }));

const normalizeLog = (log, base) => {
  if (typeof log === "string") {
    log = { level: log };
  }
  if (hasOwnProperty(log, "file") && typeof log.file !== "number") {
    log.file = toAbsoluteUrl(log.file, base);
  }
  return log;
};

const normalizePort = (port, base) => {
  if (typeof port === "string" && port !== "") {
    port = toAbsoluteUrl(port, base);
  }
  return port;
};

const generateNormalizeSplit = (separator, key1, key2) => (value) => {
  if (typeof value === "string") {
    const segments = value.split(separator);
    return {
      [key1]: segments[0],
      [key2]: segments.length === 1 ? null : segments[1],
    };
  }
  return value;
};

const normalizeRecording = generateNormalizeSplit(
  ".",
  "defined-class",
  "method-id",
);

const normalizeFramework = generateNormalizeSplit("@", "name", "version");

const normalizeFrameworkArray = (frameworks) =>
  frameworks.map(normalizeFramework);

const normalizePackageMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const {
    enabled,
    shallow,
    "inline-source": inline_source,
    exclude,
    "source-type": source_type,
    parsing,
    ...rest
  } = {
    enabled: true,
    "inline-source": null,
    shallow: hasOwnProperty(matcher, "dist"),
    exclude: [],
    "source-type": null,
    parsing: null,
    ...matcher,
  };
  return [
    createMatcher(rest, base),
    {
      enabled,
      "inline-source": inline_source,
      shallow,
      exclude: exclude.map(normalizeExclusion),
      "source-type": source_type,
      parsing,
    },
  ];
};

const normalizePackageMatcherArray = (matchers, base) => {
  if (!isArray$6(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizePackageMatcher(matcher, base));
};

const normalizeProcessMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const { enabled, ...rest } = {
    enabled: true,
    ...matcher,
  };
  return [createMatcher(rest, base), { enabled }];
};

const normalizeProcesseMatcherArray = (matchers, base) => {
  if (!isArray$6(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizeProcessMatcher(matcher, base));
};

////////////
// fields //
////////////

const fields = {
  socket: {
    extend: overwrite,
    normalize: identity,
  },
  heartbeat: {
    extend: overwrite,
    normalize: identity,
  },
  threshold: {
    extend: overwrite,
    normalize: identity,
  },
  agent: {
    extend: overwrite,
    normalize: normalizeAgent,
  },
  repository: {
    extend: overwrite,
    normalize: identity,
  },
  scenario: {
    extend: overwrite,
    normalize: identity,
  },
  scenarios: {
    extend: overwrite,
    normalize: normalizeScenarios,
  },
  "recursive-process-recording": {
    extend: overwrite,
    normalize: identity,
  },
  "postmortem-function-exclusion": {
    extend: overwrite,
    normalize: identity,
  },
  command: {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-win32": {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-options": {
    extend: extendCommandOptions,
    normalize: normalizeCommandOptions,
  },
  validate: {
    extend: assign$1,
    normalize: identity,
  },
  log: {
    extend: assign$1,
    normalize: normalizeLog,
  },
  host: {
    extend: overwrite,
    normalize: identity,
  },
  session: {
    extend: overwrite,
    normalize: identity,
  },
  sessions: {
    extend: overwrite,
    normalize: identity,
  },
  "proxy-port": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "http-switch": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "track-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-port": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  enabled: {
    extend: overwrite,
    normalize: identity,
  },
  "default-process": {
    extend: overwrite,
    normalize: normalizeDefaultProcess,
  },
  processes: {
    extend: prepend,
    normalize: normalizeProcesseMatcherArray,
  },
  recorder: {
    extend: overwrite,
    normalize: identity,
  },
  "inline-source": {
    extend: overwrite,
    normalize: identity,
  },
  hooks: {
    extend: assign$1,
    normalize: normalizeHooks,
  },
  ordering: {
    extend: overwrite,
    normalize: identity,
  },
  "collapse-package-hierachy": {
    extend: overwrite,
    normalize: identity,
  },
  serialization: {
    extend: assign$1,
    normalize: identity,
  },
  main: {
    extend: overwrite,
    normalize: toAbsoluteUrl,
  },
  language: {
    extend: overwrite,
    normalize: identity,
  },
  engine: {
    extend: overwrite,
    normalize: identity,
  },
  "default-package": {
    extend: overwrite,
    normalize: normalizeDefaultPackage,
  },
  packages: {
    extend: prepend,
    normalize: normalizePackageMatcherArray,
  },
  exclude: {
    extend: prepend,
    normalize: normalizeExclude,
  },
  recording: {
    extend: overwrite,
    normalize: normalizeRecording,
  },
  appmap_dir: {
    extend: overwrite,
    normalize: normalizeDirectoryUrl,
  },
  appmap_file: {
    extend: overwrite,
    normalize: identity,
  },
  name: {
    extend: overwrite,
    normalize: identity,
  },
  "map-name": {
    extend: overwrite,
    normalize: identity,
  },
  pruning: {
    extend: overwrite,
    normalize: identity,
  },
  labels: {
    extend: prepend,
    normalize: identity,
  },
  feature: {
    extend: overwrite,
    normalize: identity,
    initial: null,
  },
  "feature-group": {
    extend: overwrite,
    normalize: identity,
  },
  frameworks: {
    extend: prepend,
    normalize: normalizeFrameworkArray,
  },
};

////////////
// export //
////////////

const createConfiguration = (home) => ({
  scenarios: [],
  scenario: "^",
  "recursive-process-recording": true,
  command: null,
  "command-win32": null,
  "command-options": {
    cwd: toAbsoluteUrl(".", home),
    shell: false,
    encoding: "utf8",
    env: {},
    stdio: "inherit",
    timeout: 0,
    killSignal: "SIGTERM",
  },
  // overwritten by the agent
  agent: null,
  repository: {
    directory: toAbsoluteUrl(".", home),
    history: null,
    package: null,
  },
  engine: null,
  labels: [],
  feature: null,
  "feature-group": null,
  frameworks: [],
  main: null,
  recording: null,
  // provided by the user
  socket: "net",
  heartbeat: 1000,
  threshold: 100,
  host: "localhost",
  session: null,
  sessions: "^",
  "proxy-port": null,
  "trace-port": 0, // possibly overwritten by the agent
  "http-switch": "__APPMAP__",
  "trace-protocol": "TCP",
  "track-port": 0, // possibly overwritten by the agent
  "track-protocol": "HTTP/1.1",
  "intercept-track-port": "^",
  "intercept-track-protocol": "HTTP/1.1",
  validate: {
    appmap: false,
    message: false,
  },
  log: {
    level: "error",
    file: 2,
  },
  appmap_dir: toAbsoluteUrl("tmp/appmap/", home),
  appmap_file: null,
  "default-process": { enabled: true },
  processes: [],
  recorder: null,
  "postmortem-function-exclusion": null,
  "inline-source": false,
  hooks: {
    apply: HOOK_APPLY_GLOBAL,
    eval: {
      hidden: HOOK_EVAL_GLOBAL,
      aliases: [],
    },
    esm: true,
    cjs: true,
    http: true,
    mysql: null,
    sqlite3: null,
    pg: null,
  },
  ordering: "causal",
  "collapse-package-hierachy": false,
  serialization: {
    "maximum-print-length": 100,
    "maximum-properties-length": 10,
    "impure-printing": true,
    "impure-constructor-naming": true,
    "impure-array-inspection": true,
    "impure-error-inspection": true,
    "impure-hash-inspection": true,
  },
  language: "javascript",
  "default-package": {
    enabled: false,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
  },
  packages: [],
  exclude: [
    {
      combinator: "or",
      name: true,
      "qualified-name": true,
      "every-label": true,
      "some-label": true,
      excluded: false,
      recursive: false,
    },
  ],
  pruning: true,
  name: null,
  "map-name": null,
});

const extendConfiguration = (
  internal_configuration,
  external_configuration,
  base,
) => {
  const extended_internal_configuration = { ...internal_configuration };
  validateExternalConfiguration(external_configuration);
  for (const key of ownKeys$2(external_configuration)) {
    if (hasOwnProperty(fields, key)) {
      const { normalize, extend } = fields[key];
      extended_internal_configuration[key] = extend(
        extended_internal_configuration[key],
        normalize(external_configuration[key], base),
      );
    } else {
      logInfoWhen(
        !EXPECTED_EXTRA_PROPERTIES.includes(key),
        "Configuration property not recognized by the agent: %j",
        key,
      );
    }
  }
  return extended_internal_configuration;
};

const {
  undefined: undefined$a,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$3 },
  Error: Error$3,
  Set: Set$6,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$3(obj, key) !== undefined$a,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set$6([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error$3("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$9,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2 },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor$2(obj, key) !== undefined$9,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const resolveConfigurationManualRecorder = (configuration) => {
  const {
    recorder,
    hooks: { esm },
  } = configuration;
  logWarningWhen(
    recorder !== "manual",
    "Manual recorder expected configuration field 'recorder' to be %s and got %j.",
    "manual",
    recorder,
  );
  logWarningWhen(
    esm,
    "Manual recorder does not support native module recording and configuration field 'hooks.esm' is enabled.",
  );
  return extendConfiguration(
    configuration,
    {
      recorder: "manual",
      hooks: {
        esm: false,
      },
    },
    configuration.repository.directory,
  );
};

const {
  Math: { round: round$2 },
} = globalThis;

const now = () => round$2(1000 * performance.now()) / 1000;

const {
  JSON: { parse: parseJSON$2 },
} = globalThis;

const extractSourcemapUrl = ({ url, content }) => {
  const parts = /\/\/[#@] sourceMappingURL=(.*)[\s]*$/u.exec(content);
  if (parts === null) {
    return null;
  } else {
    return toAbsoluteUrl(parts[1], url);
  }
};

const parseSourcemapJson = ({ url, content }) => {
  try {
    return parseJSON$2(content);
  } catch (error) {
    logWarning("Could not parse source map at %j >> %O", url, error);
    return null;
  }
};

const isSourcemapValid = ({ url, data }) => {
  try {
    validateSourceMap(data);
    return true;
  } catch (error) {
    logWarning("Invalid source map at %j >> %O", url, error);
    return false;
  }
};

const parseSourcemap = (file, base) => {
  const { url } = file;
  const data = parseSourcemapJson(file);
  if (data === null || !isSourcemapValid({ url, data })) {
    return null;
  } else {
    const {
      sourceRoot: root,
      sources: relatives,
      sourcesContent: contents,
      mappings: payload,
    } = {
      sourceRoot: null,
      sourcesContent: null,
      ...data,
    };
    if (!url.startsWith("data:")) {
      base = url;
    }
    if (root !== null && root !== "") {
      base = toDirectoryUrl(toAbsoluteUrl(root, url));
    }
    return {
      sources: relatives.map((relative, index) => ({
        url: toAbsoluteUrl(relative, base),
        content:
          contents === null || index >= contents.length
            ? null
            : contents[index],
      })),
      payload,
    };
  }
};

const compileSourcemap = (payload) => {
  let source_index = 0;
  let source_line = 0;
  let source_column = 0;
  return payload.split(";").map((group) => {
    if (group === "") {
      return [];
    } else {
      let generated_column = 0;
      return group.split(",").map((segment) => {
        const fields = decode(segment);
        /* c8 ignore start */ if (fields.length === 1) {
          return [(generated_column += fields[0])];
        } /* c8 ignore stop */ else {
          return [
            (generated_column += fields[0]),
            (source_index += fields[1]),
            (source_line += fields[2]),
            (source_column += fields[3]),
          ];
        }
      });
    }
  });
};

const mapPosition = (mapping, { line, column }) => {
  if (line > 0 && line <= mapping.length) {
    for (const fields of mapping[line - 1]) {
      if (fields[0] === column && fields.length >= 4) {
        const [, source_index, mapped_line, mapped_column] = fields;
        return {
          index: source_index,
          position: {
            line: mapped_line + 1,
            column: mapped_column,
          },
        };
      }
    }
    return null;
  } else {
    return null;
  }
};

const { parse: parseBabel } = BabelParser;

// const getPredecessorComment = (code, index, comments) => {
//   index -= 1;
//   while (index > 0) {
//     if (comments.has(index)) {
//       return comments.get(index);
//     }
//     if (!/^\p{Zs}$/u.test(code[index])) {
//       break;
//     }
//     index -= 1;
//   }
//   return null;
// };

const printComment = ({ type, value }) => {
  if (type === "CommentBlock") {
    return `/*${value}*/`;
  } else if (type === "CommentLine") {
    return `//${value}`;
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid comment type");
  } /* c8 ignore stop */
};

const getLeadingCommentArray = (node) =>
  coalesce(node, "leadingComments", []);

const trimStartString = (string) => string.trimStart();

const extractLineLabel = (line) => {
  assert(line.startsWith("@label "), "invalid label line", InternalAppmapError);
  const maybe_tokens = line.substring("@label".length).match(/\s+\S+/gu);
  return maybe_tokens === null ? [] : maybe_tokens.map(trimStartString);
};

const extractCommentLabelArray = ({ value: text }) => {
  const maybe_lines = text.match(/@label .*/gu);
  return maybe_lines === null ? [] : maybe_lines.flatMap(extractLineLabel);
};

const resolveSource = (source, { url }) => {
  if (source === null) {
    const extension = getLastUrlExtension(url);
    if (extension === ".cjs" || extension === ".cts" || extension === ".node") {
      return "script";
    } else if (extension === ".mjs" || extension === ".mts") {
      return "module";
    } else {
      return "unambiguous";
    }
  } else {
    return source;
  }
};

const resolvePluginArray = (plugins, { url, content }) => {
  if (plugins === null) {
    const extensions = getUrlExtensionArray(url);
    const plugins = [];
    if (extensions.includes(".jsx")) {
      plugins.push(["jsx", {}]);
    }
    if (
      extensions.includes(".ts") ||
      extensions.includes(".mts") ||
      extensions.includes(".cts")
    ) {
      plugins.push(["typescript", {}]);
    }
    if (
      extensions.includes(".tsx") ||
      extensions.includes(".mtsx") ||
      extensions.includes(".ctsx")
    ) {
      plugins.push(["jsx", {}], ["typescript", {}]);
    }
    if (
      extensions.includes(".flow") ||
      /^[ \t\n]*\/(\/[ \t]*|\*[ \t\n]*)@flow/u.test(content)
    ) {
      plugins.push(["flow", {}]);
    }
    return plugins;
  } else {
    return plugins;
  }
};

const parseSafe = ({ url, content }, options) => {
  try {
    return parseBabel(content, options);
  } catch (error) {
    logError("Unrecoverable parsing error at file %j >> %O", url, error);
    const { sourceType: source_type } = options;
    return {
      errors: [],
      program: {
        type: "Program",
        body: [],
        sourceType: source_type === "unambiguous" ? "script" : source_type,
        loc: {
          start: { line: 0, column: 0 },
          end: { line: 0, column: 0 },
          filename: url,
        },
      },
    };
  }
};

const parseEstree = (file, { source, plugins }) => {
  const { url } = file;
  const { errors, program: node } = parseSafe(file, {
    sourceFilename: url,
    sourceType: resolveSource(source, file),
    plugins: [
      ["estree", { classFeatures: true }],
      ...resolvePluginArray(plugins, file),
    ],
    errorRecovery: true,
    attachComment: true,
  });
  for (const error of errors) {
    logWarning("Recoverable parsing error at file %j >> %O", url, error);
  }
  return node;
};

const {
  String: String$b,
  parseInt: parseInt$1,
  Infinity: Infinity$1,
  Math: { abs },
} = globalThis;

const stringifyPosition = ({ line, column }) =>
  `${String$b(line)}:${String$b(column)}`;

const parsePosition = (string) => {
  const parts = /^([0-9]+):([0-9]+)$/u.exec(string);
  assert(parts !== null, "invalid position format", InternalAppmapError);
  return {
    line: parseInt$1(parts[1]),
    column: parseInt$1(parts[2]),
  };
};

const measurePositionDistance = (
  { line: line1, column: column1 },
  { line: line2, column: column2 },
  { line_weight, column_weight },
) => line_weight * abs(line2 - line1) + column_weight * abs(column2 - column1);

const resolvePosition = (map, position1, options) => {
  const key1 = stringifyPosition(position1);
  if (map.has(key1)) {
    return position1;
  } else {
    let best_distance = Infinity$1;
    let best_position = null;
    for (const key2 of map.keys()) {
      const position2 = parsePosition(key2);
      const distance = measurePositionDistance(position1, position2, options);
      if (distance < best_distance) {
        best_distance = distance;
        best_position = position2;
      }
    }
    const { threshold } = options;
    return best_distance <= threshold ? best_position : null;
  }
};

/* eslint-disable no-use-before-define */

const {
  Object: { entries: toEntries$4 },
  Array: { isArray: isArray$5 },
} = globalThis;

const ANONYMOUS = "[anonymous]";

const DYNAMIC = "[dynamic]";

const getBoundary = ({ start, end }) => ({ start, end });

const getHead = ({ head }) => head;

const getRest = ({ rest }) => rest;

const combine$1 = (results) => ({
  head: results.flatMap(getHead),
  rest: results.flatMap(getRest),
});

const isContainerNodeType = (type) =>
  type === "FunctionExpression" ||
  type === "FunctionDeclaration" ||
  type === "ArrowFunctionExpression" ||
  type === "ClassExpression" ||
  type === "ClassDeclaration" ||
  type === "ObjectExpression";

const getContainerName = (node, name) => {
  if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
    return name === ANONYMOUS && node.id !== null ? node.id.name : name;
  } else if (
    node.type === "FunctionDeclaration" ||
    node.type === "ClassDeclaration"
  ) {
    return node.id === null ? "default" : node.id.name;
  } else if (
    node.type === "ArrowFunctionExpression" ||
    node.type === "ObjectExpression"
  ) {
    return name;
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid container node");
  } /* c8 ignore stop */
};

/////////////
// factory //
/////////////

const createFileEntity = (name, children, node) => ({
  type: "file",
  excluded: false,
  labels: getLeadingCommentArray(node).flatMap(extractCommentLabelArray),
  name,
  children,
});

const createClassEntity = (name, children, node) => ({
  type: "class",
  excluded: false,
  labels: getLeadingCommentArray(node).flatMap(extractCommentLabelArray),
  name,
  children,
});

const createClosureEntity = (name, children, node, is_static) => {
  const comments = getLeadingCommentArray(node);
  return {
    type: "closure",
    excluded: false,
    name,
    children,
    used: false,
    static: is_static,
    comments,
    labels: comments.flatMap(extractCommentLabelArray),
    parameters: node.params.map(getBoundary),
    boundary: getBoundary(node),
    position: { ...node.loc.start }, // cleanup prototype
  };
};

/////////////
// visitor //
/////////////

const visitProgram = (node, name) => {
  if (node.type === "Program") {
    return createFileEntity(
      name,
      node.body.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      node,
    );
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid program node");
  } /* c8 ignore stop */
};

const visitAny = (any) => {
  if (isArray$5(any)) {
    return any.flatMap(visitAny);
  } else if (
    typeof any === "object" &&
    any !== null &&
    hasOwnProperty(any, "type") &&
    typeof any.type === "string"
  ) {
    return visitNode$1(any, ANONYMOUS);
  } else {
    return [];
  }
};

const visitContainerNode = (node, name) => {
  if (
    node.type === "FunctionExpression" ||
    node.type === "FunctionDeclaration" ||
    node.type === "ArrowFunctionExpression"
  ) {
    return {
      head: [
        createClosureEntity(
          getContainerName(node, name),
          [
            ...node.params.flatMap((child) => visitNode$1(child, ANONYMOUS)),
            ...visitNode$1(node.body, ANONYMOUS),
          ],
          node,
          false,
        ),
      ],
      rest: [],
    };
  } else if (
    node.type === "ClassExpression" ||
    node.type === "ClassDeclaration"
  ) {
    const { head, rest } = visitClassBody(node.body);
    return {
      head: [createClassEntity(getContainerName(node, name), head, node)],
      rest: [
        ...(node.superClass === null
          ? []
          : visitNode$1(node.superClass, ANONYMOUS)),
        ...rest,
      ],
    };
  } else if (node.type === "ObjectExpression") {
    const { head, rest } = combine$1(node.properties.map(visitObjectProperty));
    return {
      head: [createClassEntity(getContainerName(node, name), head, node)],
      rest,
    };
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid container node type");
  } /* c8 ignore stop */
};

const visitEntry = ([key, value]) => {
  if (key === "type" || key === "start" || key === "end" || key === "loc") {
    return [];
  } else {
    return visitAny(value);
  }
};

const visitNode$1 = (node, name) => {
  if (node.type === "AssignmentExpression") {
    return [
      ...visitNode$1(node.left, ANONYMOUS),
      ...visitNode$1(
        node.right,
        node.left.type === "Identifier" ? node.left.name : ANONYMOUS,
      ),
    ];
  } else if (node.type === "VariableDeclarator") {
    return [
      ...visitNode$1(node.id, ANONYMOUS),
      ...(node.init === null
        ? []
        : visitNode$1(
            node.init,
            node.id.type === "Identifier" ? node.id.name : ANONYMOUS,
          )),
    ];
  } else if (node.type === "ConditionalExpression") {
    return [
      ...visitNode$1(node.test, ANONYMOUS),
      ...visitNode$1(node.consequent, name),
      ...visitNode$1(node.alternate, name),
    ];
  } else if (node.type === "SequenceExpression") {
    const children = node.expressions.slice();
    const last_child = children.pop();
    return [
      ...children.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      ...visitNode$1(last_child, name),
    ];
  } else if (node.type === "LogicalExpression") {
    return [...visitNode$1(node.left, name), ...visitNode$1(node.right, name)];
  } else if (isContainerNodeType(node.type)) {
    const { head, rest } = visitContainerNode(node, name);
    return [...head, ...rest];
  } else {
    return toEntries$4(node).flatMap(visitEntry);
  }
};

const visitClassBody = (node) => {
  if (node.type === "ClassBody") {
    return combine$1(node.body.map(visitClassProperty));
  } /* c8 ignore start */ else {
    logWarning("unrecognized class body node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitClassProperty = (node) => {
  if (node.type === "MethodDefinition") {
    return {
      rest: visitNode$1(node.key, ANONYMOUS),
      head: visitClassMethod(
        node.value,
        !node.computed && node.key.type === "Identifier"
          ? node.key.name
          : DYNAMIC,
        node.static,
      ),
    };
  } else if (node.type === "PropertyDefinition") {
    return combine$1([
      { head: [], rest: visitNode$1(node.key, ANONYMOUS) },
      node.value === null
        ? { head: [], rest: [] }
        : visitPropertyValue(
            node.value,
            !node.computed && node.key.type === "Identifier"
              ? node.key.name
              : DYNAMIC,
          ),
    ]);
  } /* c8 ignore start */ else {
    logWarning("unrecognized class property node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitClassMethod = (node, name, is_static) => {
  if (node.type === "FunctionExpression") {
    return createClosureEntity(
      name,
      [
        ...node.params.flatMap((child) => visitNode$1(child, ANONYMOUS)),
        .../* typescript abstract method */
        (hasOwnProperty(node, "body") && node.body !== null
          ? visitNode$1(node.body, ANONYMOUS)
          : []),
      ],
      node,
      is_static,
    );
  } /* c8 ignore start */ else {
    logWarning("unrecognized class method node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitObjectProperty = (node) => {
  if (node.type === "Property") {
    return combine$1([
      { head: [], rest: visitNode$1(node.key, ANONYMOUS) },
      visitPropertyValue(
        node.value,
        !node.computed && node.key.type === "Identifier"
          ? node.key.name
          : DYNAMIC,
      ),
    ]);
  } else if (node.type === "SpreadElement") {
    return {
      head: [],
      rest: visitNode$1(node.argument, ANONYMOUS),
    };
  } /* c8 ignore start */ else {
    logWarning("unrecognized object property node %j", node.type);
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  } /* c8 ignore stop */
};

const visitPropertyValue = (node, name) => {
  if (node.type === "LogicalExpression") {
    return combine$1([
      visitPropertyValue(node.left, name),
      visitPropertyValue(node.right, name),
    ]);
  } else if (node.type === "ConditionalExpression") {
    return combine$1([
      { head: [], rest: visitNode$1(node.test, ANONYMOUS) },
      visitPropertyValue(node.consequent, name),
      visitPropertyValue(node.alternate, name),
    ]);
  } else if (node.type === "SequenceExpression") {
    const children = node.expressions.slice();
    const last_child = children.pop();
    return combine$1([
      {
        head: [],
        rest: children.flatMap((child) => visitNode$1(child, ANONYMOUS)),
      },
      visitPropertyValue(last_child, name),
    ]);
  } else if (isContainerNodeType(node.type)) {
    return visitContainerNode(node, name);
  } else {
    return {
      head: [],
      rest: visitNode$1(node, ANONYMOUS),
    };
  }
};

////////////
// export //
////////////

const toEntity = visitProgram;

const {
  RegExp: RegExp$2,
  Object: { entries: toEntries$3 },
} = globalThis;

const compileClause = ([name, pattern]) => {
  if (typeof pattern === "boolean") {
    return (_node, _naming) => pattern;
  } else if (typeof pattern === "string") {
    const regexp = new RegExp$2(pattern, "u");
    const predicate = (string) => regexp.test(string);
    if (name === "name") {
      return (entity, _parent) => predicate(entity.name);
    } else if (name === "qualified-name") {
      return (entity, parent) =>
        predicate(
          entity.type === "closure"
            ? `${parent.name}${entity.static ? "#" : "."}${entity.name}`
            : entity.name,
        );
    } else if (name === "some-label") {
      return (entity, _parent) => entity.labels.some(predicate);
    } else if (name === "every-label") {
      return (entity, _parent) => entity.labels.every(predicate);
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid clause name");
    } /* c8 ignore stop */
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid clause pattern type");
  } /* c8 ignore stop */
};

const compileClauseArray = (combinator, clauses) => {
  const predicates = toEntries$3(clauses).map(compileClause);
  if (combinator === "and") {
    return (node, naming) =>
      predicates.every((predicate) => predicate(node, naming));
  } else if (combinator === "or") {
    return (node, naming) =>
      predicates.some((predicate) => predicate(node, naming));
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid exclusion combinator");
  } /* c8 ignore stop */
};

const compileCriterion = ({ combinator, excluded, recursive, ...clauses }) => {
  const predicate = compileClauseArray(combinator, clauses);
  const spec = { excluded, recursive };
  return (node, naming) => (predicate(node, naming) ? spec : null);
};

const compileCriteria = (criteria) => {
  const closures = criteria.map(compileCriterion);
  return (node, naming) => {
    for (const closure of closures) {
      const maybe_spec = closure(node, naming);
      if (maybe_spec !== null) {
        return maybe_spec;
      }
    }
    throw new InternalAppmapError("missing matching exclusion criterion");
  };
};

const { Map: Map$9, String: String$a } = globalThis;

const getChild = (object, index) => object.children[index];

const hasFunctionType = ({ type }) => type === "function";

const printCommentArray = (comments) => {
  const { length } = comments;
  if (length === 0) {
    return null;
  } else {
    return comments.map(printComment).join("\n");
  }
};

////////////
// Create //
////////////

const registerClosure = (entity, path, closures) => {
  if (entity.type === "closure") {
    closures.set(stringifyPosition(entity.position), path);
  }
  const { length } = entity.children;
  for (let index = 0; index < length; index += 1) {
    registerClosure(
      entity.children[index],
      `${path}/${String$a(index)}`,
      closures,
    );
  }
};

const registerClosureRoot = (entity) => {
  assert(
    entity.type === "file",
    "root entity should be a file",
    InternalAppmapError,
  );
  const closures = new Map$9();
  const { length } = entity.children;
  for (let index = 0; index < length; index += 1) {
    registerClosure(entity.children[index], String$a(index), closures);
  }
  return closures;
};

const createSource$1 = ({ url, content, program }) => {
  const entity = toEntity(program, getUrlBasename(url));
  return {
    url,
    content,
    program,
    root: entity,
    closures: registerClosureRoot(entity),
  };
};

/////////////
// Exclude //
/////////////

const excludeEntityDeeply = (entity, excluded) => {
  entity.excluded = excluded;
  for (const child of entity.children) {
    excludeEntityDeeply(child, excluded);
  }
};

const excludeEntity = (entity, parent, exclude) => {
  const { excluded, recursive } = exclude(entity, parent);
  if (recursive) {
    excludeEntityDeeply(entity, excluded);
  } else {
    entity.excluded = excluded;
    for (const child of entity.children) {
      excludeEntity(child, entity, exclude);
    }
  }
};

const applyExclusionCriteria = ({ root }, criteria) => {
  excludeEntity(root, null, compileCriteria(criteria));
};

///////////
// Query //
///////////

const LINE_WEIGHT = 1024;
const COLUMN_WEIGHT = 1;
const THRESHOLD = 10 * LINE_WEIGHT;

const DISTANCE_OPTIONS = {
  line_weight: LINE_WEIGHT,
  column_weight: COLUMN_WEIGHT,
  threshold: THRESHOLD,
};

const resolveClosurePosition = ({ closures }, position) =>
  resolvePosition(closures, position, DISTANCE_OPTIONS);

const isClosurePositionExcluded = ({ closures, root }, position) => {
  const key = stringifyPosition(position);
  assert(closures.has(key), "missing closure", InternalAppmapError);
  return closures.get(key).split("/").reduce(getChild, root).excluded;
};

const lookupClosurePosition = (
  { root, closures, content },
  position,
) => {
  const key = stringifyPosition(position);
  assert(closures.has(key), "missing closure", InternalAppmapError);
  let parent = null;
  let entity = root;
  for (const index of closures.get(key).split("/")) {
    parent = entity;
    entity = entity.children[index];
  }
  entity.used = true;
  return {
    excluded: entity.excluded,
    parameters: entity.parameters.map(({ start, end }) =>
      content.substring(start, end),
    ),
    parent: parent.name,
    name: entity.name,
    static: entity.static,
    labels: entity.labels,
  };
};

////////////
// Digest //
////////////

const digestEntity = (entity, context) => {
  const children = entity.children.flatMap((child) =>
    digestEntity(child, context),
  );
  if (entity.excluded) {
    return children;
  } else {
    if (entity.type === "file") {
      if (children.some(hasFunctionType)) {
        return [
          {
            type: "class",
            name: entity.name,
            children,
          },
        ];
      } else {
        return children;
      }
    } else if (entity.type === "class") {
      if (children.length === 0 && context.pruning) {
        return [];
      } else {
        return [
          {
            type: "class",
            name: entity.name,
            children,
          },
        ];
      }
    } else if (entity.type === "closure") {
      return [
        ...(!entity.used && context.pruning
          ? []
          : [
              {
                type: "function",
                name: entity.name,
                static: entity.static,
                location: `${context.specifier}:${entity.position.line}`,
                source: context.inline
                  ? context.content.substring(
                      entity.boundary.start,
                      entity.boundary.end,
                    )
                  : null,
                comment: printCommentArray(entity.comments),
                labels: entity.labels,
              },
            ]),
        ...(children.length === 0
          ? []
          : [
              {
                type: "class",
                name: entity.name,
                children,
              },
            ]),
      ];
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid classmap entity type");
    } /* c8 ignore stop */
  }
};

const exportClassmap$1 = ({ root, content }, options) =>
  digestEntity(root, { content, ...options });

const digest = (string) => {
  const hash = createHash("sha256");
  hash.update(string, "utf8");
  return hash.digest("base64");
};

const createSource = (
  { url, content },
  {
    packages: package_matcher_array,
    exclude: global_criteria,
    "default-package": default_package,
    "postmortem-function-exclusion": postmortem,
  },
) => {
  const {
    enabled,
    exclude: local_criteria,
    "source-type": source,
    parsing: plugins,
  } = lookupUrl(package_matcher_array, url, default_package);
  if (enabled) {
    return {
      postmortem,
      enabled: true,
      parsing: { source, plugins },
      criteria: [...local_criteria, ...global_criteria],
      url,
      content,
      hash: null,
      program: null,
      inner: null,
    };
  } else {
    return {
      postmortem,
      enabled: false,
      parsing: { source, plugins },
      criteria: [],
      url,
      content,
      hash: null,
      program: null,
      inner: null,
    };
  }
};

/////////////////////////
// Lazy Initialization //
/////////////////////////

const parseSource = (source) => {
  if (source.program === null) {
    const { url, content, parsing } = source;
    const program = parseEstree({ url, content }, parsing);
    source.program = program;
    return program;
  } else {
    return source.program;
  }
};

const digestSourceContent = (source) => {
  const { content } = source;
  if (source.hash === null && content !== null) {
    const hash = digest(content);
    source.hash = hash;
    return hash;
  } else {
    return source.hash;
  }
};

const toInnerSource = (source) => {
  if (source.inner === null) {
    const { url, content, criteria } = source;
    const program = parseSource(source);
    const inner = createSource$1({ url, content, program });
    applyExclusionCriteria(inner, criteria);
    source.inner = inner;
    return inner;
  } else {
    return source.inner;
  }
};

///////////
// Query //
///////////

const isSourceEnabled = ({ enabled }) => enabled;

const getSourceFile = ({ url, content }) => ({ url, content });

const isSourceContentRequired = ({ enabled, postmortem }) =>
  enabled && postmortem === false;

const isSourcePostmortemExclusion = ({
  postmortem,
  content,
  program,
}) => {
  if (content === null) {
    return true;
  } else if (typeof postmortem === "boolean") {
    return postmortem;
  } else {
    // If the program is already parsed,
    // it reduces of excluding functions here.
    return program === null;
  }
};

const resolveClosureLocation$1 = (source, position) => {
  const { enabled, url } = source;
  if (enabled) {
    if (isSourcePostmortemExclusion(source)) {
      return {
        url,
        hash: digestSourceContent(source),
        position,
      };
    } else {
      const maybe_resolved_position = resolveClosurePosition(
        toInnerSource(source),
        position,
      );
      if (
        maybe_resolved_position === null ||
        isClosurePositionExcluded(
          toInnerSource(source),
          maybe_resolved_position,
        )
      ) {
        return null;
      } else {
        return {
          url,
          hash: digestSourceContent(source),
          position: maybe_resolved_position,
        };
      }
    }
  } else {
    return null;
  }
};

const getUrl = ({ url }) => url;

const extractMissingUrlArray = (url, cache, configuration) => {
  if (cache.has(url)) {
    const content = cache.get(url);
    if (content === null) {
      return [];
    } else {
      const file = { url, content };
      const map_url = extractSourcemapUrl(file);
      if (map_url === null) {
        return [];
      } else {
        if (cache.has(map_url)) {
          const map_content = cache.get(map_url);
          if (map_content === null) {
            return [];
          } else {
            const map_file = {
              url: map_url,
              content: map_content,
            };
            const sourcemap = parseSourcemap(map_file, url);
            if (sourcemap === null) {
              return [];
            } else {
              const { sources } = sourcemap;
              return sources
                .filter(
                  ({ url, content }) =>
                    content === null &&
                    !cache.has(url) &&
                    isSourceContentRequired(
                      createSource({ url, content }, configuration),
                    ),
                )
                .map(getUrl);
            }
          }
        } else {
          return [map_url];
        }
      }
    }
  } else {
    return [url];
  }
};

const loadSourcemap = (file, cache, configuration) => {
  const map_url = extractSourcemapUrl(file);
  if (map_url === null) {
    return null;
  } else {
    const { url } = file;
    if (cache.has(map_url)) {
      const map_content = cache.get(map_url);
      if (map_content === null) {
        return null;
      } else {
        const map_file = {
          url: map_url,
          content: map_content,
        };
        const sourcemap = parseSourcemap(map_file, url);
        if (sourcemap === null) {
          return null;
        } else {
          const { sources, payload } = sourcemap;
          return {
            mapping: compileSourcemap(payload),
            sources: sources.map(({ url, content }) =>
              createSource(
                {
                  url,
                  content:
                    content === null && cache.has(url)
                      ? cache.get(url)
                      : content,
                },
                configuration,
              ),
            ),
          };
        }
      }
    } else {
      return null;
    }
  }
};

const createCodebase$1 = (url, cache, configuration) => {
  assert(cache.has(url), "missing main content", InternalAppmapError);
  const content = cache.get(url);
  assert(
    !logErrorWhen(
      content === null,
      "Cannot not instrument file %j because it could not be loaded",
      url,
    ),
    "missing main content",
    ExternalAppmapError,
  );
  const file = { url, content };
  return {
    main: createSource(file, configuration),
    sourcemap: loadSourcemap(file, cache, configuration),
  };
};

const getEnabledSourceFileArray = ({ main, sourcemap }) =>
  (sourcemap === null ? [main] : sourcemap.sources)
    .filter(isSourceEnabled)
    .map(getSourceFile);

const getMainFile = ({ main }) => getSourceFile(main);

const parseMain = ({ main }) => parseSource(main);

const resolveClosureLocation = ({ main, sourcemap }, position) => {
  if (sourcemap === null) {
    return resolveClosureLocation$1(main, position);
  } else {
    const { sources, mapping } = sourcemap;
    const maybe_indexed_position = mapPosition(mapping, position);
    if (maybe_indexed_position === null) {
      // This is fine, it happens when compilation introduces new functions.
      // eg:
      // ```js
      //   var __importDefault = (this && this.__importDefault) || function (mod) {
      //     return (mod && mod.__esModule) ? mod : { "default": mod };
      //   };
      // ```
      return null;
    } else {
      const { index, position: mapped_position } = maybe_indexed_position;
      if (index >= 0 && index < sources.length) {
        return resolveClosureLocation$1(sources[index], mapped_position);
      } /* c8 ignore start */ else {
        logWarning(
          "Treating %j in %j as excluded because its mapped source index is out-of-range",
          position,
          getSourceFile(main).url,
        );
        return null;
      } /* c8 ignore stop */
    }
  }
};

const { String: String$9, parseInt, undefined: undefined$8 } = globalThis;

const regexp = /^([A-Za-z0-9+/=]+\|)?([\s\S]+):([0-9]+):([0-9]+)$/u;

const stringifyLocation = ({
  url,
  hash,
  position: { line, column },
}) => {
  if (hash === null) {
    return `${url}:${String$9(line)}:${String$9(column)}`;
  } else {
    return `${hash}|${url}:${String$9(line)}:${String$9(column)}`;
  }
};

const parseLocation = (string) => {
  const parts = regexp.exec(string);
  assert(parts !== null, "invalid location format", InternalAppmapError);
  return {
    hash:
      parts[1] === undefined$8
        ? null
        : parts[1].substring(0, parts[1].length - 1),
    url: parts[2],
    position: {
      line: parseInt(parts[3]),
      column: parseInt(parts[4]),
    },
  };
};

const {
  Error: Error$2,
  String: String$8,
  Array: { isArray: isArray$4 },
  Object: { fromEntries: fromEntries$3 },
  Reflect: { ownKeys: ownKeys$1 },
} = globalThis;

//////////////////////////////
// Difficulties with groups //
//////////////////////////////

// import {createHook, executionAsyncId} from "async_hooks";
// createHook({}).enable();
// import {writeFileSync} from "fs";
// const {stdout:{fd}} = process;
// const log = (string) => writeFileSync(fd, `[${executionAsyncId()}] ${string}\n`);
// const logAwait = async (promise) => {
//   log("before");
//   try {
//     await promise;
//   } finally {
//     log("after");
//   }
// };
// const mainAsync = async () => {
//   log("begin");
//   try {
//     await logAwait(new Promise((resolve) => {
//       setTimeout(resolve, 1000, 123);
//     }));
//   } finally {
//     log("end");
//   }
// };
// await mainAsync();

// import {createHook, executionAsyncId} from "async_hooks";
// createHook({}).enable();
// import {writeFileSync} from "fs";
// const {stdout:{fd}} = process;
// const log = (string) => writeFileSync(fd, `[${executionAsyncId()}] ${string}\n`);
// function* logYield (result) {
//   log("before");
//   yield result;
//   log("after");
// };
// async function* main () {
//   log("begin");
//   yield* logYield(123);
//   log("end");
// }
// const iterator = main();
// iterator.next();
// iterator.next();

/////////////
// Builder //
/////////////

const makeProgram = (source, body) => ({
  type: "Program",
  sourceType: source,
  body,
});

const makeClosure = (
  type,
  asynchronous,
  generator,
  expression,
  id,
  params,
  body,
) => ({
  type,
  async: asynchronous,
  generator,
  expression,
  id,
  params,
  body,
});

const makeSequenceExpression = (nodes) => ({
  type: "SequenceExpression",
  expressions: nodes,
});

const makeStatement = (node) => ({
  type: "ExpressionStatement",
  expression: node,
});

const makeIfStatement = (node1, node2, node3) => ({
  type: "IfStatement",
  test: node1,
  consequent: node2,
  alternate: node3,
});

const makeBlockStatement = (nodes) => ({
  type: "BlockStatement",
  body: nodes,
});

const makeAwaitExpression = (node) => ({
  type: "AwaitExpression",
  argument: node,
});

const makeYieldExpression = (delegate, node) => ({
  type: "YieldExpression",
  delegate,
  argument: node,
});

const makeConditionalExpression = (node1, node2, node3) => ({
  type: "ConditionalExpression",
  test: node1,
  consequent: node2,
  alternate: node3,
});

const makeLogicalExpression = (operator, node1, node2) => ({
  type: "LogicalExpression",
  operator,
  left: node1,
  right: node2,
});

const makeCatchClause = (node1, node2) => ({
  type: "CatchClause",
  param: node1,
  body: node2,
});

const makeTryStatement = (node1, node2, node3) => ({
  type: "TryStatement",
  block: node1,
  handler: node2,
  finalizer: node3,
});

const makeRestElement = (node) => ({
  type: "RestElement",
  argument: node,
});

const makeUnaryExpression = (operator, node) => ({
  type: "UnaryExpression",
  prefix: true,
  operator,
  argument: node,
});

const makeBinaryExpression = (operator, node1, node2) => ({
  type: "BinaryExpression",
  operator,
  left: node1,
  right: node2,
});

const makeAssignmentExpression = (node1, node2) => ({
  type: "AssignmentExpression",
  operator: "=",
  left: node1,
  right: node2,
});

const makeArrayExpression = (nodes) => ({
  type: "ArrayExpression",
  elements: nodes,
});

const makeThisExpression = () => ({
  type: "ThisExpression",
});

const makeIdentifier = (name) => ({
  type: "Identifier",
  name,
});

const makeLiteral = (name) => ({
  type: "Literal",
  value: name,
});

const makeVariableDeclaration = (kind, nodes) => ({
  type: "VariableDeclaration",
  kind,
  declarations: nodes,
});

const makeThrowStatement = (node) => ({
  type: "ThrowStatement",
  argument: node,
});

const makeVariableDeclarator = (node1, node2) => ({
  type: "VariableDeclarator",
  id: node1,
  init: node2,
});

const makeCallExpression = (node, nodes) => ({
  type: "CallExpression",
  optional: false,
  callee: node,
  arguments: nodes,
});

const makeExpressionStatement = (node) => ({
  type: "ExpressionStatement",
  expression: node,
});

const makeRegularMemberExpression = (name1, name2) => ({
  type: "MemberExpression",
  optional: false,
  computed: false,
  object: makeIdentifier(name1),
  property: makeIdentifier(name2),
});

const makeReturnStatement = (argument) => ({
  type: "ReturnStatement",
  argument,
});

///////////////
// Component //
///////////////

const isJumpClosureNode = (node) => {
  if (node.type === "Program") {
    return node.sourceType === "module";
  } else if (
    node.type === "FunctionExpression" ||
    node.type === "FunctionDeclaration"
  ) {
    return node.async || node.generator;
  } else if (node.type === "ArrowFunctionExpression") {
    return node.async;
  } /* c8 ignore start */ else {
    throw new Error$2("unexpected closure node");
  } /* c8 ignore stop */
};

const isSubclassConstructor = (_node, parent, grand_parent) =>
  parent.type === "MethodDefinition" &&
  parent.kind === "constructor" &&
  grand_parent.superClass !== null;

const isEstreeKey = (key) => key !== "loc" && key !== "start" && key !== "end";

/* eslint-disable no-use-before-define */
const visitNode = (node, parent, grand_parent, closure, context) => {
  if (isArray$4(node)) {
    return node.map((node) =>
      visitNode(node, parent, grand_parent, closure, context),
    );
  } else if (
    typeof node === "object" &&
    node !== null &&
    hasOwnProperty(node, "type")
  ) {
    if (hasOwnProperty(instrumenters, node.type)) {
      const maybe_node = instrumenters[node.type](
        node,
        parent,
        grand_parent,
        closure,
        context,
      );
      return maybe_node === null
        ? visitGeneric(node, parent, grand_parent, closure, context)
        : maybe_node;
    } else {
      return visitGeneric(node, parent, grand_parent, closure, context);
    }
  } else {
    return node;
  }
};
/* eslint-enable no-use-before-define */

const visitGeneric = (node, parent, _grand_parent, closure, context) =>
  fromEntries$3(
    ownKeys$1(node)
      .filter(isEstreeKey)
      .map((key) => [
        key,
        visitNode(node[key], node, parent, closure, context),
      ]),
  );

const instrumentClosure = (node, parent, grand_parent, closure, context) => {
  const maybe_location = resolveClosureLocation(
    context.codebase,
    node.loc.start,
  );
  closure = {
    node,
    instrumented: context.apply !== null && maybe_location !== null,
  };
  if (closure.instrumented) {
    const location_string = stringifyLocation(maybe_location);
    return makeClosure(
      node.type,
      node.async,
      node.generator,
      false,
      mapMaybe(coalesce(node, "id", null), (child) =>
        visitNode(child, node, parent, closure, context),
      ),
      node.params.map((param, index) => {
        const pattern = makeIdentifier(
          `${context.apply}_ARGUMENT_${String$8(index)}`,
        );
        return param.type === "RestElement"
          ? makeRestElement(pattern)
          : pattern;
      }),
      makeBlockStatement([
        makeVariableDeclaration("var", [
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_BUNDLE_TAB`),
            makeCallExpression(
              makeRegularMemberExpression(context.apply, "getFreshTab"),
              [],
            ),
          ),
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_RESULT`),
            null,
          ),
          makeVariableDeclarator(
            makeIdentifier(`${context.apply}_DONE`),
            makeLiteral(false),
          ),
          ...(isJumpClosureNode(node)
            ? [
                makeVariableDeclarator(
                  makeIdentifier(`${context.apply}_JUMP`),
                  null,
                ),
                makeVariableDeclarator(
                  makeIdentifier(`${context.apply}_JUMP_TAB`),
                  makeLiteral(null),
                ),
              ]
            : []),
        ]),
        makeExpressionStatement(
          makeCallExpression(
            makeRegularMemberExpression(context.apply, "recordApply"),
            [
              makeIdentifier(`${context.apply}_BUNDLE_TAB`),
              makeLiteral(location_string),
              node.type === "ArrowFunctionExpression" ||
              isSubclassConstructor(node, parent, grand_parent)
                ? makeRegularMemberExpression(context.apply, "empty")
                : makeThisExpression(),
              makeArrayExpression(
                node.params.map((_param, index) =>
                  makeIdentifier(`${context.apply}_ARGUMENT_${String$8(index)}`),
                ),
              ),
            ],
          ),
        ),
        makeTryStatement(
          makeBlockStatement([
            ...(node.params.length === 0
              ? []
              : [
                  makeVariableDeclaration(
                    "var",
                    node.params.map((param, index) => {
                      if (param.type === "RestElement") {
                        param = param.argument;
                      }
                      // Special case for AssignmentPattern:
                      //
                      // function f (x = {}) {}
                      //
                      // function f (APPMAP_ARGUMENT_0) {
                      //   // does not work :(
                      //   var x = {} = APPMAP_ARGUMENT_0;
                      // }
                      if (param.type === "AssignmentPattern") {
                        return makeVariableDeclarator(
                          param.left,
                          makeConditionalExpression(
                            makeBinaryExpression(
                              "===",
                              makeIdentifier(
                                `${context.apply}_ARGUMENT_${String$8(index)}`,
                              ),
                              makeUnaryExpression("void", makeLiteral(0)),
                            ),
                            param.right,
                            makeIdentifier(
                              `${context.apply}_ARGUMENT_${String$8(index)}`,
                            ),
                          ),
                        );
                      } else {
                        return makeVariableDeclarator(
                          param,
                          makeIdentifier(
                            `${context.apply}_ARGUMENT_${String$8(index)}`,
                          ),
                        );
                      }
                    }),
                  ),
                ]),
            node.expression
              ? makeReturnStatement(
                  makeAssignmentExpression(
                    makeIdentifier(`${context.apply}_RESULT`),
                    visitNode(node.body, node, parent, closure, context),
                  ),
                )
              : visitNode(node.body, node, parent, closure, context),
          ]),
          makeCatchClause(
            makeIdentifier(`${context.apply}_ERROR`),
            makeBlockStatement([
              ...(isJumpClosureNode(node)
                ? [
                    makeIfStatement(
                      makeBinaryExpression(
                        "!==",
                        makeIdentifier(`${context.apply}_JUMP_TAB`),
                        makeLiteral(null),
                      ),
                      makeBlockStatement([
                        makeStatement(
                          makeCallExpression(
                            makeRegularMemberExpression(
                              context.apply,
                              "recordReject",
                            ),
                            [
                              makeIdentifier(`${context.apply}_JUMP_TAB`),
                              makeIdentifier(`${context.apply}_ERROR`),
                            ],
                          ),
                        ),
                        makeStatement(
                          makeAssignmentExpression(
                            makeIdentifier(`${context.apply}_JUMP_TAB`),
                            makeLiteral(null),
                          ),
                        ),
                      ]),
                      null,
                    ),
                  ]
                : []),
              makeExpressionStatement(
                makeAssignmentExpression(
                  makeIdentifier(`${context.apply}_DONE`),
                  makeLiteral(true),
                ),
              ),
              makeExpressionStatement(
                makeCallExpression(
                  makeRegularMemberExpression(context.apply, "recordThrow"),
                  [
                    makeIdentifier(`${context.apply}_BUNDLE_TAB`),
                    makeLiteral(location_string),
                    makeIdentifier(`${context.apply}_ERROR`),
                  ],
                ),
              ),
              makeThrowStatement(makeIdentifier(`${context.apply}_ERROR`)),
            ]),
          ),
          makeBlockStatement([
            ...(isJumpClosureNode(node)
              ? [
                  makeIfStatement(
                    makeBinaryExpression(
                      "!==",
                      makeIdentifier(`${context.apply}_JUMP_TAB`),
                      makeLiteral(null),
                    ),
                    makeBlockStatement([
                      makeStatement(
                        makeCallExpression(
                          makeRegularMemberExpression(
                            context.apply,
                            "recordResolve",
                          ),
                          [
                            makeIdentifier(`${context.apply}_JUMP_TAB`),
                            makeRegularMemberExpression(context.apply, "empty"),
                          ],
                        ),
                      ),
                      makeStatement(
                        makeAssignmentExpression(
                          makeIdentifier(`${context.apply}_JUMP_TAB`),
                          makeLiteral(null),
                        ),
                      ),
                    ]),
                    null,
                  ),
                ]
              : []),
            makeIfStatement(
              makeUnaryExpression("!", makeIdentifier(`${context.apply}_DONE`)),
              makeBlockStatement([
                makeExpressionStatement(
                  makeCallExpression(
                    makeRegularMemberExpression(context.apply, "recordReturn"),
                    [
                      makeIdentifier(`${context.apply}_BUNDLE_TAB`),
                      makeLiteral(location_string),
                      makeIdentifier(`${context.apply}_RESULT`),
                    ],
                  ),
                ),
              ]),
              null,
            ),
          ]),
        ),
      ]),
    );
  } else {
    return makeClosure(
      node.type,
      node.async,
      node.generator,
      node.expression,
      mapMaybe(node.id, (child) =>
        visitNode(child, node, parent, closure, context),
      ),
      node.params.map((param) =>
        visitNode(param, node, parent, closure, context),
      ),
      visitNode(node.body, node, parent, closure, context),
    );
  }
};

const compileInstrumentJumpExpression =
  (makeRecordJumpExpression, makeForwardJumpExpression) =>
  (node, parent, _grand_parent, closure, context) =>
    closure.instrumented
      ? makeSequenceExpression([
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP`),
            visitNode(node.argument, node, parent, closure, context),
          ),
          makeLogicalExpression(
            "||",
            makeBinaryExpression(
              "===",
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
            makeIdentifier(`${context.apply}_APPMAP_JUMP_ASSERTION_VIOLATION`),
          ),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP_TAB`),
            makeCallExpression(
              makeRegularMemberExpression(context.apply, "getFreshTab"),
              [],
            ),
          ),
          makeRecordJumpExpression(node, context.apply),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP`),
            makeForwardJumpExpression(node, context.apply),
          ),
          makeCallExpression(
            makeRegularMemberExpression(context.apply, "recordResolve"),
            [
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeIdentifier(`${context.apply}_JUMP`),
            ],
          ),
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_JUMP_TAB`),
            makeLiteral(null),
          ),
          makeIdentifier(`${context.apply}_JUMP`),
        ])
      : null;

const instrumenters = {
  AwaitExpression: compileInstrumentJumpExpression(
    (_node, namespace) =>
      makeCallExpression(
        makeRegularMemberExpression(namespace, "recordAwait"),
        [
          makeIdentifier(`${namespace}_JUMP_TAB`),
          makeIdentifier(`${namespace}_JUMP`),
        ],
      ),
    (_node, namespace) =>
      makeAwaitExpression(makeIdentifier(`${namespace}_JUMP`)),
  ),
  YieldExpression: compileInstrumentJumpExpression(
    ({ delegate }, namespace) =>
      makeCallExpression(
        makeRegularMemberExpression(namespace, "recordYield"),
        [
          makeIdentifier(`${namespace}_JUMP_TAB`),
          makeLiteral(delegate),
          makeIdentifier(`${namespace}_JUMP`),
        ],
      ),
    ({ delegate }, namespace) =>
      makeYieldExpression(delegate, makeIdentifier(`${namespace}_JUMP`)),
  ),
  ReturnStatement: (node, parent, _grand_parent, closure, context) =>
    closure.instrumented && node.argument !== null
      ? makeReturnStatement(
          makeAssignmentExpression(
            makeIdentifier(`${context.apply}_RESULT`),
            visitNode(node.argument, node, parent, closure, context),
          ),
        )
      : null,
  CallExpression: (node, parent, _grand_parent, closure, context) => {
    if (
      node.callee.type === "Identifier" &&
      context.eval.aliases.includes(node.callee.name) &&
      node.arguments.length > 0
    ) {
      return makeCallExpression(makeIdentifier(node.callee.name), [
        makeCallExpression(makeIdentifier(context.eval.hidden), [
          makeLiteral(context.url),
          makeLiteral(
            `${String$8(node.loc.start.line)}-${String$8(node.loc.start.column)}`,
          ),
          visitNode(node.arguments[0], node, parent, closure, context),
        ]),
        ...node.arguments
          .slice(1)
          .map((argument) =>
            visitNode(argument, node, parent, closure, context),
          ),
      ]);
    } else {
      return null;
    }
  },
  TryStatement: (node, parent, _grand_parent, closure, context) => {
    if (closure.instrumented && isJumpClosureNode(closure.node)) {
      return makeTryStatement(
        visitNode(node.block, node, parent, closure, context),
        makeCatchClause(
          makeIdentifier(`${context.apply}_ERROR`),
          makeBlockStatement([
            makeIfStatement(
              makeBinaryExpression(
                "!==",
                makeIdentifier(`${context.apply}_JUMP_TAB`),
                makeLiteral(null),
              ),
              makeBlockStatement([
                makeStatement(
                  makeCallExpression(
                    makeRegularMemberExpression(context.apply, "recordReject"),
                    [
                      makeIdentifier(`${context.apply}_JUMP_TAB`),
                      makeIdentifier(`${context.apply}_ERROR`),
                    ],
                  ),
                ),
                makeStatement(
                  makeAssignmentExpression(
                    makeIdentifier(`${context.apply}_JUMP_TAB`),
                    makeLiteral(null),
                  ),
                ),
              ]),
              null,
            ),
            ...(node.handler === null
              ? []
              : [
                  ...(node.handler.param === null
                    ? []
                    : [
                        makeVariableDeclaration("let", [
                          makeVariableDeclarator(
                            visitNode(
                              node.handler.param,
                              node.handler,
                              node,
                              closure,
                              context,
                            ),
                            makeIdentifier(`${context.apply}_ERROR`),
                          ),
                        ]),
                      ]),
                  visitNode(
                    node.handler.body,
                    node.handler,
                    node,
                    closure,
                    context,
                  ),
                ]),
          ]),
        ),
        makeBlockStatement([
          makeIfStatement(
            makeBinaryExpression(
              "!==",
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
            makeBlockStatement([
              makeStatement(
                makeCallExpression(
                  makeRegularMemberExpression(context.apply, "recordResolve"),
                  [
                    makeIdentifier(`${context.apply}_JUMP_TAB`),
                    makeRegularMemberExpression(context.apply, "empty"),
                  ],
                ),
              ),
              makeStatement(
                makeAssignmentExpression(
                  makeIdentifier(`${context.apply}_JUMP_TAB`),
                  makeLiteral(null),
                ),
              ),
            ]),
            null,
          ),
          ...(node.finalizer === null
            ? []
            : [visitNode(node.finalizer, node, parent, closure, context)]),
        ]),
      );
    } else {
      return null;
    }
  },
  Identifier: (node, _parent, _grand_parent, _closure, context) => {
    assert(
      !logErrorWhen(
        node.name.startsWith(context.apply),
        "Identifier collision detected at %j line %j column %j >> identifier should not start with %j, got: %j",
        context.url,
        node.loc.start.line,
        node.loc.start.column,
        context.apply,
        node.name,
      ),
      "Identifier collision",
      ExternalAppmapError,
    );
    return null;
  },
  Program: (node, parent, _grand_parent, closure, context) =>
    closure.instrumented && node.sourceType === "module"
      ? makeProgram("module", [
          makeVariableDeclaration("let", [
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_BUNDLE_TAB`),
              makeCallExpression(
                makeRegularMemberExpression(context.apply, "getFreshTab"),
                [],
              ),
            ),
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_JUMP`),
              null,
            ),
            makeVariableDeclarator(
              makeIdentifier(`${context.apply}_JUMP_TAB`),
              makeLiteral(null),
            ),
          ]),
          ...node.body.map((child) =>
            visitNode(child, node, parent, closure, context),
          ),
        ])
      : null,
  FunctionExpression: instrumentClosure,
  FunctionDeclaration: instrumentClosure,
  ArrowFunctionExpression: instrumentClosure,
};

const initial_parent = { type: "File" };

const initial_grand_parent = { type: "Root" };

const visit = (node, context) => {
  assert(
    node.type === "Program",
    "expected program as top level estree node",
    InternalAppmapError,
  );
  // Top level async jump only present in module.
  // Avoid poluting global scope in script.
  return visitNode(
    node,
    initial_parent,
    initial_grand_parent,
    {
      node,
      instrumented: context.apply !== null && node.sourceType === "module",
    },
    context,
  );
};

const { generate: generateEstree } = Astring;

const instrument$1 = (url, cache, configuration) => {
  const codebase = createCodebase$1(url, cache, configuration);
  const files = getEnabledSourceFileArray(codebase);
  if (files.length === 0) {
    logDebug("*Not* recording file %j", url);
    return {
      ...getMainFile(codebase),
      sources: [],
    };
  } else {
    logDebug("Recording file %j", url);
    return {
      url,
      content: generateEstree(
        visit(parseMain(codebase), {
          url,
          eval: configuration.hooks.eval,
          apply: configuration.hooks.apply,
          codebase,
        }),
      ),
      sources: files,
    };
  }
};

const { Map: Map$8 } = globalThis;

const readFileSafe = (url, readFile) => {
  try {
    return readFile(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const readFileSafeAsync = async (url, readFileAsync) => {
  try {
    return await readFileAsync(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const instrumentInject = (url, content, configuration, readFile) => {
  const cache = new Map$8(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, readFileSafe(url, readFile));
      }
    }
  }
};

const instrumentInjectAsync = async (
  url,
  content,
  configuration,
  readFileAsync,
) => {
  const cache = new Map$8(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, await readFileSafeAsync(url, readFileAsync));
      }
    }
  }
};

const {
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getPrototypeOf: getPrototypeOf$1, ownKeys },
  Error: { prototype: error_prototype },
  Infinity,
  Symbol,
  Symbol: { keyFor, for: symbolFor },
  WeakMap,
  Map: Map$7,
  Set: Set$5,
  String: String$7,
  undefined: undefined$7,
  Math: { min },
  Object: { prototype: object_prototype, fromEntries: fromEntries$2 },
  Array: { isArray: isArray$3 },
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const empty = symbolFor("APPMAP_EMPTY_MARKER");

const isSymbol = (any) => typeof any === "symbol";

const isString = (any) => typeof any === "string";

const wellknown = new Set$5(
  ownKeys(Symbol)
    .map((key) => Symbol[key])
    .filter(isSymbol),
);

////////////////////
// Reflect Helper //
////////////////////
const getOwnKeyArrayImpure = (object) => {
  try {
    return ownKeys(object);
  } catch (error) {
    logDebug(
      "Reflect.ownKeys(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return [];
  }
};
const getPrototypeImpure = (object) => {
  try {
    return getPrototypeOf$1(object);
  } catch (error) {
    logDebug(
      "Reflect.getPrototypeOf(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return null;
  }
};
const getOwnPropertyDescriptorImpure = (object, key) => {
  try {
    return getOwnPropertyDescriptor$1(object, key);
  } catch (error) {
    logDebug(
      "Reflect.getOwnPropertyDescriptor(%o, %j) threw %O (this should only happen when the object is a proxy)",
      object,
      key,
      error,
    );
    return undefined$7;
  }
};
const hasPrototypeImpure = (object, prototype) => {
  while (object !== null) {
    if (object === prototype) {
      return true;
    }
    object = getPrototypeImpure(object);
  }
  return false;
};
const getDataPropertyImpure = (object, key) => {
  while (object !== null) {
    const descriptor = getOwnPropertyDescriptorImpure(object, key);
    if (descriptor !== undefined$7 && hasOwnProperty(descriptor, "value")) {
      return descriptor.value;
    }
    object = getPrototypeImpure(object);
  }
  return undefined$7;
};
const toStringImpure = (object) => {
  try {
    return object.toString();
  } catch (error) {
    logDebug("%o.toString() failure >> %O", object, error);
    return undefined$7;
  }
};
///////////
// Index //
///////////
const generateGetIndex =
  (name) =>
  ({ [name]: map, counter }, value) => {
    const index = map.get(value);
    if (index !== undefined$7) {
      return index;
    } else {
      const new_index = incrementCounter(counter);
      map.set(value, new_index);
      return new_index;
    }
  };
const getSymbolIndex = generateGetIndex("symbols");
const getReferenceIndex = generateGetIndex("references");
////////////////////////
// getConstructorName //
////////////////////////
const getConstructorName = ({ impure_constructor_naming }, object) => {
  if (impure_constructor_naming) {
    const _constructor = getDataPropertyImpure(object, "constructor");
    if (typeof _constructor === "function") {
      const name = getDataPropertyImpure(_constructor, "name");
      logDebugWhen(
        typeof name !== "string",
        "Constructor name of %o is not a string: %o",
        object,
        name,
      );
      return typeof name === "string" ? name : typeof object;
    } else {
      return typeof object;
    }
  } else {
    return typeof object;
  }
};
///////////////
// stringify //
///////////////
const generatePrint =
  (printString) =>
  ({ impure_printing }, any) => {
    if (
      any === null ||
      any === undefined$7 ||
      typeof any === "boolean" ||
      typeof any === "number"
    ) {
      return String$7(any);
    } else if (typeof any === "string") {
      return printString(any);
    } else if (typeof any === "bigint") {
      return `${String$7(any)}n`;
    } else if (typeof any === "symbol") {
      if (wellknown.has(any)) {
        return `well-known ${String$7(any)}`;
      } else if (keyFor(any) !== undefined$7) {
        return `global ${String$7(any)}`;
      } else {
        return String$7(any);
      }
    } else if (typeof any === "function") {
      if (impure_printing) {
        const name = getDataPropertyImpure(any, "name");
        if (getOwnPropertyDescriptorImpure(any, "prototype") !== undefined$7) {
          if (typeof name === "string" && name !== "") {
            return `function ${name} (...) { ... }`;
          } else {
            return `function (...) { ... }`;
          }
        } else {
          if (typeof name === "string" && name !== "") {
            return `${name} = (...) => { ... }`;
          } else {
            return `(...) => { ... }`;
          }
        }
      } else {
        return "function";
      }
    } else if (typeof any === "object") {
      if (impure_printing) {
        const representation = toStringImpure(any);
        logDebugWhen(
          typeof representation !== "string",
          "%o.toString() did not return a string, got: %o",
          any,
          representation,
        );
        return typeof representation === "string" ? representation : "object";
      } else {
        return "object";
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("unknown type");
    } /* c8 ignore stop */
  };
const print = generatePrint(stringifyJSON$2);
const show = generatePrint(identity);
//////////////////
// getSpecific  //
//////////////////
const getSpecific = (serialization, object) => {
  if (
    serialization.impure_error_inspection &&
    hasPrototypeImpure(object, error_prototype)
  ) {
    return {
      type: "error",
      name: show(serialization, getDataPropertyImpure(object, "name")),
      message: show(serialization, getDataPropertyImpure(object, "message")),
      stack: show(serialization, getDataPropertyImpure(object, "stack")),
    };
  } else if (serialization.impure_array_inspection && isArray$3(object)) {
    // Proxies cannot change array's length so we know it will be a number.
    return { type: "array", length: getDataPropertyImpure(object, "length") };
  } else if (
    serialization.impure_hash_inspection &&
    (getPrototypeImpure(object) === null ||
      getPrototypeImpure(object) === object_prototype)
  ) {
    const keys = getOwnKeyArrayImpure(object).filter(isString);
    const entries = [];
    const length = min(keys.length, serialization.maximum_properties_length);
    for (let index = 0; index < length; index += 1) {
      const key = keys[index];
      entries.push([key, typeof getDataPropertyImpure(object, key)]);
    }
    return {
      type: "hash",
      length,
      properties: fromEntries$2(entries),
    };
  } else {
    return null;
  }
};
const serializeNonEmpty = (serialization, value) => {
  const type = value === null ? "null" : typeof value;
  const representation = print(serialization, value);
  if (
    type === "null" ||
    type === "undefined" ||
    type === "boolean" ||
    type === "number" ||
    type === "string" ||
    type === "bigint"
  ) {
    return { type, print: representation };
  } else if (type === "symbol") {
    return {
      type,
      print: representation,
      index: getSymbolIndex(serialization, value),
    };
  } else {
    return {
      type,
      print: representation,
      index: getReferenceIndex(serialization, value),
      constructor: getConstructorName(serialization, value),
      specific: getSpecific(serialization, value),
    };
  }
};

const createSerialization = ({
  serialization: {
    "maximum-print-length": maximum_print_length,
    "maximum-properties-length": maximum_properties_length,
    "impure-printing": impure_printing,
    "impure-constructor-naming": impure_constructor_naming,
    "impure-array-inspection": impure_array_inspection,
    "impure-error-inspection": impure_error_inspection,
    "impure-hash-inspection": impure_hash_inspection,
  },
}) => ({
  counter: createCounter(0),
  empty,
  symbols: new Map$7(),
  references: new WeakMap(),
  maximum_print_length:
    maximum_print_length === null ? Infinity : maximum_print_length,
  maximum_properties_length,
  impure_printing,
  impure_constructor_naming,
  impure_array_inspection,
  impure_error_inspection,
  impure_hash_inspection,
});

const getSerializationEmptyValue$1 = ({ empty }) => empty;

const serialize$1 = (serialization, value) => {
  if (value === serialization.empty) {
    return null;
  } else {
    const serial = serializeNonEmpty(serialization, value);
    if (serial.print.length > serialization.maximum_print_length) {
      return {
        ...serial,
        print: `${serial.print.substring(
          0,
          serialization.maximum_print_length - 4,
        )} ...`,
      };
    } else {
      return serial;
    }
  }
};

const START = "TR?";
const STOP = "TR!";
const ERROR = "ERR";
const SOURCE = "SRC";
const BEGIN_REQUEST_AMEND = "RQ.";

const SESSION_ASSIGNMENT = "SE!";

const GROUP_DEFINITION = "GR?";
const GROUP_ASSIGNMENT = "GR!";

const BEGIN_BUNDLE_EVENT = "BD>";
const END_BUNDLE_EVENT = "BD<";

const BEFORE_JUMP_EVENT = "JP?";
const AFTER_JUMP_EVENT = "JP!";

const BEGIN_APPLY_EVENT = "APP";
const END_RETURN_EVENT = "RET";
const END_THROW_EVENT = "TRW";

const BEFORE_AWAIT_EVENT = "AWT";
const BEFORE_YIELD_EVENT = "YLD";
const AFTER_RESOLVE_EVENT = "RES";
const AFTER_REJECT_EVENT = "REJ";

const BEGIN_REQUEST_EVENT = "RQ>";
const END_RESPONSE_EVENT = "RS<";
const BEFORE_REQUEST_EVENT = "RQ?";
const AFTER_RESPONSE_EVENT = "RS!";

const BEFORE_QUERY_EVENT = "QRY";
const AFTER_ANSWER_EVENT = "ASW";

const BUNDLE_PAYLOAD = { type: "bundle" };
const JUMP_PAYLOAD = { type: "jump" };

/////////////
// inflate //
/////////////

const inflaters = {
  __proto__: null,
  // not event //
  [START]: (_session, _group, [_head, track, configuration]) => ({
    type: "start",
    track,
    configuration,
  }),
  [STOP]: (_session, _group, [_head, track, termination]) => ({
    type: "stop",
    track,
    termination,
  }),
  [SOURCE]: (_session, _group, [_head, url, content]) => ({
    type: "source",
    url,
    content,
  }),
  [ERROR]: (session, _group, [_head, error]) => ({
    type: "error",
    session,
    error,
  }),
  [GROUP_DEFINITION]: (
    session,
    _group,
    [_head, group, child, description],
  ) => ({
    type: "group",
    session,
    group,
    child,
    description,
  }),
  [BEGIN_REQUEST_AMEND]: (
    session,
    _group,
    [_head, tab, protocol, method, url, route, headers, body],
  ) => ({
    type: "amend",
    site: "begin",
    session,
    tab,
    payload: {
      type: "request",
      side: "server",
      protocol,
      method,
      url,
      route,
      headers,
      body,
    },
  }),
  // bundle //
  [BEGIN_BUNDLE_EVENT]: (session, group, [_head, tab, time]) => ({
    type: "event",
    site: "begin",
    session,
    group,
    tab,
    time,
    payload: BUNDLE_PAYLOAD,
  }),
  [END_BUNDLE_EVENT]: (session, group, [_head, tab, time]) => ({
    type: "event",
    site: "end",
    session,
    group,
    tab,
    time,
    payload: BUNDLE_PAYLOAD,
  }),
  // jump //
  [BEFORE_JUMP_EVENT]: (session, group, [_head, tab, time]) => ({
    type: "event",
    site: "before",
    session,
    group,
    tab,
    time,
    payload: JUMP_PAYLOAD,
  }),
  [AFTER_JUMP_EVENT]: (session, group, [_head, tab, time]) => ({
    type: "event",
    site: "after",
    session,
    group,
    tab,
    time,
    payload: JUMP_PAYLOAD,
  }),
  // apply //
  [BEGIN_APPLY_EVENT]: (
    session,
    group,
    [_head, tab, time, function_, this_, arguments_],
  ) => ({
    type: "event",
    site: "begin",
    session,
    group,
    tab,
    time,
    payload: {
      type: "apply",
      function: function_,
      this: this_,
      arguments: arguments_,
    },
  }),
  [END_RETURN_EVENT]: (
    session,
    group,
    [_head, tab, time, function_, result],
  ) => ({
    type: "event",
    site: "end",
    session,
    group,
    tab,
    time,
    payload: {
      type: "return",
      function: function_,
      result,
    },
  }),
  [END_THROW_EVENT]: (
    session,
    group,
    [_head, tab, time, function_, error],
  ) => ({
    type: "event",
    site: "end",
    session,
    group,
    tab,
    time,
    payload: {
      type: "throw",
      function: function_,
      error,
    },
  }),
  // await/yield //
  [BEFORE_AWAIT_EVENT]: (session, group, [_head, tab, time, promise]) => ({
    type: "event",
    site: "before",
    session,
    group,
    tab,
    time,
    payload: {
      type: "await",
      promise,
    },
  }),
  [BEFORE_YIELD_EVENT]: (session, group, [_head, tab, time, iterator]) => ({
    type: "event",
    site: "before",
    session,
    group,
    tab,
    time,
    payload: {
      type: "yield",
      iterator,
    },
  }),
  [AFTER_RESOLVE_EVENT]: (session, group, [_head, tab, time, result]) => ({
    type: "event",
    site: "after",
    session,
    group,
    tab,
    time,
    payload: {
      type: "resolve",
      result,
    },
  }),
  [AFTER_REJECT_EVENT]: (session, group, [_head, tab, time, error]) => ({
    type: "event",
    site: "after",
    session,
    group,
    tab,
    time,
    payload: {
      type: "reject",
      error,
    },
  }),
  // http-server //
  [BEGIN_REQUEST_EVENT]: (
    session,
    group,
    [_head, tab, time, protocol, method, url, route, headers, body],
  ) => ({
    type: "event",
    site: "begin",
    session,
    group,
    tab,
    time,
    payload: {
      type: "request",
      side: "server",
      protocol,
      method,
      url,
      route,
      headers,
      body,
    },
  }),
  [END_RESPONSE_EVENT]: (
    session,
    group,
    [_head, tab, time, status, message, headers, body],
  ) => ({
    type: "event",
    site: "end",
    session,
    group,
    tab,
    time,
    payload: {
      type: "response",
      side: "server",
      status,
      message,
      headers,
      body,
    },
  }),
  // http-client //
  [BEFORE_REQUEST_EVENT]: (
    session,
    group,
    [_head, tab, time, protocol, method, url, route, headers, body],
  ) => ({
    type: "event",
    site: "before",
    session,
    group,
    tab,
    time,
    payload: {
      type: "request",
      side: "client",
      protocol,
      method,
      url,
      route,
      headers,
      body,
    },
  }),
  [AFTER_RESPONSE_EVENT]: (
    session,
    group,
    [_head, tab, time, status, message, headers, body],
  ) => ({
    type: "event",
    site: "after",
    session,
    group,
    tab,
    time,
    payload: {
      type: "response",
      side: "client",
      status,
      message,
      headers,
      body,
    },
  }),
  // query //
  [BEFORE_QUERY_EVENT]: (
    session,
    group,
    [_head, tab, time, database, version, sql, parameters],
  ) => ({
    type: "event",
    site: "before",
    session,
    group,
    tab,
    time,
    payload: {
      type: "query",
      database,
      version,
      sql,
      parameters,
    },
  }),
  [AFTER_ANSWER_EVENT]: (session, group, [_head, tab, time]) => ({
    type: "event",
    site: "after",
    session,
    group,
    tab,
    time,
    payload: { type: "answer" },
  }),
};

const inflate = (lines) => {
  let group = null;
  let session = null;
  const messages = [];
  for (const tokens of lines) {
    const head = tokens[0];
    if (head === SESSION_ASSIGNMENT) {
      session = tokens[1];
    } else if (head === GROUP_ASSIGNMENT) {
      group = tokens[1];
    } else {
      messages.push(inflaters[head](session, group, tokens));
    }
  }
  return messages;
};

const {
  Array: { isArray: isArray$2, from: toArray$5 },
  Object: { fromEntries: fromEntries$1, entries: toEntries$2 },
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const serialize = (serialization, enabled, value) => {
  enabled.value = false;
  try {
    return serialize$1(serialization, value);
  } finally {
    enabled.value = true;
  }
};

const updateGroup = (buffer, old_group, new_group) => {
  if (old_group.value !== new_group) {
    buffer.push([GROUP_ASSIGNMENT, new_group]);
    old_group.value = new_group;
  }
};

const initializeBuffer = (buffer, session, { value: group }) => {
  buffer.push([SESSION_ASSIGNMENT, session], [GROUP_ASSIGNMENT, group]);
};

const createFrontend = (configuration) => {
  const { session } = configuration;
  assert(session !== null, "missing session", InternalAppmapError);
  const buffer = [];
  initializeBuffer(buffer, session, { value: 0 });
  return {
    enabled: { value: true },
    buffer,
    counter: createCounter(0),
    session,
    old_group: { value: 0 },
    serialization: createSerialization(configuration),
    configuration,
  };
};

/* c8 ignore start */
const flushMessageArray = ({ buffer, session, old_group }) => {
  if (buffer.length === 2) {
    return [];
  } else {
    const messages = inflate(buffer);
    buffer.length = 0;
    initializeBuffer(buffer, session, old_group);
    return messages;
  }
};
/* c8 ignore stop */

const getFreshTab = ({ counter }) => incrementCounter(counter);

const getSerializationEmptyValue = ({ serialization }) =>
  getSerializationEmptyValue$1(serialization);

const instrument = (
  { enabled, buffer, configuration },
  url,
  content,
  readFile,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } = instrumentInject(
      url,
      content,
      configuration,
      readFile,
    );
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const instrumentAsync = async (
  { enabled, buffer, configuration },
  url,
  content,
  readFileAsync,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } =
      await instrumentInjectAsync(url, content, configuration, readFileAsync);
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const recordError = ({ enabled, buffer, serialization }, error) => {
  if (enabled.value) {
    buffer.push([ERROR, serialize(serialization, enabled, error)]);
  }
};

const recordStartTrack = ({ enabled, buffer }, track, configuration) => {
  if (enabled.value) {
    buffer.push([START, track, configuration]);
  }
};

const recordStopTrack = ({ enabled, buffer }, track, termination) => {
  if (enabled.value) {
    buffer.push([STOP, track, termination]);
  }
};

const recordGroup = ({ enabled, buffer }, group, child, description) => {
  if (enabled.value) {
    buffer.push([GROUP_DEFINITION, group, child, description]);
  }
};

// jump && bundle //

const compileRecordEmpty =
  (head) =>
  ({ enabled, buffer, old_group }, tab, group, time) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([head, tab, time]);
    }
  };

const recordBeforeJumpEvent = compileRecordEmpty(BEFORE_JUMP_EVENT);

const recordAfterJumpEvent = compileRecordEmpty(AFTER_JUMP_EVENT);

const recordBeginBundleEvent = compileRecordEmpty(BEGIN_BUNDLE_EVENT);

const recordEndBundleEvent = compileRecordEmpty(END_BUNDLE_EVENT);

// function //

const recordBeginApplyEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  this_,
  arguments_,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEGIN_APPLY_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, this_),
      arguments_.map((argument) => serialize(serialization, enabled, argument)),
    ]);
  }
};

const recordEndReturnEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_RETURN_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordEndThrowEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_THROW_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, error),
    ]);
  }
};

// promise && iterator //

const recordBeforeAwaitEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  promise,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_AWAIT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, promise),
    ]);
  }
};

const recordBeforeYieldEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  iterator,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_YIELD_EVENT,
      tab,
      time,
      serialize(serialization, enabled, iterator),
    ]);
  }
};

const recordAfterResolveEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_RESOLVE_EVENT,
      tab,
      time,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordAfterRejectEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_REJECT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, error),
    ]);
  }
};

// client && server //

const compileRecordRequest =
  (head) =>
  (
    { enabled, buffer, serialization, old_group },
    tab,
    group,
    time,
    protocol,
    method,
    url,
    route,
    headers,
    body,
  ) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([
        head,
        tab,
        time,
        protocol,
        method,
        url,
        route,
        headers,
        serialize(serialization, enabled, body),
      ]);
    }
  };

const compileRecordResponse =
  (head) =>
  (
    { enabled, buffer, serialization, old_group },
    tab,
    group,
    time,
    status,
    message,
    headers,
    body,
  ) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([
        head,
        tab,
        time,
        status,
        message,
        headers,
        serialize(serialization, enabled, body),
      ]);
    }
  };

const recordBeforeRequestEvent =
  compileRecordRequest(BEFORE_REQUEST_EVENT);

const recordAfterResponseEvent =
  compileRecordResponse(AFTER_RESPONSE_EVENT);

const recordBeginRequestEvent =
  compileRecordRequest(BEGIN_REQUEST_EVENT);

const recordBeginRequestAmend = (
  { enabled, buffer, serialization },
  tab,
  protocol,
  method,
  url,
  route,
  headers,
  body,
) => {
  if (enabled.value) {
    buffer.push([
      BEGIN_REQUEST_AMEND,
      tab,
      protocol,
      method,
      url,
      route,
      headers,
      serialize(serialization, enabled, body),
    ]);
  }
};

const recordEndResponseEvent = compileRecordResponse(END_RESPONSE_EVENT);

// database //

const recordBeforeQueryEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  database,
  version,
  sql,
  parameters,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_QUERY_EVENT,
      tab,
      time,
      database,
      version,
      sql,
      isArray$2(parameters)
        ? parameters.map((parameter) =>
            serialize(serialization, enabled, parameter),
          )
        : fromEntries$1(
            toArray$5(toEntries$2(parameters)).map(([name, parameter]) => [
              name,
              serialize(serialization, enabled, parameter),
            ]),
          ),
    ]);
  }
};

const recordAfterAnswerEvent = compileRecordEmpty(AFTER_ANSWER_EVENT);

const unhook$e = (backup) => {
  backup.forEach(assignProperty);
};

const hook$e = (frontend, { hooks: { apply: apply_hook_variable } }) => {
  if (apply_hook_variable === null) {
    return [];
  } else {
    const runtime = {
      empty: getSerializationEmptyValue(frontend),
      getFreshTab: () => getFreshTab(frontend),
      recordApply: (tab, function_, this_, arguments_) => {
        recordBeginApplyEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          function_,
          this_,
          arguments_,
        );
      },
      recordReturn: (tab, function_, result) => {
        recordEndReturnEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          function_,
          result,
        );
      },
      recordThrow: (tab, function_, error) => {
        recordEndThrowEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          function_,
          error,
        );
      },
      recordAwait: (tab, promise) => {
        recordBeforeAwaitEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          promise,
        );
      },
      recordYield: (tab, iterator) => {
        recordBeforeYieldEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          iterator,
        );
      },
      recordResolve: (tab, result) => {
        recordAfterResolveEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          result,
        );
      },
      recordReject: (tab, error) => {
        recordAfterRejectEvent(frontend, tab, executionAsyncId(), now(), error);
      },
    };
    assert(
      defineGlobal(apply_hook_variable, runtime),
      "global apply hook variable already defined",
      InternalAppmapError,
    );
    return [
      "getFreshTab",
      "recordApply",
      "recordReturn",
      "recordThrow",
      "recordAwait",
      "recordResolve",
      "recordReject",
      "recordYield",
    ].map((key) => ({
      object: runtime,
      key,
      value: noop,
    }));
  }
};

var HookApply = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$e,
  hook: hook$e
});

const {
  Set: Set$4,
  Number: { isInteger, MAX_SAFE_INTEGER },
} = globalThis;

// NB: current execution id when called from C++ is 0
const isGroup = (group) =>
  isInteger(group) && group >= 0 && group < MAX_SAFE_INTEGER;

const hook$d = (frontend, { ordering }) => {
  if (ordering !== "causal") {
    return null;
  } else {
    const groups = new Set$4();
    const hook = createHook({
      init: (id, description, origin) => {
        if (isGroup(id) && isGroup(origin)) {
          // In the presence of a debugger, the init hook may be called multiple times for the same asyncId.
          // However, the asyncId is guaranteed to be unique so we should be able to safely ignore it if it's
          // already been seen.
          if (!groups.has(id)) {
            groups.add(id);
            recordGroup(frontend, origin, id, toString(description));
          }
        } /* c8 ignore start */ else {
          logWarning("Invalid group id for id = %o or origin = %o", id, origin);
        } /* c8 ignore stop */
      },
    });
    hook.enable();
    return hook;
  }
};

const unhook$d = (hook) => {
  if (hook !== null) {
    hook.disable();
  }
};

var HookGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$d,
  unhook: unhook$d
});

const { Error: Error$1, decodeURIComponent, URL: URL$2 } = globalThis;

const { from: toBuffer$3 } = Buffer$1;

const splitDataPath = (path) => {
  const index = path.indexOf(",");
  return {
    head: path.substring(0, index),
    body: path.substring(index + 1),
  };
};

const generateReadFile = (readFile) => (url) => {
  const url_obj = new URL$2(url);
  if (url_obj.protocol === "file:") {
    return readFile(url_obj, "utf8");
  } else if (url_obj.protocol === "data:") {
    const { head, body } = splitDataPath(url_obj.pathname);
    if (head.endsWith(";base64")) {
      logDebugWhen(
        !head.toLowerCase().includes(";charset=utf-8;") &&
          !head.toLowerCase().includes(";charset=utf8;"),
        "Data url is encoded as base64 and does not declare UTF-8 as its character encoding, will try to use UTF-8 anyway >> %s",
        url,
      );
      return toBuffer$3(body, "base64").toString("utf8");
    } else {
      return decodeURIComponent(body);
    }
  } else {
    // This file is meant to be used at the same
    //   abstraction level as a node library.
    // Hence, this is delibearately left as an unknown error.
    // ie: not an External/Internal AppmapError.
    throw new Error$1("unsupported protocol");
  }
};

const readFile$1 = generateReadFile(readFileSync);

const readFileAsync = generateReadFile(readFile$2);

const {
  Reflect: { apply: apply$6 },
} = globalThis;

const { prototype } = Module;

const unhook$c = (backup) => {
  backup.forEach(assignProperty);
};

const hook$c = (frontend, { hooks: { cjs } }) => {
  if (!cjs) {
    return [];
  } else {
    const { _compile: original } = prototype;
    prototype._compile = function _compile(content, path) {
      return apply$6(original, this, [
        instrument(
          frontend,
          convertPathToFileUrl(toString(path)),
          content,
          readFile$1,
        ),
        path,
      ]);
    };
    return [{ object: prototype, key: "_compile", value: original }];
  }
};

const {
  Buffer,
  Buffer: { from: toBuffer$2 },
  ArrayBuffer,
  SharedArrayBuffer,
  Uint8Array,
} = globalThis;

const stringifyContent = (content) => {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof Uint8Array) {
    content = content.buffer;
  }
  if (content instanceof SharedArrayBuffer || content instanceof ArrayBuffer) {
    content = toBuffer$2(content);
  }
  if (content instanceof Buffer) {
    // We assume utf8 encoding as node does:
    // https://github.com/nodejs/node/blob/c200106305f4367ba9ad8987af5139979c6cc40c/lib/internal/modules/cjs/loader.js#L1136
    //
    // Module._extensions['.js'] = function(module, filename) {
    //   // If already analyzed the source, then it will be cached.
    //   const cached = cjsParseCache.get(module);
    //   let content;
    //   if (cached?.source) {
    //     content = cached.source;
    //     cached.source = undefined;
    //   } else {
    //     content = fs.readFileSync(filename, 'utf8');
    //   }
    return content.toString("utf8");
  } else {
    logError(
      "Expected module content to be either: a string, a UintArray, a ArrayBuffer, a SharedArrayBuffer, or a Buffer. Got: %o",
      content,
    );
    throw new ExternalAppmapError("Invalid module content");
  }
};

/* eslint-disable no-import-assign */

let hooked = false;

const unhook$b = (esm) => {
  if (esm) {
    assert(hooked, "esm not yet hooked", InternalAppmapError);
    hooks.load = loadDefault;
    hooks.transformSourceDefault = transformSourceDefault;
    hooked = false;
  }
};

const hook$b = (frontend, { hooks: { esm } }) => {
  if (esm) {
    assert(!hooked, "esm already hooked", InternalAppmapError);
    hooked = esm;
    const transformModuleAsync = async (url, format, content) => {
      // We do not want to intrument commonjs here
      // because cjs has its own hook mechanism.
      if (format === "module") {
        return await instrumentAsync(
          frontend,
          url,
          stringifyContent(content),
          readFileAsync,
        );
      } else {
        return content;
      }
    };
    hooks.load = async (url, context, nextAsync) => {
      const { format, source } = await nextAsync(url, context, nextAsync);
      return {
        format,
        source: await transformModuleAsync(url, format, source),
      };
    };
    hooks.transformSource = async (content, context, nextAsync) => {
      const { format, url } = context;
      const { source } = await nextAsync(content, context, nextAsync);
      return {
        source: await transformModuleAsync(url, format, source),
      };
    };
  }
  return esm;
};

const unhook$a = (backup) => {
  if (backup !== null) {
    unhook$c(backup.cjs);
    unhook$b(backup.esm);
  }
};

const hook$a = (frontend, configuration) => {
  if (configuration.recorder === "jest") {
    return null;
  } else {
    return {
      cjs: hook$c(frontend, configuration),
      esm: hook$b(frontend, configuration),
    };
  }
};

var HookModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$a,
  hook: hook$a
});

// TODO: detect if preloaded with `--experimental-loader`

const forward = (_url, _location, content) => content;

const unhook$9 = (maybe_hidden) => {
  if (maybe_hidden !== null) {
    writeGlobal(maybe_hidden, forward);
  }
};

const hook$9 = (
  frontend,
  {
    hooks: {
      eval: { hidden, aliases },
    },
  },
) => {
  const enabled = aliases.length > 0;
  if (enabled) {
    assert(
      defineGlobal(
        hidden,
        (url, position, content) =>
          instrument(
            frontend,
            toAbsoluteUrl(`eval-${position}.js`, toDirectoryUrl(url)),
            toString(content),
            readFile$1,
          ),
        true,
      ),
      "global eval hook variable already defined",
      InternalAppmapError,
    );
  }
  return enabled ? hidden : null;
};

var HookEval = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$9,
  hook: hook$9
});

const hook$8 = (frontend, _configuration) => {
  const listener = (error) => {
    recordError(frontend, error);
  };
  process.addListener("uncaughtExceptionMonitor", listener);
  return listener;
};

const unhook$8 = (listener) => {
  process.removeListener("uncaughtExceptionMonitor", listener);
};

var HookError = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$8,
  unhook: unhook$8
});

const {
  Number: { isNaN },
} = globalThis;

const toStatus = (any) => {
  const integer = toInteger(any);
  if (isNaN(integer) || integer < 0 || integer > 255) {
    return 1;
  } else {
    return integer;
  }
};

const hook$7 = (frontend, _configuration) => {
  const listener = (status) => {
    recordStopTrack(frontend, null, {
      type: "exit",
      status: toStatus(status),
    });
  };
  process.addListener("beforeExit", listener);
  process.addListener("exit", listener);
  return listener;
};

const unhook$7 = (listener) => {
  process.removeListener("beforeExit", listener);
  process.removeListener("exit", listener);
};

var HookExit = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$7,
  unhook: unhook$7
});

const { URL: URL$1 } = globalThis;

const requirePeerDependency = (specifier, { directory, strict }) => {
  const require = createRequire(new URL$1(directory));
  try {
    return require(specifier);
  } catch (error) {
    if (strict) {
      logError(
        "Could not load peer dependency %j from %j >> %O",
        specifier,
        directory,
        error,
      );
      throw new ExternalAppmapError("Could not load peer dependency");
    } else {
      logDebug(
        "Could not load peer dependency %j from %j >> %O",
        specifier,
        directory,
        error,
      );
      return null;
    }
  }
};

const {
  Set: Set$3,
  Map: Map$6,
  Array: { isArray: isArray$1, from: toArray$4 },
  Object: toObject,
  Object: { entries: toEntryArray, fromEntries: fromEntryArray },
} = globalThis;

const isStringEntry = ([key]) => typeof key === "string";

const toParameterCollection = (parameters) => {
  if (parameters instanceof Set$3) {
    return toArray$4(parameters.values());
  } else if (parameters instanceof Map$6) {
    return fromEntryArray(toArray$4(parameters.entries()).filter(isStringEntry));
  } else if (isArray$1(parameters)) {
    return toArray$4(parameters);
  } else {
    return fromEntryArray(toEntryArray(toObject(parameters)));
  }
};

/* c8 ignore start */

const {
  Reflect: { apply: apply$5 },
} = globalThis;

const DATABASE$2 = "mysql";
const VERSION$3 = null;

const unhook$6 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$6 = (
  frontend,
  { repository: { directory }, hooks: { mysql } },
) => {
  if (mysql === false) {
    return [];
  } else {
    const Mysql = requirePeerDependency("mysql", {
      directory,
      strict: mysql === true,
    });
    if (Mysql === null) {
      return [];
    } else {
      const { createConnection, createQuery } = Mysql;
      const { __proto__: prototype } = createConnection({});
      const { query: original } = prototype;
      prototype.query = function query(sql, values, callback) {
        const query = createQuery(sql, values, callback);
        const bundle_tab = getFreshTab(frontend);
        const jump_tab = getFreshTab(frontend);
        recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        recordBeforeQueryEvent(
          frontend,
          jump_tab,
          executionAsyncId(),
          now(),
          DATABASE$2,
          VERSION$3,
          toString(query.sql),
          toParameterCollection(query.values),
        );
        const { _callback: query_callback } = query;
        query._callback = spyOnce((_error, _result, _field) => {
          recordAfterAnswerEvent(frontend, jump_tab, executionAsyncId(), now());
          recordEndBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        }, query_callback);
        return apply$5(original, this, [query]);
      };
      return [{ object: prototype, key: "query", value: original }];
    }
  }
};

/* c8 ignore start */

const {
  undefined: undefined$6,
  Reflect: { apply: apply$4 },
  Promise: Promise$2,
  TypeError: TypeError$1,
} = globalThis;

const VERSION$2 = null;
const DATABASE$1 = "postgres";

const unhook$5 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$5 = (
  frontend,
  { repository: { directory }, hooks: { pg } },
) => {
  if (pg === false) {
    return [];
  } else {
    const Postgres = requirePeerDependency("pg", {
      directory,
      strict: pg === true,
    });
    if (Postgres === null) {
      return [];
    } else {
      const { Client, Query } = Postgres;
      const { prototype } = Client;
      const { query: original } = prototype;
      const { query } = {
        // We use the method syntax to create a function that is not constructor.
        query(query, values, callback) {
          if (query === null || query === undefined$6) {
            throw new TypeError$1("Client was passed a null or undefined query");
          }
          let result = undefined$6;
          if (typeof query.submit === "function") {
            result = query;
            if (!query.callback) {
              if (typeof values === "function") {
                query.callback = values;
              } else {
                query.callback = (error, _result) => {
                  if (error !== null) {
                    query.emit("error", error);
                  }
                };
              }
            }
          } else {
            query = new Query(query, values, callback);
            if (!query.callback) {
              result = new Promise$2((resolve, reject) => {
                query.callback = (error, result) => {
                  error ? reject(error) : resolve(result);
                };
              });
            }
          }
          const bundle_tab = getFreshTab(frontend);
          const jump_tab = getFreshTab(frontend);
          recordBeginBundleEvent(
            frontend,
            bundle_tab,
            executionAsyncId(),
            now(),
          );
          recordBeforeQueryEvent(
            frontend,
            jump_tab,
            executionAsyncId(),
            now(),
            DATABASE$1,
            VERSION$2,
            toString(query.text),
            toParameterCollection(query.values),
          );
          const { callback: query_callback } = query;
          query.callback = spyOnce((_error, _result) => {
            recordAfterAnswerEvent(
              frontend,
              jump_tab,
              executionAsyncId(),
              now(),
            );
            recordEndBundleEvent(
              frontend,
              bundle_tab,
              executionAsyncId(),
              now(),
            );
          }, query_callback);
          apply$4(original, this, [query]);
          return result;
        },
      };
      prototype.query = query;
      return [{ object: prototype, key: "query", value: original }];
    }
  }
};

const {
  Array: { isArray },
  Object: { assign },
  Reflect: { apply: apply$3 },
  TypeError,
} = globalThis;

const throwIfNotNull = (error) => {
  /* c8 ignore start */
  if (error !== null) {
    throw error;
  }
  /* c8 ignore stop */
};

const DATABASE = "sqlite3";
const VERSION$1 = null;

const extractEach = (args) => {
  let each = throwIfNotNull;
  if (args.length > 0 && typeof args[args.length - 1] === "function") {
    if (args.length > 1 && typeof args[args.length - 2] === "function") {
      each = args[args.length - 2];
      args[args.length - 2] = args[args.length - 1];
    } else {
      each = args[args.length - 1];
    }
    args.length -= 1;
  }
  return each;
};

const normalizeStatementArguments = (args) => {
  if (args.length === 0 || typeof args[args.length - 1] !== "function") {
    args[args.length] = throwIfNotNull;
  }
  if (args.length === 1) {
    args = [[], args[0]];
  } else if (args.length > 2) {
    const parameters = [];
    for (let index = 0; index < args.length - 1; index += 1) {
      parameters[parameters.length] = args[index];
    }
    args = [parameters, args[args.length - 1]];
  }
  let [parameters, callback] = args;
  if (typeof parameters !== "object" || parameters === null) {
    parameters = [parameters];
  }
  return {
    parameters,
    callback,
  };
};

const normalizeDatabaseArguments = (args) => {
  if (args.length === 0) {
    throw new TypeError("missing sql query string");
  }
  const sql = args[0];
  if (typeof sql !== "string") {
    throw new TypeError("first argument is expected to be a sql query string");
  }
  for (let index = 1; index < args.length; index += 1) {
    args[index - 1] = args[index];
  }
  args.length -= 1;
  const { parameters, callback } = normalizeStatementArguments(args);
  return { sql, parameters, callback };
};

const combine = (parameters1, parameters2) => {
  if (isArray(parameters1) && parameters1.length === 0) {
    return parameters2;
  }
  if (isArray(parameters2) && parameters2.length === 0) {
    return parameters1;
  }
  if (isArray(parameters1) && isArray(parameters2)) {
    return [...parameters1, ...parameters2];
  }
  return { ...parameters1, ...parameters2 };
};

const unhook$4 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$4 = (
  frontend,
  { repository: { directory }, hooks: { sqlite3 } },
) => {
  if (sqlite3 === false) {
    return [];
  } else {
    const Sqlite3 = requirePeerDependency("sqlite3", {
      directory,
      strict: sqlite3 === true,
    });
    /* c8 ignore start */ if (Sqlite3 === null) {
      return [];
    } /* c8 ignore stop */ else {
      const { Database } = Sqlite3;
      const { prototype: database_prototype } = Database;
      const backup = ["run", "get", "all", "each", "prepare"].map((key) => ({
        object: database_prototype,
        key,
        value: database_prototype[key],
      }));
      const copy = { ...database_prototype };
      const recordQuery = (sql, parameters, callback) => {
        const bundle_tab = getFreshTab(frontend);
        const jump_tab = getFreshTab(frontend);
        recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        recordBeforeQueryEvent(
          frontend,
          jump_tab,
          executionAsyncId(),
          now(),
          DATABASE,
          VERSION$1,
          toString(sql),
          toParameterCollection(parameters),
        );
        return spyOnce(() => {
          recordAfterAnswerEvent(frontend, jump_tab, executionAsyncId(), now());
          recordEndBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        }, callback);
      };
      /////////////////////////////////
      // Direct Database method call //
      /////////////////////////////////
      database_prototype.each = function each(...args) {
        const each = extractEach(args);
        const { sql, parameters, callback } = normalizeDatabaseArguments(args);
        return apply$3(copy.each, this, [
          sql,
          parameters,
          each,
          recordQuery(sql, parameters, callback),
        ]);
      };
      for (const key of ["run", "all", "get"]) {
        database_prototype[key] = function (...args) {
          const { sql, parameters, callback } =
            normalizeDatabaseArguments(args);
          return apply$3(copy[key], this, [
            sql,
            parameters,
            recordQuery(sql, parameters, callback),
          ]);
        };
      }
      // Database.prototype.exec is immutable :(
      // database_prototype.exec = function exec (...args) {
      //   const {sql, callback} = normalizeDatabaseArguments(args);
      //   return apply(
      //     save.exec,
      //     this,
      //     [sql, recordQuery(sql, null, callback)]
      //   );
      // }
      ////////////////////////
      // Prepared Statement //
      ////////////////////////
      // NB: Statement.prototype is largely immutable, that is why we need
      // to perform object composition instead of simple prototype assignments.
      function Statement(database, sql, parameters, callback) {
        const statement = apply$3(copy.prepare, database, [sql, callback]);
        statement._appmap_statement = this;
        this._appmap_statement = statement;
        this._appmap_sql = sql;
        this._appmap_parameters = parameters;
      }
      const { prototype: statement_prototype } = Statement;
      assign(statement_prototype, {
        run: null,
        all: null,
        get: null,
        each: function each(...args) {
          const each = extractEach(args);
          let { parameters, callback } = normalizeStatementArguments(args);
          parameters = combine(this._appmap_parameters, parameters);
          this._appmap_statement.each(
            parameters,
            each,
            recordQuery(this._appmap_sql, parameters, callback),
          );
          return this;
        },
        bind: function bind(...args) {
          const { parameters, callback } = normalizeStatementArguments(args);
          this._appmap_parameters = parameters;
          this._appmap_statement.reset(callback);
          return this;
        },
        reset: function reset(callback) {
          this._appmap_statement.reset(callback);
          return this;
        },
        finalize: function finalize(callback) {
          this._appmap_statement.finalize(callback);
          return this;
        },
      });
      for (const key of ["run", "all", "get"]) {
        statement_prototype[key] = function (...args) {
          let { parameters, callback } = normalizeStatementArguments(args);
          parameters = combine(this._appmap_parameters, parameters);
          this._appmap_statement[key](
            parameters,
            recordQuery(this._appmap_sql, parameters, callback),
          );
          return this;
        };
      }
      database_prototype.prepare = function (...args) {
        const { sql, parameters, callback } = normalizeDatabaseArguments(args);
        return new Statement(this, sql, parameters, callback);
      };
      return backup;
    }
  }
};

const hook$3 = (frontend, socket, configuration) => ({
  mysql: hook$6(frontend, socket),
  pg: hook$5(frontend, socket),
  sqlite3: hook$4(frontend, socket),
});

const unhook$3 = ({ mysql, pg, sqlite3 }) => {
  unhook$6(mysql);
  unhook$5(pg);
  unhook$4(sqlite3);
};

var HookQuery = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$3,
  unhook: unhook$3
});

const {
  Reflect: { getPrototypeOf, defineProperty, getOwnPropertyDescriptor },
  undefined: undefined$5,
} = globalThis;

const patch = (object, key, makePatch) => {
  if (hasOwnProperty(object, key)) {
    const descriptor = getOwnPropertyDescriptor(object, key);
    assert(
      !logErrorWhen(
        !hasOwnProperty(descriptor, "value"),
        "Cannot monkey-patch accessor property %j of object %o",
        key,
        object,
      ),
      "Cannot monkey-patch accessor property",
      ExternalAppmapError,
    );
    assert(
      !logErrorWhen(
        !descriptor.configurable && !descriptor.writable,
        "Cannot monkey-patch constant data property %j of object %o",
        key,
        object,
      ),
      "Cannot monkey-patch constant data property",
      ExternalAppmapError,
    );
    defineProperty(object, key, {
      __proto__: descriptor,
      value: makePatch(descriptor.value),
    });
  } else {
    let prototype = getPrototypeOf(object);
    let existing_value = undefined$5;
    while (prototype !== null) {
      if (hasOwnProperty(prototype, key)) {
        const descriptor = getOwnPropertyDescriptor(prototype, key);
        assert(
          !logErrorWhen(
            !hasOwnProperty(descriptor, "value"),
            "Cannot monkey-patch accessor property %j of prototype %o",
            key,
            prototype,
          ),
          "Cannot monkey-patch accessor property on prototype",
          ExternalAppmapError,
        );
        existing_value = descriptor.value;
        prototype = null;
      } else {
        prototype = getPrototypeOf(prototype);
      }
    }
    defineProperty(object, key, {
      __proto__: null,
      writable: true,
      enumerable: false,
      value: makePatch(existing_value),
      configurable: true,
    });
  }
};

const {
  Buffer: { from: toBuffer$1, concat: concatBuffer$1 },
  Object: { fromEntries, entries: toEntries$1 },
  TextDecoder,
  Reflect: { apply: apply$2 },
  JSON: { parse: parseJSON$1 },
  Math: { round: round$1 },
  undefined: undefined$4,
} = globalThis;

const normalizeChunk = (chunk, encoding) =>
  typeof chunk === "string" ? toBuffer$1(chunk, encoding) : chunk;

const spyReadable = (readable, callback) => {
  const buffers = [];
  patch(
    readable,
    "push",
    (original_push) =>
      function (chunk, encoding) {
        if (chunk === null) {
          callback(concatBuffer$1(buffers));
        } else {
          buffers.push(normalizeChunk(chunk, encoding));
        }
        return apply$2(original_push, this, [chunk, encoding]);
      },
  );
};

const spyWritable = (writable, callback1) => {
  const buffers = [];
  patch(
    writable,
    "write",
    (original_write) =>
      function (chunk, encoding, callback2) {
        buffers.push(normalizeChunk(chunk, encoding));
        return apply$2(original_write, this, [chunk, encoding, callback2]);
      },
  );
  patch(
    writable,
    "end",
    (original_end) =>
      function (chunk, encoding, callback2) {
        if (chunk !== null && chunk !== undefined$4) {
          buffers.push(normalizeChunk(chunk, encoding));
        }
        callback1(concatBuffer$1(buffers));
        return apply$2(original_end, this, [chunk, encoding, callback2]);
      },
  );
};

const parseJSONSafe = (string, recovery) => {
  try {
    return parseJSON$1(string);
  } catch (error) {
    logWarning("Could not parse as JSON %j >> %O", string, error);
    return recovery;
  }
};

const decodeSafe = (buffer, encoding, recovery) => {
  try {
    return new TextDecoder(encoding).decode(buffer);
  } catch (error) {
    logWarning("Could not decode as %j buffer >> %O", encoding, error);
    return recovery;
  }
};

const parseContentTypeHead = (head) => {
  const parts = /^ *([a-zA-Z-]+) *\/ *([a-zA-Z-]+) *$/u.exec(head);
  if (parts === null) {
    logWarning("Could not parse content-type head %j", head);
    return { type: "text", subtype: "plain" };
  } else {
    return { type: parts[1], subtype: parts[2] };
  }
};

const parseContentTypeParameter = (parameter) => {
  const parts = /^ *([a-zA-Z0-9-]+) *= *([a-zA-Z0-9-]+) *$/u.exec(parameter);
  if (parts === null) {
    logWarning("Could not parse content-type parameter %j", parameter);
    return [];
  } else {
    return [[parts[1], parts[2]]];
  }
};

const parseContentType = (content_type) => {
  const segments = content_type.toLowerCase().split(";");
  const { type, subtype } = parseContentTypeHead(segments.shift());
  return {
    type,
    subtype,
    parameters: fromEntries(segments.flatMap(parseContentTypeParameter)),
  };
};

const isStringKeyEntry = ({ 0: key }) => typeof key === "string";

const toStringValueEntry = ({ 0: key, 1: value }) => [key, toString(value)];

const formatHeaders = (headers) =>
  fromEntries(
    toEntries$1(headers).filter(isStringKeyEntry).map(toStringValueEntry),
  );

const replacements = {
  NaN: 0,
  NEGATIVE_INFINITY: 0,
  POSITIVE_INFINITY: 0,
};

const formatStatus = (any) =>
  round$1(jsonifyNumber(toNumber(any), replacements));

const {
  Reflect: { apply: apply$1, construct: construct$1 },
  Proxy: Proxy$1,
} = globalThis;

const unhook$2 = (backup) => backup.forEach(assignProperty);

const hook$2 = (frontend, { hooks: { http } }) => {
  if (!http) {
    return [];
  } else {
    const empty = getSerializationEmptyValue(frontend);
    const backup = [
      ...["ClientRequest", "request", "get"].map((key) => ({
        object: Http,
        key,
      })),
      ...["request", "get"].map((key) => ({ object: Https, key })),
    ].map(({ object, key }) => ({ object, key, value: object[key] }));
    const spyRequest = (request) => {
      const bundle_tab = getFreshTab(frontend);
      const jump_tab = getFreshTab(frontend);
      recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
      recordBeforeRequestEvent(
        frontend,
        jump_tab,
        executionAsyncId(),
        now(),
        "HTTP/1.1",
        toString(request.method),
        toString(request.path),
        null,
        formatHeaders(request.getHeaders()),
        empty,
      );
      request.on("response", (response) => {
        const {
          headers,
          statusCode: status,
          statusMessage: message,
        } = response;
        let body = empty;
        const { type, subtype, parameters } = parseContentType(
          getOwnProperty(headers, "content-type", "text/plain"),
        );
        const compression = getOwnProperty(
          headers,
          "content-encoding",
          "identity",
        );
        if (
          type === "application" &&
          subtype === "json" &&
          compression === "identity"
        ) {
          spyReadable(response, (buffer) => {
            const maybe = decodeSafe(
              buffer,
              getOwnProperty(parameters, "charset", "utf-8"),
              null,
            );
            if (maybe !== null) {
              body = parseJSONSafe(maybe, empty);
            }
          });
        }
        response.once(
          "end",
          spyOnce(() => {
            recordAfterResponseEvent(
              frontend,
              jump_tab,
              executionAsyncId(),
              now(),
              formatStatus(status),
              toString(message),
              formatHeaders(headers),
              body,
            );
            recordEndBundleEvent(
              frontend,
              bundle_tab,
              executionAsyncId(),
              now(),
            );
          }, identity),
        );
      });
    };
    const traps = {
      __proto__: null,
      apply: (target, context, values) => {
        const request = apply$1(target, context, values);
        spyRequest(request);
        return request;
      },
      construct: (target, values, newtarget) => {
        const request = construct$1(target, values, newtarget);
        spyRequest(request);
        return request;
      },
    };
    for (const { object, key, value } of backup) {
      object[key] = new Proxy$1(value, traps);
    }
    return backup;
  }
};

var HookHttpClient = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$2,
  hook: hook$2
});

const {
  Buffer: { from: toBuffer, concat: concatBuffer },
  Promise: Promise$1,
  Error,
  JSON: { parse: parseJSON, stringify: stringifyJSON },
} = globalThis;

const { request: createRequest } = Http;

const INVALID_HEADERS_MESSAGE =
  "in the presence of a body, 'content-type' should be 'application/json; charset=UTF-8'";

const parse = (body) => {
  if (body === "") {
    return null;
  }
  return parseJSON(body);
};

const stringify = (data) => {
  if (data === null) {
    return "";
  }
  return stringifyJSON(data);
};

const areValidHeaders = (headers) =>
  !hasOwnProperty(headers, "content-length") ||
  headers["content-length"] === "0" ||
  (hasOwnProperty(headers, "content-type") &&
    headers["content-type"] === "application/json; charset=UTF-8");

const empty_headers = {
  "content-length": 0,
};

const createHeaders = ({ length }) => {
  if (length === 0) {
    return empty_headers;
  }
  return {
    "content-type": "application/json; charset=UTF-8",
    "content-length": length,
  };
};

const requestAsync = (host, port, method, path, data) =>
  new Promise$1((resolve, reject) => {
    const buffer = toBuffer(stringify(data), "utf8");
    const request = createRequest({
      host,
      port: typeof port === "number" ? port : null,
      socketPath:
        typeof port === "string" ? toIpcPath(fileURLToPath(port)) : null,
      method,
      path,
      headers: createHeaders(buffer),
    });
    request.end(buffer);
    request.on("error", reject);
    request.on("response", (response) => {
      response.on("error", reject);
      if (areValidHeaders(response.headers)) {
        const buffers = [];
        response.on("data", (buffer) => {
          buffers.push(buffer);
        });
        response.on("end", () => {
          resolve({
            code: response.statusCode,
            message: response.statusMessage,
            body: parse(concatBuffer(buffers).toString("utf8")),
          });
        });
      } else {
        reject(new Error(INVALID_HEADERS_MESSAGE));
      }
    });
  });

const generateRespond = (respondAsync) => (request, response) => {
  if (areValidHeaders(request.headers)) {
    const buffers = [];
    request.on("data", (buffer) => {
      buffers.push(buffer);
    });
    request.on("end", async () => {
      const { code, message, body } = await respondAsync(
        request.method,
        request.url,
        parse(concatBuffer(buffers).toString("utf8")),
      );
      const buffer = toBuffer(stringify(body), "utf8");
      response.writeHead(code, message, createHeaders(buffer));
      response.end(buffer);
    });
  } else {
    request.on("data", noop);
    request.on("end", noop);
    response.writeHead(400, INVALID_HEADERS_MESSAGE, empty_headers);
    response.end();
  }
};

const {
  RegExp: RegExp$1,
  String: String$6,
  process: { nextTick },
  Reflect: { apply, construct },
  Proxy,
  undefined: undefined$3,
} = globalThis;

// TODO: improve test coverage

/* c8 ignore start */
const getStringPort = (server) => {
  const address = server.address();
  return typeof address === "string" ? address : String$6(address.port);
};

const interceptTraffic = (
  { host, track_port, recorder, regexp },
  server,
  request,
  response,
) => {
  if (
    recorder === "remote" &&
    request.url.startsWith("/_appmap/") &&
    regexp.test(getStringPort(server))
  ) {
    request.url = request.url.substring("/_appmap".length);
    generateRespond((method, path, body) =>
      requestAsync(host, track_port, method, `/_appmap${path}`, body),
    )(request, response);
    return true;
  } else {
    return false;
  }
};

/* c8 ignore stop */

const recordBegin = ({ frontend, empty }, tab, request) => {
  const { httpVersion: version, method, url, headers } = request;
  const protocol = `HTTP/${version}`;
  recordBeginRequestEvent(
    frontend,
    tab,
    executionAsyncId(),
    now(),
    toString(protocol),
    toString(method),
    toString(url),
    null,
    formatHeaders(headers),
    empty,
  );
  // Give time for express to populate the request
  nextTick(() => {
    if (
      typeof coalesce(request, "baseUrl", undefined$3) === "string" &&
      typeof coalesce(request, "route", undefined$3) === "object" &&
      typeof coalesce(request.route, "path", undefined$3) === "string"
    ) {
      recordBeginRequestAmend(
        frontend,
        tab,
        toString(protocol),
        toString(method),
        toString(url),
        `${request.baseUrl}${request.route.path}`,
        formatHeaders(headers),
        empty,
      );
    }
  });
};

const recordEnd = ({ frontend }, tab, response, body) => {
  recordEndResponseEvent(
    frontend,
    tab,
    executionAsyncId(),
    now(),
    formatStatus(response.statusCode),
    toString(response.statusMessage),
    formatHeaders(response.getHeaders()),
    body,
  );
};

const serializeResponseBody = ({ empty }, response, buffer) => {
  const headers = response.getHeaders();
  const { type, subtype, parameters } = parseContentType(
    getOwnProperty(headers, "content-type", "text/plain"),
  );
  const compression = getOwnProperty(headers, "content-encoding", "identity");
  if (
    type === "application" &&
    subtype === "json" &&
    compression === "identity"
  ) {
    return fromMaybe(
      decodeSafe(buffer, getOwnProperty(parameters, "charset", "utf-8"), null),
      empty,
      (string) => parseJSONSafe(string, empty),
    );
  } /* c8 ignore start */ else {
    return empty;
  } /* c8 ignore stop */
};

const trackJump = ({ frontend }, box, emitter) => {
  const tracking = createBox(true);
  patch(
    emitter,
    "emit",
    (original_emit) =>
      function emit(...args) {
        if (getBox(tracking)) {
          recordAfterJumpEvent(frontend, getBox(box), executionAsyncId(), now());
          setBox(box, getFreshTab(frontend));
          try {
            return apply(original_emit, this, args);
          } finally {
            recordBeforeJumpEvent(
              frontend,
              getBox(box),
              executionAsyncId(),
              now(),
            );
          }
        } else {
          return apply(original_emit, this, args);
        }
      },
  );
  return tracking;
};

const forwardTraffic = (
  _state,
  original_server_emit,
  server,
  request,
  response,
) => apply(original_server_emit, server, ["request", request, response]);

const spyTraffic = (state, original_server_emit, server, request, response) => {
  const { frontend, empty } = state;
  const bundle_tab = getFreshTab(frontend);
  const jump_box = createBox(getFreshTab(frontend));
  const request_tracking = trackJump(state, jump_box, request);
  const response_tracking = trackJump(state, jump_box, response);
  let body = empty;
  spyWritable(response, (buffer) => {
    body = serializeResponseBody(state, response, buffer);
  });
  const generateStopTracking = (box, peer_box) => () => {
    setBox(box, false);
    if (!getBox(peer_box)) {
      // make sure the end event is the last of the tab
      nextTick(() => {
        recordAfterJumpEvent(
          state.frontend,
          getBox(jump_box),
          executionAsyncId(),
          now(),
        );
        recordEnd(state, bundle_tab, response, body);
      });
    }
  };
  request.once(
    "close",
    spyOnce(
      generateStopTracking(request_tracking, response_tracking),
      identity,
    ),
  );
  response.once(
    "close",
    spyOnce(
      generateStopTracking(response_tracking, request_tracking),
      identity,
    ),
  );
  recordBegin(state, bundle_tab, request);
  try {
    return forwardTraffic(
      state,
      original_server_emit,
      server,
      request,
      response,
    );
  } finally {
    recordBeforeJumpEvent(frontend, getBox(jump_box), executionAsyncId(), now());
  }
};

const spyServer = (state, server, handleTraffic) => {
  patch(
    server,
    "emit",
    (original_server_emit) =>
      function emit(name, ...args) {
        if (name !== "request") {
          return apply(original_server_emit, this, [name, ...args]);
        } else {
          assert(
            !logErrorWhen(
              args.length !== 2,
              "Expected exactly two arguments for `request` event listener on `node:http.Server`",
            ),
            "Unexpected argument number on 'request' event listener",
            ExternalAppmapError,
          );
          const [request, response] = args;
          if (!interceptTraffic(state, this, request, response)) {
            handleTraffic(state, original_server_emit, this, request, response);
          }
          return true;
        }
      },
  );
};

const unhook$1 = (backup) => {
  backup.forEach(assignProperty);
};

const compileInterceptTrackPort = (source) => {
  try {
    return new RegExp$1(source, "u");
  } catch (error) {
    logError(
      "Failed to compile the 'intercept-track-port' configuration field %j as regexp >> %O",
      source,
      error,
    );
    throw new ExternalAppmapError("intercept-track-port is not a regexp");
  }
};

const hook$1 = (
  frontend,
  {
    recorder,
    host,
    "intercept-track-port": intercept_track_port,
    "track-port": track_port,
    hooks: { http },
  },
) => {
  if (!http && recorder !== "remote") {
    return [];
  } else {
    const handleTraffic = http ? spyTraffic : forwardTraffic;
    const backup = [Http, Https].flatMap((object) =>
      ["Server", "createServer"].map((key) => ({
        object,
        key,
        value: object[key],
      })),
    );
    const state = {
      frontend,
      recorder,
      track_port,
      host,
      empty: getSerializationEmptyValue(frontend),
      regexp: compileInterceptTrackPort(intercept_track_port),
    };
    const traps = {
      __proto__: null,
      apply: (target, context, values) => {
        const server = apply(target, context, values);
        spyServer(state, server, handleTraffic);
        return server;
      },
      construct: (target, values, newtarget) => {
        const server = construct(target, values, newtarget);
        spyServer(state, server, handleTraffic);
        return server;
      },
    };
    for (const { object, key, value } of backup) {
      object[key] = new Proxy(value, traps);
    }
    return backup;
  }
};

var HookHttpServer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$1,
  hook: hook$1
});

const Hooks = [
  HookApply,
  HookGroup,
  HookModule,
  HookEval,
  HookError,
  HookExit,
  HookQuery,
  HookHttpClient,
  HookHttpServer,
];

const generateHookSingle = (frontend, configuration) => (_, index) =>
  Hooks[index].hook(frontend, configuration);

const unhookSingle = (hooking, index) => Hooks[index].unhook(hooking);

const hook = (frontend, configuration) =>
  Hooks.map(generateHookSingle(frontend, configuration));

const unhook = (hooking) => hooking.map(unhookSingle);

const version = "1.8.0";

let validate = null;

const validateAppmap = (data) => {
  if (validate === null) {
    // Dynamic import on demand for performance
    const require = createRequire(import.meta.url);
    ({ validate } = require("@appland/appmap-validate"));
  }
  try {
    validate(data, { version });
  } catch (error) {
    logError("Invalid %s appmap >> %O\n>>%j", version, error, data);
    throw new InternalAppmapError("Invalid appmap");
  }
};

const setUrlHash = (url, hash) => {
  const url_obj = new URL$6(url);
  url_obj.hash = hash;
  return url_obj.toString();
};

const toSpecifier = (url, base) => {
  const relative = toRelativeUrl(url, base);
  if (relative === null) {
    return url;
  } else if (relative.startsWith("./") || relative.startsWith("../")) {
    return relative;
  } else {
    return `./${relative}`;
  }
};

const toDynamicSpecifier = (url, base, version) =>
  toSpecifier(setUrlHash(url, `#${version}`), base);

const toStaticSpecifier = (url, base) =>
  toSpecifier(setUrlHash(url, ""), base);

const splitSpecifier = (specifier) => {
  if (specifier.startsWith("./") || specifier.startsWith("../")) {
    return specifier.split("/");
  } else if (/^[a-zA-Z]+:\/\//u.test(specifier)) {
    const { protocol, host, pathname, search, hash } = new URL$6(specifier);
    assert(
      pathname.startsWith("/"),
      "url pathname should start with a slash",
      InternalAppmapError,
    );
    const dirnames = pathname.substring(1).split("/");
    const filename = `${dirnames.pop()}${search}${hash}`;
    return [`${protocol}//${host}`, ...dirnames, filename];
  } else {
    throw new InternalAppmapError("invalid specifier");
  }
};

const splitSpecifierDirectory = (specifier) => {
  const segments = splitSpecifier(specifier);
  segments.pop();
  if (segments[0] === "." && segments.length > 1) {
    segments.shift();
  }
  return segments;
};

const { Set: Set$2, Map: Map$5, String: String$5 } = globalThis;

/////////////
// factory //
/////////////

const registerFileUrl = (
  { url },
  codebase,
  disabled,
  {
    "inline-source": global_inline,
    exclude: global_criteria,
    packages: package_matcher_array,
    "default-package": default_package,
  },
) => {
  if (disabled.has(url)) {
    return false;
  } else if (codebase.has(url)) {
    return true;
  } else {
    const {
      enabled,
      exclude: criteria,
      "inline-source": inline,
      "source-type": source,
      parsing: plugins,
      shallow,
    } = lookupUrl(package_matcher_array, url, default_package);
    if (enabled) {
      codebase.set(url, {
        inline: inline === null ? global_inline : inline,
        criteria: [...criteria, ...global_criteria],
        shallow,
        parsing: { source, plugins },
        versions: new Map$5(),
      });
      return true;
    } else {
      disabled.add(url);
      return false;
    }
  }
};

const registerFile = ({ url, hash, content }, codebase) => {
  const { versions, criteria, parsing } = codebase.get(url);
  const version = String$5(versions.size);
  const source = createSource$1({
    url,
    content,
    program: parseEstree({ url, content }, parsing),
  });
  applyExclusionCriteria(source, criteria);
  versions.set(hash, { version, source });
};

const createCodebase = (files, configuration) => {
  const codebase = new Map$5();
  const disabled = new Set$2();
  for (const file of files) {
    if (registerFileUrl(file, codebase, disabled, configuration)) {
      registerFile(file, codebase);
    }
  }
  const {
    repository: { directory: base },
    "collapse-package-hierachy": collapse,
    pruning,
  } = configuration;
  return {
    codebase,
    disabled,
    pruning,
    collapse,
    base,
  };
};

///////////
// query //
///////////

const completeClosure = (source, specifier, shallow, position) => {
  const maybe_resolved_position = resolveClosurePosition(source, position);
  if (maybe_resolved_position === null) {
    return null;
  } else {
    return {
      ...lookupClosurePosition(source, maybe_resolved_position),
      position: maybe_resolved_position,
      shallow,
      specifier,
    };
  }
};

const lookupClosureLocation = (
  { codebase, disabled, base },
  location,
) => {
  const { url, hash, position } = location;
  if (codebase.has(url)) {
    const { shallow, versions } = codebase.get(url);
    if (/* c8 ignore start */ versions.size === 0) {
      throw new InternalAppmapError("unexpected source without version");
    } /* c8 ignore stop */ else if (versions.size === 1) {
      const {
        value: { source },
      } = versions.values().next();
      return completeClosure(
        source,
        toStaticSpecifier(url, base),
        shallow,
        position,
      );
    } else {
      if (hash === null) {
        logWarning(
          "Ignoring closure at %j because its source has multiple versions",
          location,
        );
        return null;
      } else {
        if (versions.has(hash)) {
          const { source, version } = versions.get(hash);
          return completeClosure(
            source,
            toDynamicSpecifier(url, base, version),
            shallow,
            position,
          );
        } else {
          logWarning(
            "Ignoring closure at %j because of source content mismatch",
            location,
          );
          return null;
        }
      }
    }
  } else {
    logWarningWhen(
      !disabled.has(url),
      "Ignoring closure at %j because its source is missing",
      location,
    );
    return null;
  }
};

////////////
// export //
////////////

const registerPackage = (entities, segment) => {
  const predicate = (entity) =>
    entity.type === "package" && entity.name === segment;
  if (!entities.some(predicate)) {
    entities.push({ type: "package", name: segment, children: [] });
  }
  return entities.find(predicate).children;
};

const exportClassmap = ({ codebase, base, pruning, collapse }) => {
  const root = [];
  for (const [url, { inline, versions }] of codebase.entries()) {
    for (const { version, source } of versions.values()) {
      const specifier =
        versions.size === 1
          ? toStaticSpecifier(url, base)
          : toDynamicSpecifier(url, base, version);
      const children = exportClassmap$1(source, {
        specifier,
        inline,
        pruning,
      });
      if (
        /* c8 ignore start */ !pruning ||
        children.length > 0 /* c8 ignore stop */
      ) {
        if (collapse) {
          root.push({
            type: "package",
            name: specifier,
            children,
          });
        } else {
          splitSpecifierDirectory(specifier)
            .reduce(registerPackage, root)
            .push(...children);
        }
      }
    }
  }
  return root;
};

const { undefined: undefined$2 } = globalThis;

/* c8 ignore start */
const getName = ({ name }) => name;

const makeClient = (agent) => {
  if (agent === null) {
    agent = {
      directory: null,
      package: {
        name: "@appland/appmap-agent-js",
        version: "???",
        homepage: undefined$2,
      },
    };
  }
  const {
    package: { name, version, homepage },
  } = agent;
  return {
    name,
    version,
    url:
      homepage === null || homepage === undefined$2
        ? "https://github.com/applandinc/appmap-agent-js"
        : homepage,
  };
};

/* c8 ignore stop */

const makeJustRecording = ({
  "defined-class": defined_class,
  "method-id": method_id,
}) => ({
  defined_class,
  method_id,
});

const makeRecording = (recording) => mapMaybe(recording, makeJustRecording);

const sanitizeHistory = ({ repository, branch, commit, ...rest }) => ({
  repository: recoverMaybe(repository, "APPMAP-MISSING-REPOSITORY-NAME"),
  branch: recoverMaybe(branch, "APPMAP-MISSING-REPOSITORY-BRANCH"),
  commit: recoverMaybe(commit, "APPMAP-MISSING-REPOSITORY-COMMIT"),
  ...rest,
});

const makeGit = ({ history }) => mapMaybe(history, sanitizeHistory);

const makeAppName = (app_name, { package: _package }) =>
  app_name === null ? mapMaybe(_package, getName) : app_name;

const makeMapName = (map_name, file_name, main) => {
  if (map_name !== null) {
    return map_name;
  }
  if (file_name !== null) {
    return file_name;
  }
  if (main !== null) {
    return getUrlBasename(main);
  }
  return null;
};

const makeTestStatus = (termination) => {
  if (termination.type === "test") {
    return termination.passed ? "succeeded" : "failed";
  } else {
    return null;
  }
};

const makeRecorder = (recorder) => {
  assert(
    recorder !== null,
    "recorder should have been resolved earlier",
    InternalAppmapError,
  );
  return { name: recorder };
};

const makeException = (serials) => {
  if (serials.length === 0) {
    return null;
  } else {
    const serial = serials[0];
    if (serial.type === "object" || serial.type === "function") {
      if (serial.specific !== null && serial.specific.type === "error") {
        return {
          class: serial.specific.name,
          message: serial.specific.message,
        };
      } else {
        return {
          class: serial.constructor,
          message: serial.print,
        };
      }
    } else {
      return {
        class: serial.type,
        message: serial.print,
      };
    }
  }
};

/* c8 ignore start */
const compileMetadata = (
  {
    name: app_name,
    "map-name": map_name,
    repository,
    labels,
    frameworks,
    language,
    engine,
    agent,
    main,
    appmap_file: file_name,
    recorder,
    recording,
  },
  errors,
  termination,
) => ({
  name: makeMapName(map_name, file_name, main) ?? undefined$2,
  app: makeAppName(app_name, repository) ?? undefined$2,
  labels: labels ?? undefined$2,
  language: {
    name: language,
    version: "ES.Next",
    engine: engine ?? undefined$2,
  },
  frameworks: frameworks ?? undefined$2,
  client: makeClient(agent),
  recorder: makeRecorder(recorder),
  recording: makeRecording(recording) ?? undefined$2,
  git: makeGit(repository) ?? undefined$2,
  test_status: makeTestStatus(termination) ?? undefined$2,
  exception: makeException(errors) ?? undefined$2,
});
/* c8 ignore stop */

const {
  String: String$4,
  undefined: undefined$1,
  Object: { entries: toEntries },
  Array: { from: arrayFrom },
} = globalThis;

const parseURL = (url, headers) =>
  new URL$6(
    url[0] === "/"
      ? `http://${coalesceCaseInsensitive(headers, "host", "localhost")}${url}`
      : url,
  );

// const placeholder = {
//   link: {
//     defined_class: "MANUFACTURED_APPMAP_CLASS",
//     lineno: 0,
//     method_id: "MANUFACTURED_APPMAP_METHOD",
//     static: false,
//     path: "MANUFACTURED_APPMAP_FILE.js",
//   },
//   parameters: [],
// };

const isFirstColon = ([string]) => string.startsWith(":");

const digestSearchMessage = (search) =>
  arrayFrom(new URLSearchParams(search).entries());

// export for testing
const digestParameterPrimitive = (name, primitive) => ({
  name,
  class: typeof primitive,
  object_id: undefined$1,
  value: String$4(primitive),
});

const digestParameterPrimitiveTuple = ([name, primitive]) =>
  digestParameterPrimitive(name, primitive);

const digestSpecificHashEntry = ([key, value]) => ({
  name: key,
  class: value,
});

const digestSpecific = (specific) => {
  if (specific === null) {
    return null;
  } else if (specific.type === "array") {
    return { size: specific.length };
  } else if (specific.type === "hash") {
    return {
      size: specific.length,
      properties: toEntries(specific.properties).map(digestSpecificHashEntry),
    };
  } else {
    return null;
  }
};

// export for testing
const digestParameterSerial = (name, serial) => {
  if (serial.type === "object" || serial.type === "function") {
    return {
      name,
      class: serial.constructor,
      object_id: serial.index,
      value: serial.print,
      ...digestSpecific(serial.specific),
    };
  } else {
    return {
      name,
      class: serial.type,
      object_id: serial.type === "symbol" ? serial.index : undefined$1,
      value: serial.print,
    };
  }
};

const digestParameterSerialReturn = (serial) =>
  digestParameterSerial("return", serial);

const digestParameterSerialTuple = ([name, serial]) =>
  digestParameterSerial(name, serial);

const extractErrorSpecific = (specific) =>
  specific !== null && specific.type === "error"
    ? specific
    : { message: null, stack: null };

// export for testing
const digestExceptionSerial = (serial) => {
  if (serial.type === "object" || serial.type === "function") {
    const { message, stack } = extractErrorSpecific(serial.specific);
    return {
      class: serial.constructor,
      message: recoverMaybe(message, serial.print),
      object_id: serial.index,
      // TODO: extract path from stack
      path: stack ?? undefined$1,
      // TODO: extract line number from stack
      lineno: undefined$1,
    };
  } else {
    return {
      class: serial.type,
      message: serial.print,
      object_id: serial.type === "symbol" ? serial.index : 0,
      path: undefined$1,
      lineno: undefined$1,
    };
  }
};

const digesters = {
  // function //
  apply: ({ this: _this, arguments: _arguments }, { link, parameters }) => ({
    ...link,
    // TODO: It would make more sense to allow receiver to be null.
    // receiver: mapMaybe(this, digestParameterSerialThis),
    receiver:
      _this === null
        ? digestParameterPrimitive("this", undefined$1)
        : digestParameterSerial("this", _this),
    parameters: zip(parameters, _arguments).map(digestParameterSerialTuple),
  }),
  return: ({ result }, _options) => ({
    return_value: digestParameterSerial("return", result),
    exceptions: undefined$1,
  }),
  throw: ({ error }, _options) => ({
    return_value: undefined$1,
    exceptions: [digestExceptionSerial(error)],
  }),
  // http //
  request: ({ side, protocol, method, url, headers, route }, _options) => {
    const { origin, pathname, search } = parseURL(url, headers);
    if (side === "server") {
      return {
        http_server_request: {
          protocol,
          request_method: method,
          path_info: pathname,
          normalized_path_info: route,
          headers,
        },
        message: [
          ...(route === null
            ? []
            : zip(route.split("/"), pathname.split("/")).filter(isFirstColon)),
          ...digestSearchMessage(search),
        ].map(digestParameterPrimitiveTuple),
      };
    } else if (side === "client") {
      return {
        http_client_request: {
          request_method: method,
          url: `${origin}${pathname}`,
          headers,
        },
        message: digestSearchMessage(search).map(digestParameterPrimitiveTuple),
      };
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid request side");
    } /* c8 ignore stop */
  },
  response: ({ side, status, headers, body }, _options) => ({
    [`http_${side}_response`]: {
      status_code: status,
      headers,
      return_value: mapMaybe(body, digestParameterSerialReturn),
    },
  }),
  // sql //
  query: ({ database, version, sql, parameters }, _options) => ({
    sql_query: {
      database_type: database,
      server_version: version,
      sql,
      explain_sql: undefined$1,
    },
    message: toEntries(parameters).map(digestParameterSerialTuple),
  }),
  answer: ({}, _options) => ({}),
};

const digestPayload = (payload, options) => {
  const { type } = payload;
  assert(
    hasOwnProperty(digesters, type),
    "cannot digest payload",
    InternalAppmapError,
  );
  return digesters[type](payload, options);
};

const { Map: Map$4 } = globalThis;

const digestEventPair = (event1, event2, id1, id2, info) => [
  {
    event: "call",
    thread_id: 0,
    id: id1,
    ...digestPayload(event1.payload, info),
  },
  {
    event: "return",
    thread_id: 0,
    id: id2,
    parent_id: id1,
    elapsed: (event2.time - event1.time) / 1000,
    ...digestPayload(event2.payload, info),
  },
];

const toClosureInfo = ({
  excluded,
  specifier,
  position: { line },
  parent,
  name,
  static: is_static,
  parameters,
  shallow,
}) => ({
  excluded,
  link: {
    path: specifier,
    lineno: line,
    defined_class: parent,
    static: is_static,
    method_id: name,
  },
  shallow,
  parameters,
});

const digestEventTrace = (root, codebase) => {
  const counter = createCounter(0);
  const cache = new Map$4();
  const getClosureInfo = (location_string) => {
    if (cache.has(location_string)) {
      return cache.get(location_string);
    } else {
      const info = mapMaybe(
        lookupClosureLocation(codebase, parseLocation(location_string)),
        toClosureInfo,
      );
      cache.set(location_string, info);
      return info;
    }
  };
  /* eslint-disable no-use-before-define */
  const digestTransparentBundle = ({ children }, _info) =>
    children.flatMap(loop);
  /* eslint-enable no-use-before-define */
  const digestShallowBundle = ({ begin, end }, info) =>
    digestEventPair(
      begin,
      end,
      incrementCounter(counter),
      incrementCounter(counter),
      info,
    );
  /* eslint-disable no-use-before-define */
  const digestDeepBundle = ({ begin, children, end }, info) => {
    const id1 = incrementCounter(counter);
    const digest = children.flatMap(loop);
    const id2 = incrementCounter(counter);
    const [event1, event2] = digestEventPair(begin, end, id1, id2, info);
    digest.unshift(event1);
    digest.push(event2);
    return digest;
  };
  /* eslint-enable no-use-before-define */
  const loop = (node) => {
    if (node.type === "bundle") {
      const {
        begin: {
          payload: { type },
        },
      } = node;
      if (type === "bundle" || type === "group") {
        return digestTransparentBundle(node);
      } else if (type === "apply") {
        const info = mapMaybe(node.begin.payload.function, getClosureInfo);
        if (info === null || info.excluded) {
          return digestTransparentBundle(node);
        } else if (info.shallow) {
          return digestShallowBundle(node, info);
        } else {
          return digestDeepBundle(node, info);
        }
      } else {
        return digestDeepBundle(node, null);
      }
    } else if (node.type === "jump") {
      const { before, after } = node;
      const {
        payload: { type },
      } = before;
      if (type === "jump" || type === "await" || type === "yield") {
        return [];
      } else {
        return digestEventPair(
          before,
          after,
          incrementCounter(counter),
          incrementCounter(counter),
          null,
        );
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid node type");
    } /* c8 ignore stop */
  };
  return root.flatMap(loop);
};

// Resolve groups.
// Each top-level tree is associated to a group.
// These trees are inserted into their corresponding group/ungroup event pair.
// NB: group/ungroup event pairs appear when asynchronous ressources are registered.

const {
  Array: { from: toArray$3 },
  Map: Map$3,
  String: String$3,
} = globalThis;

const takeMap = (map, key) => {
  const value = map.get(key);
  map.delete(key);
  return value;
};

const makeGroupKey = (session, group) => `${session}/${String$3(group)}`;

const groupStack = (root) => {
  const deep_group_map = new Map$3();
  const root_group_map = new Map$3();
  for (const node of root) {
    const key = makeGroupKey(node.enter.session, node.enter.group);
    if (root_group_map.has(key)) {
      root_group_map.get(key).push(node);
    } else {
      root_group_map.set(key, [node]);
    }
  }
  const mapping = ({ enter, children, leave }) => {
    children = children.map(mapping);
    if (enter.site === "begin" && enter.payload.type === "group") {
      // NB: We want to use `enter.payload.group` and not `enter.group`.
      // - `enter.payload.group` is the id of the newly created async group.
      // - `enter.group` is the id of the current async group.
      const key = makeGroupKey(enter.session, enter.payload.group);
      if (root_group_map.has(key)) {
        for (const async_child of takeMap(root_group_map, key)) {
          children.push(mapping(async_child));
        }
      } else if (deep_group_map.has(key)) {
        for (const async_child of takeMap(deep_group_map, key)) {
          children.push(async_child);
        }
      }
    }
    return { enter, children, leave };
  };
  for (const key of root_group_map.keys()) {
    deep_group_map.set(key, takeMap(root_group_map, key).map(mapping));
  }
  return toArray$3(deep_group_map.values()).flat(1);
};

// Rearrenge the event trace into an array of trees.

const createJumpEvent = (session, site, tab, group, time) => ({
  type: "event",
  session,
  site,
  tab,
  group,
  time,
  payload: {
    type: "jump",
  },
});

const createFreshCounter = (events) => {
  let max = 0;
  for (const event of events) {
    if (event.tab > max) {
      max = event.tab;
    }
  }
  return createCounter(max);
};

const stackify = (events) => {
  const stack = [
    {
      enter: null,
      children: [],
      leave: null,
    },
  ];
  const counter = createFreshCounter(events);
  for (const event of events) {
    if (event.site === "begin" || event.site === "after") {
      stack.push({
        enter: event,
        children: [],
        leave: null,
      });
    } else if (event.site === "end" || event.site === "before") {
      let maybe_frame = null;
      for (
        let index = stack.length - 1;
        index >= 1 && maybe_frame === null;
        index -= 1
      ) {
        const frame = stack[index];
        if (frame.enter.session === event.session) {
          maybe_frame = stack[index];
        }
      }
      if (maybe_frame === null) {
        stack[0].children = [
          {
            enter: createJumpEvent(
              event.session,
              "after",
              incrementCounter(counter),
              event.group,
              event.time,
            ),
            children: stack[0].children,
            leave: event,
          },
        ];
      } else {
        assert(
          maybe_frame.leave === null,
          "frame has already been completed",
          InternalAppmapError,
        );
        maybe_frame.leave = event;
        while (stack.length > 1 && stack[stack.length - 1].leave !== null) {
          const frame = stack.pop();
          stack[stack.length - 1].children.push(frame);
        }
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid event site");
    } /* c8 ignore stop */
  }
  while (stack.length > 1) {
    const frame = stack.pop();
    frame.leave = createJumpEvent(
      frame.enter.session,
      "before",
      incrementCounter(counter),
      frame.enter.group,
      frame.enter.time,
    );
    stack[stack.length - 1].children.push(frame);
  }
  return stack[0].children;
};

const payloads = {
  jump: {
    type: "jump",
  },
  bundle: {
    type: "bundle",
  },
  apply: {
    type: "apply",
    function: null,
    this: {
      type: "string",
      print: "APPMAP-APPLY",
    },
    arguments: [],
  },
  return: {
    type: "return",
    function: null,
    result: {
      type: "string",
      print: "APPMAP-RETURN",
    },
  },
  throw: {
    type: "throw",
    function: null,
    error: {
      type: "string",
      print: "APPMAP-THROW",
    },
  },
  request: {
    side: null,
    type: "request",
    protocol: "HTTP/1.1",
    method: "GET",
    path: "/APPMAP/REQUEST",
    route: null,
    headers: {},
    body: null,
  },
  response: {
    side: null,
    type: "response",
    status: 200,
    message: "APPMAP-RESPONSE",
    route: null,
    headers: {},
    body: null,
  },
  query: {
    type: "query",
    database: "",
    version: null,
    sql: "SELECT * FROM APPMAP-QUERY;",
  },
  answer: {
    type: "answer",
    error: null,
  },
  yield: {
    type: "yield",
    function: null,
    delegate: false,
    iterator: {
      type: "string",
      print: "APPMAP-YIELD",
    },
  },
  await: {
    type: "await",
    function: null,
    promise: {
      type: "string",
      print: "APPMAP-AWAIT",
    },
  },
  resolve: {
    type: "resolve",
    function: null,
    result: {
      type: "APPMAP-RESOLVE",
    },
  },
  reject: {
    type: "reject",
    function: null,
    error: {
      type: "APPMAP-REJECT",
    },
  },
  group: {
    type: "group",
    group: null,
    description: "MISSING",
  },
  ungroup: {
    type: "ungroup",
    group: null,
  },
};

const matching = [
  ["begin/bundle", "end/bundle", []],
  ["begin/apply", "end/return", ["function"]],
  ["begin/apply", "end/throw", ["function"]],
  ["begin/request", "end/response", ["side"]],
  ["begin/group", "end/ungroup", ["group"]],
  ["before/await", "after/resolve", ["function"]],
  ["before/await", "after/reject", ["function"]],
  ["before/yield", "after/resolve", ["function"]],
  ["before/yield", "after/reject", ["function"]],
  ["before/jump", "after/jump", []],
  ["before/request", "after/response", ["side"]],
  ["before/query", "after/answer", []],
];

const makeMatchingKey = ({ site, payload: { type } }) => `${site}/${type}`;

const makeMatch = (key, copying) => {
  const [site, type] = key.split("/");
  return { site, type, copying };
};

const lookupMatch = (event) => {
  const key = makeMatchingKey(event);
  for (const match of matching) {
    if (match[0] === key) {
      return makeMatch(match[1], match[2]);
    } else if (match[1] === key) {
      return makeMatch(match[0], match[2]);
    }
  }
  throw new InternalAppmapError(
    "invalid combination of event site and event payload type",
  );
};

const manufactureMatchingEvent = (event) => {
  const { site, type, copying } = lookupMatch(event);
  const payload = { ...payloads[type] };
  for (const field of copying) {
    payload[field] = event.payload[field];
  }
  return {
    type: "event",
    session: event.session,
    site,
    tab: event.tab,
    time: event.time,
    group: event.group,
    payload,
  };
};

const isMatchingEvent = (event1, event2) => {
  const key1 = makeMatchingKey(event1);
  const key2 = makeMatchingKey(event2);
  for (const match of matching) {
    if (match[0] === key1 && match[1] === key2) {
      for (const field of match[2]) {
        if (event1.payload[field] !== event2.payload[field]) {
          return false;
        }
      }
      return event1.session === event2.session && event1.tab === event2.tab;
    }
  }
  return false;
};

// Resolve jumps.

const {
  Array: { from: toArray$2 },
  Map: Map$2,
  String: String$2,
} = globalThis;

const makeJumpKey = ({ session, tab }) => `${session}/${String$2(tab)}`;

const manufactureBundleEvent = (session, site, tab) => ({
  type: "event",
  session,
  site,
  tab,
  group: 0,
  time: 0,
  payload: {
    type: "bundle",
  },
});

const makeBundleNode = (begin, children, end) => {
  assert(
    isMatchingEvent(begin, end),
    "begin/end event mismatch",
    InternalAppmapError,
  );
  return {
    type: "bundle",
    begin,
    children,
    end,
  };
};

const makeJumpNode = (before, after) => {
  assert(
    isMatchingEvent(before, after),
    "before/after event mismatch",
    InternalAppmapError,
  );
  return {
    type: "jump",
    before,
    after,
  };
};

const makeOrphan = (open, children, close) => ({
  open,
  children,
  close,
});

const manufactureBundleNode = (orphan) => {
  if (orphan.open.site === "begin" && orphan.close.site === "end") {
    return makeBundleNode(orphan.open, orphan.children, orphan.close);
  } else if (orphan.open.site === "after" && orphan.close.site === "before") {
    return makeBundleNode(
      manufactureBundleEvent(orphan.open.session, "begin", 0),
      [
        makeJumpNode(manufactureMatchingEvent(orphan.open), orphan.open),
        ...orphan.children,
        makeJumpNode(orphan.close, manufactureMatchingEvent(orphan.close)),
      ],
      manufactureBundleEvent(orphan.close.session, "end", 0),
    );
  } else if (orphan.open.site === "after" && orphan.close.site === "end") {
    return makeBundleNode(
      manufactureMatchingEvent(orphan.close),
      [
        makeJumpNode(manufactureMatchingEvent(orphan.open), orphan.open),
        ...orphan.children,
      ],
      orphan.close,
    );
  } else if (orphan.open.site === "begin" && orphan.close.site === "before") {
    return makeBundleNode(
      orphan.open,
      [
        ...orphan.children,
        makeJumpNode(orphan.close, manufactureMatchingEvent(orphan.close)),
      ],
      manufactureMatchingEvent(orphan.open),
    );
  } /* c8 ignore start */ else {
    throw new InternalAppmapError("invalid enter/leave event site");
  } /* c8 ignore stop */
};

const splitJump = (frames, jumps) => {
  const filtering = (frame) => {
    if (frame.enter.site === "after") {
      const key = makeJumpKey(frame.enter);
      assert(!jumps.has(key), "duplicate jump", InternalAppmapError);
      jumps.set(key, frame);
      return false;
    } else {
      return true;
    }
  };
  const mapping = ({ enter, children, leave }) => ({
    enter,
    children: children.map(mapping).filter(filtering),
    leave,
  });
  return frames.map(mapping).filter(filtering);
};

const joinJump = (frames, jumps) => {
  /* eslint-disable no-use-before-define */
  const mapBeginFrame = (frame) => manufactureBundleNode(mapFrame(frame));
  /* eslint-enable no-use-before-define */
  const orphans = new Map$2();
  const mapFrame = (frame) => {
    const open = frame.enter;
    const nodes = frame.children.map(mapBeginFrame);
    let close = frame.leave;
    while (close.site === "before") {
      const key = makeJumpKey(close);
      if (jumps.has(key)) {
        const frame = jumps.get(key);
        jumps.delete(key);
        nodes.push(makeJumpNode(close, frame.enter));
        nodes.push(...frame.children.map(mapBeginFrame));
        close = frame.leave;
      } else if (orphans.has(key)) {
        const orphan = orphans.get(key);
        orphans.delete(key);
        nodes.push(makeJumpNode(close, orphan.open));
        nodes.push(...orphan.children);
        close = orphan.close;
      } else {
        return makeOrphan(open, nodes, close);
      }
    }
    return makeOrphan(open, nodes, close);
  };
  const nodes = frames.map(mapBeginFrame);
  for (const key of jumps.keys()) {
    const frame = jumps.get(key);
    jumps.delete(key);
    orphans.set(key, mapFrame(frame));
  }
  return [].concat(toArray$2(orphans.values()).map(manufactureBundleNode), nodes);
};

const jumpify = (root) => {
  const jumps = new Map$2();
  return joinJump(splitJump(root, jumps), jumps);
};

// Beware, event ordering is by far the most difficult code to understand.

const orderEventArray = (events) =>
  jumpify(groupStack(stackify(events)));

const { encodeURIComponent } = globalThis;

const pickBasename = ({ appmap_file: basename, "map-name": name }) => {
  if (basename !== null) {
    return basename;
  } else if (name !== null) {
    return name;
  } else {
    return "anonymous";
  }
};

const getOutputUrl = (configuration) =>
  toAbsoluteUrl(
    `${configuration.recorder}/${encodeURIComponent(
      sanitizePathFilename(`${pickBasename(configuration)}.appmap.json`),
    )}`,
    configuration.appmap_dir,
  );

const {
  Map: Map$1,
  Array: { from: toArray$1 },
  String: String$1,
  Math: { round },
  RangeError,
} = globalThis;

const VERSION = "1.8.0";

const TOTAL_EVENT_THRESHOLD = 1e6;

const GROUP_EVENT_THRESHOLD = 5e5;

const APPLY_EVENT_THRESHOLD = 1e5;

const STACKOVERFLOW_MESSAGE = `\
We could not process your appmap because it has too many events (that are deeply nested). \
The preferred method to solve this issue is to reduce the size of the appmap. \
Alternatively, you could try to increase the callstack size of this node process:
\`\`\`
> node --stack-size=5000 node_modules/bin/appmap-agent-js -- npm run test
\`\`\`
NB: Unfortunately, \`--stack-size'\` cannot be set via the \`NODE_OPTIONS\` environment variable.\
`;

const TOO_MANY_GROUP_EVENT_MESSAGE = `\
Many recorded events were related to tracking asynchronous resources. \
This impacts the performance of the javascript agent and may cause memory issues. \
It is possible to no longer record them by adding \`ordering: chronological\` to the appmap.yml file. \
This would speed up the execution of the agent but would make it unable to track the origin of callbacks. \
Note that async/await structure will still be preserved.\
`;

const TOO_MANY_APPLY_EVENT_MESSAGE = `\
Many function applications were recorded. \
The appmap framework works best with smaller appmaps. \
Beside reducing the scope of the recording (eg: smaller test cases or shorter remote recording) the configuration file can be tweaked to exclude functions from recording. \
Let's say we recorded this function many times:
  \`\`\`js
  /* util.js */
  // @label appmap-exclude
  export const isNull = (any) => any === null;
  \`\`\`
  There are many ways to exclude it:
  \`\`\`yaml
  # appmap.yml #
  # global function exclusion #
  exclude:
    - name: isNull
    - qualified-name: util.isNull
    - some-label: appmap-exclude
  packages:
    # file-scoped function exclusion #
    - glob: util.js
      exclude:
        - name: isNull
    # file exclusion #
    - glob: util.js
      enabled: false
  \`\`\`
`;

const countApplyEvent = (count, { payload: { type } }) =>
  type === "apply" ? count + 1 : count;

const countGroupEvent = (count, { payload: { type } }) =>
  type === "group" ? count + 1 : count;

const printLocation = ({ url, position: { line, column } }) =>
  `${url}:${String$1(line)}:${String$1(column)}`;

const printCount = (count, total) =>
  `${String$1(count)} [${String$1(round((100 * count) / total))}%]`;

const chartEvent = (events) => {
  const counters = new Map$1();
  for (const { payload } of events) {
    const { type } = payload;
    counters.set(type, (counters.has(type) ? counters.get(type) : 0) + 1);
  }
  return counters;
};

const printEventCount = (name, count, total) =>
  `  - ${name}: ${printCount(count, total)}\n`;

const printEventDistribution = (events) => {
  const counters = chartEvent(events);
  const { length: total } = events;
  return toArray$1(counters.keys())
    .sort((key1, key2) => counters.get(key2) - counters.get(key1))
    .map((key) => printEventCount(key, counters.get(key), total))
    .join("");
};

const chartApplyEvent = (events) => {
  const counters = new Map$1();
  for (const { payload } of events) {
    if (payload.type === "apply") {
      const { function: location } = payload;
      counters.set(
        location,
        (counters.has(location) ? counters.get(location) : 0) + 1,
      );
    }
  }
  return counters;
};

const printApplyEventCount = (location, count, total, codebase) => {
  const maybe = lookupClosureLocation(codebase, location);
  const lines = [];
  lines.push(`  - ${printLocation(location)} >> ${printCount(count, total)}`);
  /* c8 ignore start */
  if (maybe === null) {
    lines.push(
      "    We could not find any information associated to this function...",
    );
  } else {
    const { excluded } = maybe;
    if (excluded) {
      lines.push(
        "    This function was excluded but postmortem so it was still recorded.",
        "    To no longer record this function use: `postmortem-function-exclusion: false`.",
      );
    } else {
      const { labels, name, parent, static: static_ } = maybe;
      lines.push(
        "    This function can be excluded with the following criteria:",
        `      - name: ${name}`,
        `      - qualified-name: ${parent}${static_ ? "#" : "."}${name}`,
      );
      if (labels.length > 0) {
        lines.push(`      - labels: ${labels.join(", ")}`);
      }
    }
    lines.push("");
  }
  /* c8 ignore stop */
  return lines.join("\n");
};

const printApplyEventDistribution = (events, codebase) => {
  const counters = chartApplyEvent(events);
  const total = events.reduce(countApplyEvent, 0);
  return toArray$1(counters.keys())
    .sort((key1, key2) => counters.get(key2) - counters.get(key1))
    .slice(0, 7)
    .map((key) =>
      printApplyEventCount(
        parseLocation(key),
        counters.get(key),
        total,
        codebase,
      ),
    )
    .join("");
};

const compileTrace = (configuration, files, messages, termination) => {
  logDebug("Trace: %j", { configuration, files, messages, termination });
  const errors = [];
  const events = [];
  for (const message of messages) {
    const { type } = message;
    if (type === "error") {
      errors.push(message.error);
    } else if (type === "event") {
      events.push(message);
    } else if (type === "group") {
      events.push(
        {
          type: "event",
          session: message.session,
          site: "begin",
          tab: 0,
          group: message.group,
          time: 0,
          payload: {
            type: "group",
            group: message.child,
            description: message.description,
          },
        },
        {
          type: "event",
          session: message.session,
          site: "end",
          tab: 0,
          group: message.group,
          time: 0,
          payload: {
            type: "ungroup",
            group: message.child,
          },
        },
      );
    } else if (type === "amend") {
      for (let index = events.length - 1; index >= 0; index -= 1) {
        const event = events[index];
        if (
          event.session === message.session &&
          event.tab === message.tab &&
          event.site === message.site
        ) {
          events[index] = { ...event, payload: message.payload };
          break;
        }
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("invalid core message type");
    } /* c8 ignore stop */
  }
  const url = getOutputUrl(configuration);
  const codebase = createCodebase(files, configuration);
  const total_count = events.length;
  const apply_count = events.reduce(countApplyEvent, 0);
  const group_count = events.reduce(countGroupEvent, 0);
  logInfo("AppMap %s", url);
  logInfoWhen(
    total_count > TOTAL_EVENT_THRESHOLD,
    "This appmap is very large (%j events), we will try our best to process it...",
    total_count,
  );
  logInfoWhen(
    total_count > TOTAL_EVENT_THRESHOLD,
    "Event distribution:\n%f",
    () => printEventDistribution(events),
  );
  logDebugWhen(
    total_count <= TOTAL_EVENT_THRESHOLD,
    "Event distribution:\n%f",
    () => printEventDistribution(events),
  );
  logInfoWhen(
    group_count > GROUP_EVENT_THRESHOLD,
    TOO_MANY_GROUP_EVENT_MESSAGE,
  );
  logInfoWhen(
    apply_count > APPLY_EVENT_THRESHOLD,
    TOO_MANY_APPLY_EVENT_MESSAGE,
  );
  logInfoWhen(
    apply_count > APPLY_EVENT_THRESHOLD,
    "Most frequently applied functions:\n%f",
    () => printApplyEventDistribution(events, codebase),
  );
  logDebugWhen(
    apply_count <= APPLY_EVENT_THRESHOLD,
    "Most frequently applied functions:\n%f",
    () => printApplyEventDistribution(events, codebase),
  );
  let digested_events = null;
  /* c8 ignore start */
  try {
    digested_events = digestEventTrace(orderEventArray(events), codebase);
  } catch (error) {
    if (error instanceof RangeError) {
      logError("Stack overflow error >> %O", error);
      logError(STACKOVERFLOW_MESSAGE);
      throw new ExternalAppmapError(
        "Stack overflow error during appmap processing",
      );
    } else {
      throw error;
    }
  }
  /* c8 ignore stop */
  const appmap = {
    version: VERSION,
    metadata: compileMetadata(configuration, errors, termination),
    classMap: exportClassmap(codebase),
    events: digested_events,
  };
  if (configuration.validate.appmap) {
    validateAppmap(appmap);
  }
  return {
    url: getOutputUrl(configuration),
    content: appmap,
  };
};

const { RegExp, Set: Set$1 } = globalThis;

const startTrack = (configuration) => ({
  configuration,
  regexp: new RegExp(configuration.sessions, "u"),
  sources: [],
  messages: [],
  termination: null,
  present: new Set$1(),
  missing: new Set$1(),
});

const stopTrack = (track, termination) => {
  track.termination = termination;
};

const compileTrack = (track) =>
  compileTrace(
    track.configuration,
    track.sources,
    track.messages,
    track.termination ?? { type: "unknown" },
  );

const makeStaticKey = ({ url }) => `|${url}`;

const makeDynamicKey = ({ url, hash }) => `${hash}|${url}`;

const addTrackSource = (track, source) => {
  track.sources.push(source);
  const key1 = makeStaticKey(source);
  track.present.add(key1);
  track.missing.delete(key1);
  if (source.hash !== null) {
    const key2 = makeDynamicKey(source);
    track.present.add(key2);
    track.missing.delete(key2);
  }
};

const sendTrack = (track, message) => {
  const { type, session } = message;
  if (track.regexp.test(session)) {
    if (type === "amend" || track.termination === null) {
      track.messages.push(message);
    }
    if (type === "event") {
      const { payload } = message;
      const { type: payload_type } = payload;
      if (
        payload_type === "apply" ||
        payload_type === "return" ||
        payload_type === "throw"
      ) {
        const location = parseLocation(payload.function);
        const key1 = makeStaticKey(location);
        if (!track.present.has(key1)) {
          track.missing.add(key1);
        }
        if (location.hash !== null) {
          const key2 = makeDynamicKey(location);
          if (!track.present.has(key2)) {
            track.missing.add(key2);
          }
        }
      }
    }
  }
};

const isTrackComplete = (track) =>
  track.termination !== null && track.missing.size === 0;

const {
  Map,
  Boolean,
  Array: { from: toArray },
} = globalThis;

const processStartMessage = ({ tracks, sources }, key, configuration) => {
  if (tracks.has(key)) {
    logError("Duplicate track %j", key);
    return false;
  } else {
    const track = startTrack(configuration);
    for (const source of sources) {
      addTrackSource(track, source);
    }
    tracks.set(key, track);
    return true;
  }
};

// We do no compile the track at this points because additional
// source messages may still arrive. That is because the tranformer
// may reside on a different process.
const processStopMessage = ({ tracks }, key, termination) => {
  if (tracks.has(key)) {
    const track = tracks.get(key);
    stopTrack(track, termination);
    return true;
  } else {
    logError("missing track %j", key);
    return false;
  }
};

const createBackend = (configuration) => ({
  configuration,
  sources: [],
  tracks: new Map(),
});

const compileBackendTrack = ({ tracks }, key, abrupt) => {
  if (tracks.has(key)) {
    const track = tracks.get(key);
    if (abrupt || isTrackComplete(track)) {
      tracks.delete(key);
      return compileTrack(track);
    } else {
      return null;
    }
  } else {
    return null;
  }
};

const sendBackend = (backend, message) => {
  logDebug("message >> %j", message);
  if (backend.configuration.validate.message) {
    validateMessage(message);
  }
  const { type } = message;
  if (type === "start") {
    return processStartMessage(backend, message.track, message.configuration);
  } else if (type === "stop") {
    const { track: key } = message;
    if (key === null) {
      return toArray(backend.tracks.keys())
        .map((key) => processStopMessage(backend, key, message.termination))
        .every(identity);
    } else {
      return processStopMessage(backend, key, message.termination);
    }
  } else if (type === "source") {
    if (message.content === null) {
      logWarning("Ignoring file %j because it was empty", message.url);
    } else {
      const source = {
        url: message.url,
        content: message.content,
        hash: digest(message.content),
      };
      backend.sources.push(source);
      for (const track of backend.tracks.values()) {
        addTrackSource(track, source);
      }
    }
    return true;
  } else {
    for (const track of backend.tracks.values()) {
      sendTrack(track, message);
    }
    return true;
  }
};

const { URL, Set, String } = globalThis;

let global_running = false;

const validateUrl = (url = "file:///w:/missing-file-url.mjs") => {
  try {
    url = String(url);
    new URL(url);
    return url;
  } catch (error) {
    logError(
      "The second argument of appmap.recordScript is not a valid url, got: %j >> %O",
      url,
      error,
    );
    throw new ExternalAppmapError("Invalid url argument");
  }
};

/* c8 ignore start */
const readFile = (_url) => {
  throw new ExternalAppmapError("Recorder API does not support source map");
};
/* c8 ignore stop */

const expectRunning = (hooking) => {
  assert(
    !logErrorWhen(
      hooking === null,
      "This appmap instance has been terminated.",
    ),
    "Terminated appmap instance",
    ExternalAppmapError,
  );
};

const flush = (frontend, backend) => {
  for (const message of flushMessageArray(frontend)) {
    sendBackend(backend, message);
  }
};

class Appmap {
  constructor(home, conf, base) {
    assert(
      !logErrorWhen(
        global_running,
        "Two appmap instances cannot be active concurrently.",
      ),
      "Concurrent appmap instances",
      ExternalAppmapError,
    );
    const configuration = resolveConfigurationManualRecorder(
      extendConfiguration(
        {
          ...createConfiguration(toDirectoryUrl(home)),
          session: "singleton",
        },
        conf,
        toDirectoryUrl(base),
      ),
    );
    this.configuration = configuration;
    this.frontend = createFrontend(configuration);
    this.backend = createBackend(configuration);
    this.hooking = hook(this.frontend, configuration);
    this.tracks = new Set();
    global_running = true;
  }
  instrumentScript(content, url) {
    expectRunning(this.hooking);
    url = validateUrl(url);
    return instrument(this.frontend, url, String(content), readFile);
  }
  instrumentModule(content, url) {
    expectRunning(this.hooking);
    url = validateUrl(url);
    return instrument(this.frontend, url, String(content), readFile);
  }
  recordScript(content, url) {
    expectRunning(this.hooking);
    return runScript(this.instrumentScript(content, url));
  }
  startRecording(track, conf = {}, base = null) {
    expectRunning(this.hooking);
    if (track === null) {
      track = getUuid();
    }
    assert(
      !logErrorWhen(
        this.tracks.has(track),
        "Cannot start track %j because it already exists.",
        track,
      ),
      "Duplicate track name",
      ExternalAppmapError,
    );
    this.tracks.add(track);
    recordStartTrack(
      this.frontend,
      track,
      extendConfiguration(this.configuration, conf, base),
    );
    flush(this.frontend, this.backend);
    return track;
  }
  stopRecording(track, termination = { type: "manual" }) {
    expectRunning(this.hooking);
    assert(
      !logErrorWhen(
        !this.tracks.has(track),
        "Cannot stop track %j because it is missing.",
        track,
      ),
      "Missing track name",
      ExternalAppmapError,
    );
    this.tracks.delete(track);
    recordStopTrack(this.frontend, track, termination);
    flush(this.frontend, this.backend);
    return compileBackendTrack(this.backend, track).content;
  }
  terminate() {
    expectRunning(this.hooking);
    assert(
      global_running,
      "globally unregistered appmap instance",
      InternalAppmapError,
    );
    global_running = false;
    unhook(this.hooking);
    this.hooking = null;
  }
}

export { Appmap };
