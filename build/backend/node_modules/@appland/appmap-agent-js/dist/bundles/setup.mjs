import { readFile, writeFile, readdir } from 'node:fs/promises';
import { createRequire } from 'node:module';
import YAML from 'yaml';
import Semver from 'semver';
import Chalk from 'chalk';
import { URL as URL$4, pathToFileURL } from 'node:url';
import Treeify from 'treeify';
import AjvErrorTree from 'ajv-error-tree';
import { openSync, writeSync } from 'node:fs';
import prompts from 'prompts';
import { platform } from 'node:os';
import { win32, posix } from 'node:path';

const toAbsoluteUrl = (relative, base_url) =>
  new URL$4(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toDirectoryUrl = (url) => {
  const url_obj = new URL$4(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$3,
  JSON: { parse: parseJSON$1 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$1(
  await readFile(
    new URL$3(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$4 } = globalThis;

class AppmapError extends Error$4 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const { Error: Error$3 } = globalThis;

class AssertionError extends Error$3 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const {
  Boolean,
  String: String$1,
  Number,
  parseInt: parseInt$1,
  Array: { isArray },
  Number: {
    isNaN,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER,
    MIN_SAFE_INTEGER,
  },
  Math: { round },
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const print = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$1(any);
  } else {
    return String$1(any);
  }
};

const {
  Error: Error$2,
  String,
  JSON: { stringify: stringifyJSON },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON(value);
      }
      if (marker === "O") {
        try {
          return String(value);
        } catch {
          return print(value);
        }
      }
      if (marker === "o") {
        return print(value);
      }
      throw new Error$2("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const {
  Error: Error$1,
  Reflect: { apply },
  WeakMap,
} = globalThis;

new WeakMap();

const noop = () => {};
const constant = (x) => () => x;

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const {
  undefined: undefined$4,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2, ownKeys, defineProperty: defineProperty$1 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$2(Object$1, "hasOwn") === undefined$4
    ? (object, key) => getOwnPropertyDescriptor$2(object, key) !== undefined$4
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$3,
  ReferenceError,
  Reflect: { defineProperty },
} = globalThis;

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$2 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$2(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$2 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$2(fd, "DEBUG"),
    logInfo: generateLog$2(fd, "INFO"),
    logWarning: generateLog$2(fd, "WARNING"),
    logError: generateLog$2(fd, "ERROR"),
  };
};

const { logDebug, logInfo, logWarning, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog$1 = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

generateLog$1(
  "debug",
  logDebug,
);

generateLog$1(
  "info",
  logInfo,
);

generateLog$1(
  "warning",
  logWarning,
);

const { log: logError, logWhen: logErrorWhen } = generateLog$1(
  "error",
  logError$1,
);

const { URL: URL$1 } = globalThis;

const {
  validateSerial: validateAjvSerial,
  validatePayload: validateAjvPayload,
  validateExternalConfiguration: validateAjvExternalConfiguration,
  validateInternalConfiguration: validateAjvInternalConfiguration,
  validateMessage: validateAjvMessage,
  validateSourceMap: validateAjvSourceMap,
} = await import(new URL$1("dist/schema.mjs", self_directory));

const { asTree } = Treeify;

const generateValidate = (validateAjv, name, AppmapError) => (json) => {
  if (!validateAjv(json)) {
    const { errors } = validateAjv;
    const { length } = errors;
    assert(length > 0, "unexpected empty error array", InternalAppmapError);
    const tree1 = AjvErrorTree.structureAJVErrorArray(errors);
    const tree2 = AjvErrorTree.summarizeAJVErrorTree(tree1);
    logError(
      "invalid %s\n%s\n  Parameters = %j\n  Input = %j",
      name,
      typeof tree2 === "string" ? tree2 : asTree(tree2, true),
      errors.map((error) => coalesce(error, "params", null)),
      json,
    );
    throw new AppmapError("Failed to validate data against JSON schema");
  }
};

const validateExternalConfiguration = generateValidate(
  validateAjvExternalConfiguration,
  "user-defined configuration",
  ExternalAppmapError,
);

const {
  JSON: { parse: parseJSON },
  Number: { parseInt },
  Object: { assign, fromEntries },
} = globalThis;

// const generateMakeGlobSpecifier = (enabled) => (glob) => ({enabled, glob});
// const makeEnabledGlobSpecifier = generateMakeGlobSpecifier(true);
// const makeDisabledGlobSpecifier = generateMakeGlobSpecifier(false);

// Validate //

const generateValidatePort = (randomable) => (input) => {
  if (/^[0-9]+$/u.test(input)) {
    const port = parseInt(input);
    /* c8 ignore start */
    if (!randomable && port === 0) {
      return "Cannot assign a random port.";
    }
    if (port > 65535) {
      return "Port is out-of-range (the maximum port is 65535).";
    }
    /* c8 ignore stop */
  }
  return true;
};

// Parse //

const parsePossibleInteger = (input) =>
  /^[0-9]+$/u.test(input) ? parseInt(input) : input;

// Format //

const questions = [
  // Naming //
  constant({
    type: "text",
    name: "value",
    initial: "",
    message: [
      "What is the name of your app?",
      "Skip to let us pick a meaningful a name",
    ],
    format: (app_name) => (app_name === "" ? {} : { name: app_name }),
  }),
  // Recorder //
  constant({
    type: "select",
    name: "value",
    initial: 0,
    message: ["How appmaps should be generated?"],
    choices: [
      {
        title: "By recording processes",
        value: { recorder: "process" },
        description: [
          "Record node processes from start to finish.",
          "A single appmap will be generated per spawned node process.",
        ].join(" "),
      },
      {
        title: "By recording mocha test cases",
        value: { recorder: "mocha" },
        description: [
          "An appmap will be generated for each mocha test case.",
        ].join(" "),
      },
      {
        title: "By remote HTTP requests",
        value: { recorder: "remote" },
        description: [
          "Appmaps will be generated on demand via HTTP requests.",
          "These requests can be send via the record button in our editors plugins.",
          "VSCode: https://marketplace.visualstudio.com/items?itemName=appland.appmap.",
          "JetBrains: https://plugins.jetbrains.com/plugin/16701-appmap.",
        ].join(" "),
      },
      {
        title: "Manually",
        value: {
          recorder: "manual",
          hooks: { cjs: false, esm: false },
          packages: [{ regexp: "^", flags: "u", enabled: true }],
        },
        description: [
          "Appmaps will be generated by user-defined logics located in the recorded process.",
          "NB: To record functions applications, code should be given to: `appmap.recordScript(code, path)`.",
        ].join(" "),
      },
    ],
  }),
  // Scenario //
  ({ recorder }) =>
    recorder === "manual"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "What command should be executed and recorded when running `npx appmap-agent-js`?",
            "The command should be provided as a JSON array of strings.",
            'For instance: ["node", "path/to/main.js"]',
            "Skip to provide the command as positional argument.",
            "For instance: `npx appmap-agent-js -- node path/to/main.js",
          ],
          initial: "",
          format: (input) =>
            input === "" ? {} : { command: parseJSON(input) },
        },
  // Remote Recording //
  ({ recorder }) =>
    recorder !== "remote"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "On which primary port should the agent listen for remote recording requests?",
            "Either provide a port number or a path to a unix domain socket.",
            "Provide `0` to use a random available port.",
          ],
          initial: "0",
          validate: generateValidatePort(true),
          format: (input) => ({
            "track-port": parsePossibleInteger(input),
          }),
        },
  ({ recorder }) =>
    recorder !== "remote"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "On which secondary port should to agent intercept remote recording requests?",
            "The agent will expect the recorded application to deploy a HTTP server on that port.",
            "Either provide a port number or a path to a unix domain socket.",
            "Skip to disable this functionality.",
          ],
          initial: "",
          validate: generateValidatePort(false),
          format: (input) => ({
            "intercept-track-port": parsePossibleInteger(input),
          }),
        },
  // Storage //
  ({ recorder }) =>
    recorder !== "process" && recorder !== "mocha"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "Where should appmap files be written?",
            "Provide a relative path to a directory.",
          ],
          initial: "tmp/appmap",
          format: (directory) => ({ appmap_dir: directory }),
        },
  // Hooks //
  ({ recorder }) => ({
    type: "multiselect",
    name: "value",
    message: ["What are the things that you are interested into recording?"],
    instructions: false,
    choices: [
      {
        title: "Applications of functions located in CommonJS modules",
        value: "cjs",
        disabled: recorder === "manual",
        selected: recorder !== "manual",
      },
      {
        title: "Application of functions located in native modules",
        value: "esm",
        disabled: recorder === "manual",
        selected: recorder !== "manual",
      },
      {
        title: "HTTP/1.1 traffic (via node's builtin http package)",
        value: "http",
        disabled: false,
        selected: true,
      },
      {
        title: "MySQL queries (via mysql package)",
        value: "mysql",
        disabled: false,
        selected: false,
      },
      {
        title: "Postgres queries (via pg package)",
        value: "pg",
        disabled: false,
        selected: false,
      },
      {
        title: "SQLite3 queries (via sqlite3 package)",
        value: "sqlite3",
        disabled: false,
        selected: false,
      },
    ],
    format: (keys) => ({
      hooks: {
        esm: false,
        cjs: false,
        http: false,
        mysql: false,
        pg: false,
        sqlite3: false,
        ...fromEntries(keys.map((key) => [key, true])),
      },
    }),
  }),
  constant({
    type: "select",
    name: "value",
    message: ["How should events be ordered?"],
    initial: 0,
    choices: [
      {
        title: "Chronologically",
        value: { ordering: "chronological" },
        description: "Events will not be re-ordered.",
      },
      {
        title: "Causally",
        value: { ordering: "causal" },
        description: [
          "Events will be re-ordered based on causality links.",
          "For instance, asynchronous callbacks will (often) appear as nested calls rather than top-level calls.",
          "NB: This comes at the price of performance overhead",
        ].join(" "),
      },
    ],
  }),
  // Whitelisting //
  // ({ recorder }) =>
  //   recorder === "manual"
  //     ? null
  //     : {
  //         type: "list",
  //         name: "value",
  //         message: [
  //           "What are the node processes that should be recorded?",
  //           "Useful to prevent child node processes from being recorded.",
  //           "Whitelisting is based on the path of the entry script.",
  //           "Provide a coma-separated list of globs.",
  //         ],
  //         initial: "bin/*, test/*, test/**/*",
  //         separator: ",",
  //         format: (globs) => ({ processes: globs.map(makeGlobSpecifier) }),
  //       },
  // ({ recorder }) =>
  //   recorder === "manual"
  //     ? null
  //     : {
  //         type: "list",
  //         name: "value",
  //         message: [
  //           "What are the files that should be recorded?",
  //           "By default, every files inside the repository are recorded."
  //           "Safe for files within `node_modules` directories which are ignored."
  //           "Provide a coma-separated list of globs.",
  //         ],
  //         initial: "",
  //         separator: ",",
  //         format: (globs) => ({ packages: globs.map(makeEnabledGlobSpecifier) }),
  //       },
  // Pruning //
  ({ recorder }) => ({
    type: "toggle",
    name: "value",
    message: ["Should we include code that did not get executed in appmaps?"],
    initial: recorder !== "mocha",
    active: "yes",
    inactive: "no",
    format: (complete) => ({ pruning: !complete }),
  }),
  // Log //
  constant({
    type: "select",
    name: "value",
    message: ["What level of information should be logged?"],
    initial: 1,
    choices: [
      {
        title: "Debug",
        value: { log: "debug" },
      },
      {
        title: "Info",
        value: { log: "info" },
      },
      {
        title: "Warning",
        value: { log: "warning" },
      },
      {
        title: "Error",
        value: { log: "error" },
      },
      {
        title: "Off",
        value: { log: "off" },
      },
    ],
  }),
];

const questionConfigAsync = async () => {
  const config = {};
  for (const createPrompt of questions) {
    const prompt = createPrompt(config);
    if (prompt !== null) {
      const { message, ...rest } = prompt;
      const result = await prompts({
        message: `${
          message.length === 1 ? message[0] : message.join("\n  ")
        }\n`,
        ...rest,
      });
      if (hasOwnProperty(result, "value")) {
        assign(config, result.value);
      } else {
        break;
      }
    }
  }
  return config;
};

const {
  undefined: undefined$2,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1 },
  Error,
  Set,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$1(obj, key) !== undefined$2,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$1,
  Reflect: { getOwnPropertyDescriptor },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor(obj, key) !== undefined$1,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const getCwdPath = ({ cwd: getCwd }) => toDirectoryPath(getCwd());

const { URL } = globalThis;

const { satisfies: satisfiesSemver } = Semver;
const { green: chalkGreen, yellow: chalkYellow, red: chalkRed } = Chalk;
const { parse: parseYAML, stringify: stringifyYAML } = YAML;

const generateLog = (prefix, writable) => (message) => {
  writable.write(`${prefix} ${message}${"\n"}`);
};

const mainAsync = async (
  { version, cwd, env, stdout, stderr },
  testable_self_directory = self_directory,
) => {
  const logSuccess = generateLog(chalkGreen("\u2714"), stdout);
  const logWarning = generateLog(chalkYellow("\u26A0"), stderr);
  const logFailure = generateLog(chalkRed("\u2716"), stderr);
  const cwd_url = toDirectoryUrl(convertPathToFileUrl(cwd()));
  let conf_url = toAbsoluteUrl("appmap.yml", cwd_url);
  if (hasOwnProperty(env, "APPMAP_CONFIGURATION_PATH")) {
    conf_url = convertPathToFileUrl(
      toAbsolutePath(env.APPMAP_CONFIGURATION_PATH, getCwdPath({ cwd })),
    );
  }
  let repo_url = cwd_url;
  if (hasOwnProperty(env, "APPMAP_REPOSITORY_DIRECTORY")) {
    repo_url = toDirectoryUrl(
      convertPathToFileUrl(
        toAbsolutePath(env.APPMAP_REPOSITORY_DIRECTORY, getCwdPath({ cwd })),
      ),
    );
  }
  // node //
  if (!satisfiesSemver(version, self_package.engines.node)) {
    logFailure(
      `Node version ${version} is not compatible with ${self_package.engines.node}`,
    );
    return false;
  }
  logSuccess(`compatible node version: ${version}`);
  // configuration file //
  {
    let content;
    try {
      content = await readFile(new URL(conf_url), "utf8");
    } catch ({ code, message }) {
      /* c8 ignore start */
      if (code !== "ENOENT") {
        logFailure(`configuration file cannot be read: ${message}`);
        return false;
      }
      /* c8 ignore stop */
      if (
        !(
          await prompts({
            type: "toggle",
            name: "value",
            message:
              "Do you wish to answer several questions to help you create a configuration file?",
            initial: true,
            active: "yes",
            inactive: "no",
          })
        ).value
      ) {
        logFailure("missing configuration file");
        return false;
      }
      /* c8 ignore start */
      content = stringifyYAML(await questionConfigAsync());
      try {
        await writeFile(new URL(conf_url), content, "utf8");
      } catch ({ message }) {
        logFailure(`configuration file cannot not be written: ${message}`);
        return false;
      }
      /* c8 ignore stop */
    }
    logSuccess("configuration file exists");
    let config;
    try {
      config = parseYAML(content);
    } catch ({ message }) {
      logFailure(`configuration file is not valid YAML: ${message}`);
      return false;
    }
    logSuccess("configuration file is valid YAML");
    try {
      validateExternalConfiguration(config);
    } catch ({ message }) {
      logFailure(`configuration file is invalid: ${message}`);
      return false;
    }
    logSuccess("configuration file is valid");
  }
  // appmap-agent-js //
  {
    const { resolve } = createRequire(repo_url);
    let agent_main_path = null;
    try {
      agent_main_path = resolve("@appland/appmap-agent-js");
    } catch ({ message }) {
      logFailure(`cannot resolve appmap-agent-js module: ${message}`);
      return false;
    }
    const agent_main_url = convertPathToFileUrl(agent_main_path);
    const resolved_agent_url = toAbsoluteUrl("../../", agent_main_url);
    if (resolved_agent_url !== testable_self_directory) {
      logFailure(
        `agent location mismatch, expected agent to resolve to ${testable_self_directory} but got ${resolved_agent_url}`,
      );
      return false;
    }
    logSuccess("appmap-agent-js module is available");
  }
  // git repository //
  {
    let success = true;
    try {
      await readdir(new URL(toAbsoluteUrl(".git", repo_url)));
    } catch ({ message }) {
      success = false;
      logWarning(
        `current working directory does not appear to be a git repository: ${message}`,
      );
    }
    if (success) {
      logSuccess("current working directory appears to be a git repository");
    }
  }
  // package json file //
  {
    let success = true;
    try {
      await readFile(
        new URL(toAbsoluteUrl("package.json", repo_url)),
        "utf8",
      );
    } catch ({ code, message }) {
      success = false;
      if (code === "ENOENT") {
        logWarning(`missing package.json file`);
      } /* c8 ignore start */ else {
        logWarning(`cannot read package.json file: ${message}`);
      } /* c8 ignore stop */
    }
    if (success) {
      logSuccess("package.json file exists");
    }
  }
  // overall success //
  return true;
};

export { mainAsync };
