import process from 'node:process';
import { readFile as readFile$1 } from 'node:fs/promises';
import { URL as URL$4, pathToFileURL, fileURLToPath } from 'node:url';
import { openSync, writeSync, readFileSync } from 'node:fs';
import Minimatch from 'minimatch';
import { platform } from 'node:os';
import { win32, posix } from 'node:path';
import 'node:child_process';
import { performance } from 'node:perf_hooks';
import { executionAsyncId, createHook } from 'node:async_hooks';
import Module, { createRequire } from 'node:module';
import { Buffer as Buffer$1 } from 'node:buffer';
import { hooks, loadDefault, transformSourceDefault } from '../../lib/node/loader-esm.mjs';
import Http from 'node:http';
import Https from 'node:https';
import { Socket } from 'node:net';
import NetSocketMessaging from 'net-socket-messaging';

const toAbsoluteUrl = (relative, base_url) =>
  new URL$4(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toDirectoryUrl = (url) => {
  const url_obj = new URL$4(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$3,
  JSON: { parse: parseJSON$2 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$2(
  await readFile$1(
    new URL$3(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$6 } = globalThis;

class AppmapError extends Error$6 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const { Error: Error$5 } = globalThis;

class AssertionError extends Error$5 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const generateDeadcode = (message, Constructor) => () => {
  throw new Constructor(message);
};

const createBox = (value) => ({ value });
const getBox = ({ value }) => value;
const setBox = (box, value) => {
  box.value = value;
};

const {
  Boolean,
  String: String$3,
  Number,
  parseInt: parseInt$1,
  Array: { isArray: isArray$5 },
  Number: {
    isNaN: isNaN$1,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
    MIN_SAFE_INTEGER,
  },
  Math: { round: round$2 },
  JSON: { stringify: stringifyJSON$4 },
} = globalThis;

const toInteger = (any) => {
  if (typeof any === "boolean") {
    return Number(any);
  } else if (typeof any === "number") {
    if (any < MIN_SAFE_INTEGER) {
      return NEGATIVE_INFINITY;
    } else if (any > MAX_SAFE_INTEGER$1) {
      return POSITIVE_INFINITY;
    } else {
      return round$2(any);
    }
  } else if (typeof any === "bigint") {
    if (any < MIN_SAFE_INTEGER) {
      return NEGATIVE_INFINITY;
    } else if (any > MAX_SAFE_INTEGER$1) {
      return POSITIVE_INFINITY;
    } else {
      return Number(any);
    }
  } else if (typeof any === "string") {
    return parseInt$1(any);
  } else {
    return NaN$1;
  }
};

const toNumber = (any) => {
  if (typeof any === "boolean") {
    return any ? 1 : 0;
  } else if (typeof any === "number") {
    return any;
  } else if (typeof any === "bigint") {
    return Number(any);
  } else if (typeof any === "string") {
    return Number(any);
  } else {
    return NaN$1;
  }
};

const toString = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$5(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else {
    return String$3(any);
  }
};

const print$1 = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$5(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$4(any);
  } else {
    return String$3(any);
  }
};

const jsonifyNumber = (number, replacements) => {
  if (number === NEGATIVE_INFINITY) {
    return replacements.NEGATIVE_INFINITY;
  } else if (number === POSITIVE_INFINITY) {
    return replacements.POSITIVE_INFINITY;
  } else if (isNaN$1(number)) {
    return replacements.NaN;
  } else {
    return number;
  }
};

const {
  Error: Error$4,
  String: String$2,
  JSON: { stringify: stringifyJSON$3 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$3(value);
      }
      if (marker === "O") {
        try {
          return String$2(value);
        } catch {
          return print$1(value);
        }
      }
      if (marker === "o") {
        return print$1(value);
      }
      throw new Error$4("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const createCounter = (value) => ({ value });
const incrementCounter = (counter) => (counter.value += 1);

const {
  Error: Error$3,
  Reflect: { apply: apply$7 },
  WeakMap: WeakMap$1,
} = globalThis;

new WeakMap$1();

const noop = () => {};
const identity = (x) => x;

const spyOnce = (spy, forward) => {
  let called = false;
  return function (...args) {
    if (!called) {
      called = true;
      apply$7(spy, this, args);
    }
    return apply$7(forward, this, args);
  };
};

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const fromMaybe = (maybe, recovery, transform) =>
  maybe === null ? recovery : transform(maybe);

const {
  undefined: undefined$a,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$4, ownKeys: ownKeys$2, defineProperty: defineProperty$3 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$4(Object$1, "hasOwn") === undefined$a
    ? (object, key) => getOwnPropertyDescriptor$4(object, key) !== undefined$a
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const assignProperty = ({ object, key, value }) => {
  object[key] = value;
};

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$9,
  ReferenceError,
  Reflect: { defineProperty: defineProperty$2 },
} = globalThis;

const defineGlobal = (name, value, writable = false) => {
  if (!hasOwnProperty(globalThis, name)) {
    return defineProperty$2(globalThis, name, {
      __proto__: null,
      value,
      writable,
      configurable: false,
      enumerable: false,
    });
  } else {
    return false;
  }
};

const writeGlobal = (name, value) => {
  if (hasOwnProperty(globalThis, name)) {
    globalThis[name] = value;
    return undefined$9;
  } else {
    throw ReferenceError("missing global variable");
  }
};

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$2 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$2(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$1 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$1(fd, "DEBUG"),
    logInfo: generateLog$1(fd, "INFO"),
    logWarning: generateLog$1(fd, "WARNING"),
    logError: generateLog$1(fd, "ERROR"),
  };
};

const { logDebug: logDebug$1, logInfo: logInfo$1, logWarning: logWarning$1, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

const { log: logDebug, logWhen: logDebugWhen } = generateLog(
  "debug",
  logDebug$1,
);

const { log: logInfo, logWhen: logInfoWhen } = generateLog(
  "info",
  logInfo$1,
);

const { log: logWarning, logWhen: logWarningWhen } = generateLog(
  "warning",
  logWarning$1,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const {
  Date: { now: now$1 },
  Math: { random },
} = globalThis;

const getUuid = () =>
  `${now$1().toString(32).substr(-4)}${random().toString(32).substr(-4)}`;

const { Minimatch: MinimatchClass } = Minimatch;

const compileGlob = (glob) => new MinimatchClass(glob).makeRe();

const { Map: Map$4, RegExp: RegExp$1 } = globalThis;

new Map$4();

const escape = (char) => `\\${char}`;

const sanitizeForRegExp = (string) =>
  string.replace(/[/\\+*?.^$()[\]{}|]/gu, escape);

// const sanitizeForGlob = (string) => string.replace(/[*?[\]]/g, escape);

const toTargetRegExp = (target, recursive) => {
  if (recursive) {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}`;
    } else {
      return `^${sanitizeForRegExp(target)}(/|$)`;
    }
  } else {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}[^/]*$`;
    } else {
      return `^${sanitizeForRegExp(target)}$`;
    }
  }
};

const createMatcher = (options, base) => {
  const {
    glob,
    url,
    path,
    dist,
    regexp,
    flags,
    recursive,
    external,
    relative,
  } = {
    glob: null,
    path: null,
    url: null,
    dist: null,
    regexp: null,
    flags: "",
    recursive: true,
    external: false,
    relative: true,
    ...options,
  };
  if (regexp !== null) {
    return {
      base: relative ? base : null,
      source: regexp,
      flags,
    };
  }
  if (glob !== null) {
    const { source, flags } = compileGlob(glob);
    return {
      base,
      source,
      flags,
    };
  }
  if (path !== null) {
    return {
      base,
      source: toTargetRegExp(path, recursive),
      flags: "",
    };
  }
  if (url !== null) {
    return {
      base: null,
      source: toTargetRegExp(url, recursive),
      flags: "",
    };
  }
  if (dist !== null) {
    assert(
      dist[dist.length - 1] !== "/",
      "package path should not end with a path separator",
      InternalAppmapError,
    );
    let source = `node_modules/${sanitizeForRegExp(dist)}/`;
    if (!external) {
      source = `^${source}`;
    }
    if (!recursive) {
      source = `${source}[^/]*$`;
    }
    return {
      base,
      source,
      flags: "",
    };
  }
  throw new InternalAppmapError("invalid matcher options");
};

const {
  Array: { isArray: isArray$4 },
  Reflect: { ownKeys: ownKeys$1 },
  Object: { entries: toEntries$2 },
} = globalThis;

const HOOK_APPLY_GLOBAL = "APPMAP_HOOK_APPLY";

const HOOK_EVAL_GLOBAL = "APPMAP_HOOK_EVAL";

const EXPECTED_EXTRA_PROPERTIES = ["test_recording"];

////////////
// Extend //
////////////

const assign$1 = (value1, value2) => ({ ...value1, ...value2 });

const overwrite = (_value1, value2) => value2;

// const append = (value1, value2) => [...value1, ...value2];

const prepend = (value1, value2) => [...value2, ...value1];

const extendCommandOptions = (options1, options2) => ({
  ...options1,
  ...options2,
  env: {
    ...coalesce(options1, "env", {}),
    ...coalesce(options2, "env", {}),
  },
});

///////////////
// Normalize //
///////////////

const normalizeDefaultProcess = (default_process, _base) => {
  if (typeof default_process === "boolean") {
    return { enabled: default_process };
  } else {
    return {
      enabled: false,
      ...default_process,
    };
  }
};

const normalizeExclusion = (exclusion, _base) => {
  if (typeof exclusion === "string") {
    exclusion = {
      "qualified-name": exclusion,
      recursive: true,
    };
  }
  const default_value = coalesce(exclusion, "combinator", "and") === "and";
  return {
    combinator: "and",
    "qualified-name": default_value,
    name: default_value,
    "every-label": default_value,
    "some-label": default_value,
    excluded: true,
    recursive: false,
    ...exclusion,
  };
};

const normalizeCommandOptions = (options, base) => ({
  shell: false,
  encoding: "utf8",
  env: {},
  stdio: "inherit",
  timeout: 0,
  killSignal: "SIGTERM",
  ...options,
  cwd: hasOwnProperty(options, "cwd")
    ? toDirectoryUrl(toAbsoluteUrl(options.cwd, base))
    : toAbsoluteUrl(".", base),
});

const normalizeHooks = (hooks, _base) => {
  if (hasOwnProperty(hooks, "eval")) {
    hooks.eval =
      typeof hooks.eval === "boolean"
        ? {
            hidden: HOOK_EVAL_GLOBAL,
            aliases: hooks.eval ? ["eval"] : [],
          }
        : hooks.eval;
  }
  if (hasOwnProperty(hooks, "apply")) {
    hooks.apply =
      typeof hooks.apply === "boolean"
        ? hooks.apply
          ? HOOK_APPLY_GLOBAL
          : null
        : hooks.apply;
  }
  return hooks;
};

const normalizeDefaultPackage = (package_, _base) => {
  if (typeof package_ === "boolean") {
    package_ = { enabled: package_ };
  }
  return {
    enabled: true,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
    ...package_,
  };
};

const normalizeAgent = ({ directory, package: _package }, base) => ({
  directory: toDirectoryUrl(toAbsoluteUrl(directory, base)),
  package: _package,
});

const normalizeDirectoryUrl = (url, base) =>
  toDirectoryUrl(toAbsoluteUrl(url, base));

const normalizeExclude = (exclusions, _base) =>
  exclusions.map(normalizeExclusion);

const normalizeCommand = (command, _base) => ({
  source: typeof command === "string" ? command : null,
  tokens: typeof command === "string" ? null : command,
});

const normalizeScenarios = (scenarios, base) =>
  toEntries$2(scenarios).map(([key, value]) => ({
    base,
    key,
    value,
  }));

const normalizeLog = (log, base) => {
  if (typeof log === "string") {
    log = { level: log };
  }
  if (hasOwnProperty(log, "file") && typeof log.file !== "number") {
    log.file = toAbsoluteUrl(log.file, base);
  }
  return log;
};

const normalizePort = (port, base) => {
  if (typeof port === "string" && port !== "") {
    port = toAbsoluteUrl(port, base);
  }
  return port;
};

const generateNormalizeSplit = (separator, key1, key2) => (value) => {
  if (typeof value === "string") {
    const segments = value.split(separator);
    return {
      [key1]: segments[0],
      [key2]: segments.length === 1 ? null : segments[1],
    };
  }
  return value;
};

const normalizeRecording = generateNormalizeSplit(
  ".",
  "defined-class",
  "method-id",
);

const normalizeFramework = generateNormalizeSplit("@", "name", "version");

const normalizeFrameworkArray = (frameworks) =>
  frameworks.map(normalizeFramework);

const normalizePackageMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const {
    enabled,
    shallow,
    "inline-source": inline_source,
    exclude,
    "source-type": source_type,
    parsing,
    ...rest
  } = {
    enabled: true,
    "inline-source": null,
    shallow: hasOwnProperty(matcher, "dist"),
    exclude: [],
    "source-type": null,
    parsing: null,
    ...matcher,
  };
  return [
    createMatcher(rest, base),
    {
      enabled,
      "inline-source": inline_source,
      shallow,
      exclude: exclude.map(normalizeExclusion),
      "source-type": source_type,
      parsing,
    },
  ];
};

const normalizePackageMatcherArray = (matchers, base) => {
  if (!isArray$4(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizePackageMatcher(matcher, base));
};

const normalizeProcessMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const { enabled, ...rest } = {
    enabled: true,
    ...matcher,
  };
  return [createMatcher(rest, base), { enabled }];
};

const normalizeProcesseMatcherArray = (matchers, base) => {
  if (!isArray$4(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizeProcessMatcher(matcher, base));
};

////////////
// fields //
////////////

const fields = {
  socket: {
    extend: overwrite,
    normalize: identity,
  },
  heartbeat: {
    extend: overwrite,
    normalize: identity,
  },
  threshold: {
    extend: overwrite,
    normalize: identity,
  },
  agent: {
    extend: overwrite,
    normalize: normalizeAgent,
  },
  repository: {
    extend: overwrite,
    normalize: identity,
  },
  scenario: {
    extend: overwrite,
    normalize: identity,
  },
  scenarios: {
    extend: overwrite,
    normalize: normalizeScenarios,
  },
  "recursive-process-recording": {
    extend: overwrite,
    normalize: identity,
  },
  "postmortem-function-exclusion": {
    extend: overwrite,
    normalize: identity,
  },
  command: {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-win32": {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-options": {
    extend: extendCommandOptions,
    normalize: normalizeCommandOptions,
  },
  validate: {
    extend: assign$1,
    normalize: identity,
  },
  log: {
    extend: assign$1,
    normalize: normalizeLog,
  },
  host: {
    extend: overwrite,
    normalize: identity,
  },
  session: {
    extend: overwrite,
    normalize: identity,
  },
  sessions: {
    extend: overwrite,
    normalize: identity,
  },
  "proxy-port": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "http-switch": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "track-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-port": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  enabled: {
    extend: overwrite,
    normalize: identity,
  },
  "default-process": {
    extend: overwrite,
    normalize: normalizeDefaultProcess,
  },
  processes: {
    extend: prepend,
    normalize: normalizeProcesseMatcherArray,
  },
  recorder: {
    extend: overwrite,
    normalize: identity,
  },
  "inline-source": {
    extend: overwrite,
    normalize: identity,
  },
  hooks: {
    extend: assign$1,
    normalize: normalizeHooks,
  },
  ordering: {
    extend: overwrite,
    normalize: identity,
  },
  "collapse-package-hierachy": {
    extend: overwrite,
    normalize: identity,
  },
  serialization: {
    extend: assign$1,
    normalize: identity,
  },
  main: {
    extend: overwrite,
    normalize: toAbsoluteUrl,
  },
  language: {
    extend: overwrite,
    normalize: identity,
  },
  engine: {
    extend: overwrite,
    normalize: identity,
  },
  "default-package": {
    extend: overwrite,
    normalize: normalizeDefaultPackage,
  },
  packages: {
    extend: prepend,
    normalize: normalizePackageMatcherArray,
  },
  exclude: {
    extend: prepend,
    normalize: normalizeExclude,
  },
  recording: {
    extend: overwrite,
    normalize: normalizeRecording,
  },
  appmap_dir: {
    extend: overwrite,
    normalize: normalizeDirectoryUrl,
  },
  appmap_file: {
    extend: overwrite,
    normalize: identity,
  },
  name: {
    extend: overwrite,
    normalize: identity,
  },
  "map-name": {
    extend: overwrite,
    normalize: identity,
  },
  pruning: {
    extend: overwrite,
    normalize: identity,
  },
  labels: {
    extend: prepend,
    normalize: identity,
  },
  feature: {
    extend: overwrite,
    normalize: identity,
    initial: null,
  },
  "feature-group": {
    extend: overwrite,
    normalize: identity,
  },
  frameworks: {
    extend: prepend,
    normalize: normalizeFrameworkArray,
  },
};

const extendConfiguration = (
  internal_configuration,
  external_configuration,
  base,
) => {
  const extended_internal_configuration = { ...internal_configuration };
  for (const key of ownKeys$1(external_configuration)) {
    if (hasOwnProperty(fields, key)) {
      const { normalize, extend } = fields[key];
      extended_internal_configuration[key] = extend(
        extended_internal_configuration[key],
        normalize(external_configuration[key], base),
      );
    } else {
      logInfoWhen(
        !EXPECTED_EXTRA_PROPERTIES.includes(key),
        "Configuration property not recognized by the agent: %j",
        key,
      );
    }
  }
  return extended_internal_configuration;
};

const {
  undefined: undefined$8,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$3 },
  Error: Error$2,
  Set: Set$3,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$3(obj, key) !== undefined$8,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set$3([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error$2("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$7,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2 },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor$2(obj, key) !== undefined$7,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const extendConfigurationNode = (
  configuration,
  { version, argv, cwd },
) => {
  assert(argv.length >= 2, "expected at least two argv", InternalAppmapError);
  const [, main] = argv;
  assert(
    version.startsWith("v"),
    "expected version to start with v",
    InternalAppmapError,
  );
  return {
    ...configuration,
    engine: `node@${version.substring(1)}`,
    main: convertPathToFileUrl(toAbsolutePath(main, toDirectoryPath(cwd()))),
  };
};

const instrument$1 = generateDeadcode(
  "forbidden call to instrument",
  InternalAppmapError,
);

const extractMissingUrlArray = generateDeadcode(
  "forbidden call to extractMissingUrlArray",
  InternalAppmapError,
);

const { Map: Map$3 } = globalThis;

const readFileSafe = (url, readFile) => {
  try {
    return readFile(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const readFileSafeAsync = async (url, readFileAsync) => {
  try {
    return await readFileAsync(url);
  } catch (error) {
    logWarning("Could not read file %j >> %O", url, error);
    return null;
  }
};

const instrumentInject = (url, content, configuration, readFile) => {
  const cache = new Map$3(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, readFileSafe(url, readFile));
      }
    }
  }
};

const instrumentInjectAsync = async (
  url,
  content,
  configuration,
  readFileAsync,
) => {
  const cache = new Map$3(content === null ? [] : [[url, content]]);
  while (true) {
    const urls = extractMissingUrlArray(url, cache, configuration);
    if (urls.length === 0) {
      return instrument$1(url, cache, configuration);
    } else {
      for (const url of urls) {
        cache.set(url, await readFileSafeAsync(url, readFileAsync));
      }
    }
  }
};

const {
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getPrototypeOf: getPrototypeOf$1, ownKeys },
  Error: { prototype: error_prototype },
  Infinity,
  Symbol,
  Symbol: { keyFor, for: symbolFor },
  WeakMap,
  Map: Map$2,
  Set: Set$2,
  String: String$1,
  undefined: undefined$6,
  Math: { min },
  Object: { prototype: object_prototype, fromEntries: fromEntries$2 },
  Array: { isArray: isArray$3 },
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const empty = symbolFor("APPMAP_EMPTY_MARKER");

const isSymbol = (any) => typeof any === "symbol";

const isString = (any) => typeof any === "string";

const wellknown = new Set$2(
  ownKeys(Symbol)
    .map((key) => Symbol[key])
    .filter(isSymbol),
);

////////////////////
// Reflect Helper //
////////////////////
const getOwnKeyArrayImpure = (object) => {
  try {
    return ownKeys(object);
  } catch (error) {
    logDebug(
      "Reflect.ownKeys(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return [];
  }
};
const getPrototypeImpure = (object) => {
  try {
    return getPrototypeOf$1(object);
  } catch (error) {
    logDebug(
      "Reflect.getPrototypeOf(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return null;
  }
};
const getOwnPropertyDescriptorImpure = (object, key) => {
  try {
    return getOwnPropertyDescriptor$1(object, key);
  } catch (error) {
    logDebug(
      "Reflect.getOwnPropertyDescriptor(%o, %j) threw %O (this should only happen when the object is a proxy)",
      object,
      key,
      error,
    );
    return undefined$6;
  }
};
const hasPrototypeImpure = (object, prototype) => {
  while (object !== null) {
    if (object === prototype) {
      return true;
    }
    object = getPrototypeImpure(object);
  }
  return false;
};
const getDataPropertyImpure = (object, key) => {
  while (object !== null) {
    const descriptor = getOwnPropertyDescriptorImpure(object, key);
    if (descriptor !== undefined$6 && hasOwnProperty(descriptor, "value")) {
      return descriptor.value;
    }
    object = getPrototypeImpure(object);
  }
  return undefined$6;
};
const toStringImpure = (object) => {
  try {
    return object.toString();
  } catch (error) {
    logDebug("%o.toString() failure >> %O", object, error);
    return undefined$6;
  }
};
///////////
// Index //
///////////
const generateGetIndex =
  (name) =>
  ({ [name]: map, counter }, value) => {
    const index = map.get(value);
    if (index !== undefined$6) {
      return index;
    } else {
      const new_index = incrementCounter(counter);
      map.set(value, new_index);
      return new_index;
    }
  };
const getSymbolIndex = generateGetIndex("symbols");
const getReferenceIndex = generateGetIndex("references");
////////////////////////
// getConstructorName //
////////////////////////
const getConstructorName = ({ impure_constructor_naming }, object) => {
  if (impure_constructor_naming) {
    const _constructor = getDataPropertyImpure(object, "constructor");
    if (typeof _constructor === "function") {
      const name = getDataPropertyImpure(_constructor, "name");
      logDebugWhen(
        typeof name !== "string",
        "Constructor name of %o is not a string: %o",
        object,
        name,
      );
      return typeof name === "string" ? name : typeof object;
    } else {
      return typeof object;
    }
  } else {
    return typeof object;
  }
};
///////////////
// stringify //
///////////////
const generatePrint =
  (printString) =>
  ({ impure_printing }, any) => {
    if (
      any === null ||
      any === undefined$6 ||
      typeof any === "boolean" ||
      typeof any === "number"
    ) {
      return String$1(any);
    } else if (typeof any === "string") {
      return printString(any);
    } else if (typeof any === "bigint") {
      return `${String$1(any)}n`;
    } else if (typeof any === "symbol") {
      if (wellknown.has(any)) {
        return `well-known ${String$1(any)}`;
      } else if (keyFor(any) !== undefined$6) {
        return `global ${String$1(any)}`;
      } else {
        return String$1(any);
      }
    } else if (typeof any === "function") {
      if (impure_printing) {
        const name = getDataPropertyImpure(any, "name");
        if (getOwnPropertyDescriptorImpure(any, "prototype") !== undefined$6) {
          if (typeof name === "string" && name !== "") {
            return `function ${name} (...) { ... }`;
          } else {
            return `function (...) { ... }`;
          }
        } else {
          if (typeof name === "string" && name !== "") {
            return `${name} = (...) => { ... }`;
          } else {
            return `(...) => { ... }`;
          }
        }
      } else {
        return "function";
      }
    } else if (typeof any === "object") {
      if (impure_printing) {
        const representation = toStringImpure(any);
        logDebugWhen(
          typeof representation !== "string",
          "%o.toString() did not return a string, got: %o",
          any,
          representation,
        );
        return typeof representation === "string" ? representation : "object";
      } else {
        return "object";
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("unknown type");
    } /* c8 ignore stop */
  };
const print = generatePrint(stringifyJSON$2);
const show = generatePrint(identity);
//////////////////
// getSpecific  //
//////////////////
const getSpecific = (serialization, object) => {
  if (
    serialization.impure_error_inspection &&
    hasPrototypeImpure(object, error_prototype)
  ) {
    return {
      type: "error",
      name: show(serialization, getDataPropertyImpure(object, "name")),
      message: show(serialization, getDataPropertyImpure(object, "message")),
      stack: show(serialization, getDataPropertyImpure(object, "stack")),
    };
  } else if (serialization.impure_array_inspection && isArray$3(object)) {
    // Proxies cannot change array's length so we know it will be a number.
    return { type: "array", length: getDataPropertyImpure(object, "length") };
  } else if (
    serialization.impure_hash_inspection &&
    (getPrototypeImpure(object) === null ||
      getPrototypeImpure(object) === object_prototype)
  ) {
    const keys = getOwnKeyArrayImpure(object).filter(isString);
    const entries = [];
    const length = min(keys.length, serialization.maximum_properties_length);
    for (let index = 0; index < length; index += 1) {
      const key = keys[index];
      entries.push([key, typeof getDataPropertyImpure(object, key)]);
    }
    return {
      type: "hash",
      length,
      properties: fromEntries$2(entries),
    };
  } else {
    return null;
  }
};
const serializeNonEmpty = (serialization, value) => {
  const type = value === null ? "null" : typeof value;
  const representation = print(serialization, value);
  if (
    type === "null" ||
    type === "undefined" ||
    type === "boolean" ||
    type === "number" ||
    type === "string" ||
    type === "bigint"
  ) {
    return { type, print: representation };
  } else if (type === "symbol") {
    return {
      type,
      print: representation,
      index: getSymbolIndex(serialization, value),
    };
  } else {
    return {
      type,
      print: representation,
      index: getReferenceIndex(serialization, value),
      constructor: getConstructorName(serialization, value),
      specific: getSpecific(serialization, value),
    };
  }
};

const createSerialization = ({
  serialization: {
    "maximum-print-length": maximum_print_length,
    "maximum-properties-length": maximum_properties_length,
    "impure-printing": impure_printing,
    "impure-constructor-naming": impure_constructor_naming,
    "impure-array-inspection": impure_array_inspection,
    "impure-error-inspection": impure_error_inspection,
    "impure-hash-inspection": impure_hash_inspection,
  },
}) => ({
  counter: createCounter(0),
  empty,
  symbols: new Map$2(),
  references: new WeakMap(),
  maximum_print_length:
    maximum_print_length === null ? Infinity : maximum_print_length,
  maximum_properties_length,
  impure_printing,
  impure_constructor_naming,
  impure_array_inspection,
  impure_error_inspection,
  impure_hash_inspection,
});

const getSerializationEmptyValue$1 = ({ empty }) => empty;

const serialize$1 = (serialization, value) => {
  if (value === serialization.empty) {
    return null;
  } else {
    const serial = serializeNonEmpty(serialization, value);
    if (serial.print.length > serialization.maximum_print_length) {
      return {
        ...serial,
        print: `${serial.print.substring(
          0,
          serialization.maximum_print_length - 4,
        )} ...`,
      };
    } else {
      return serial;
    }
  }
};

const START = "TR?";
const STOP = "TR!";
const ERROR = "ERR";
const SOURCE = "SRC";
const BEGIN_REQUEST_AMEND = "RQ.";

const SESSION_ASSIGNMENT = "SE!";

const GROUP_DEFINITION = "GR?";
const GROUP_ASSIGNMENT = "GR!";

const BEGIN_BUNDLE_EVENT = "BD>";
const END_BUNDLE_EVENT = "BD<";

const BEFORE_JUMP_EVENT = "JP?";
const AFTER_JUMP_EVENT = "JP!";

const BEGIN_APPLY_EVENT = "APP";
const END_RETURN_EVENT = "RET";
const END_THROW_EVENT = "TRW";

const BEFORE_AWAIT_EVENT = "AWT";
const BEFORE_YIELD_EVENT = "YLD";
const AFTER_RESOLVE_EVENT = "RES";
const AFTER_REJECT_EVENT = "REJ";

const BEGIN_REQUEST_EVENT = "RQ>";
const END_RESPONSE_EVENT = "RS<";
const BEFORE_REQUEST_EVENT = "RQ?";
const AFTER_RESPONSE_EVENT = "RS!";

const BEFORE_QUERY_EVENT = "QRY";
const AFTER_ANSWER_EVENT = "ASW";

const {
  Array: { isArray: isArray$2, from: toArray$2 },
  Object: { fromEntries: fromEntries$1, entries: toEntries$1 },
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const serialize = (serialization, enabled, value) => {
  enabled.value = false;
  try {
    return serialize$1(serialization, value);
  } finally {
    enabled.value = true;
  }
};

const updateGroup = (buffer, old_group, new_group) => {
  if (old_group.value !== new_group) {
    buffer.push([GROUP_ASSIGNMENT, new_group]);
    old_group.value = new_group;
  }
};

const initializeBuffer = (buffer, session, { value: group }) => {
  buffer.push([SESSION_ASSIGNMENT, session], [GROUP_ASSIGNMENT, group]);
};

const createFrontend = (configuration) => {
  const { session } = configuration;
  assert(session !== null, "missing session", InternalAppmapError);
  const buffer = [];
  initializeBuffer(buffer, session, { value: 0 });
  return {
    enabled: { value: true },
    buffer,
    counter: createCounter(0),
    session,
    old_group: { value: 0 },
    serialization: createSerialization(configuration),
    configuration,
  };
};

const flushContent = ({ buffer, session, old_group }) => {
  if (buffer.length === 2) {
    return null;
  } else {
    const content = stringifyJSON$1(buffer);
    buffer.length = 0;
    initializeBuffer(buffer, session, old_group);
    return content;
  }
};
/* c8 ignore stop */

const getFreshTab = ({ counter }) => incrementCounter(counter);

const getSerializationEmptyValue = ({ serialization }) =>
  getSerializationEmptyValue$1(serialization);

const instrument = (
  { enabled, buffer, configuration },
  url,
  content,
  readFile,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } = instrumentInject(
      url,
      content,
      configuration,
      readFile,
    );
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const instrumentAsync = async (
  { enabled, buffer, configuration },
  url,
  content,
  readFileAsync,
) => {
  if (enabled.value) {
    const { sources, content: instrumented_content } =
      await instrumentInjectAsync(url, content, configuration, readFileAsync);
    for (const { url, content } of sources) {
      buffer.push([SOURCE, url, content]);
    }
    return instrumented_content;
  } /* c8 ignore start */ else {
    return content;
  } /* c8 ignore stop */
};

const recordError = ({ enabled, buffer, serialization }, error) => {
  if (enabled.value) {
    buffer.push([ERROR, serialize(serialization, enabled, error)]);
  }
};

const recordStartTrack = ({ enabled, buffer }, track, configuration) => {
  if (enabled.value) {
    buffer.push([START, track, configuration]);
  }
};

const recordStopTrack = ({ enabled, buffer }, track, termination) => {
  if (enabled.value) {
    buffer.push([STOP, track, termination]);
  }
};

const recordGroup = ({ enabled, buffer }, group, child, description) => {
  if (enabled.value) {
    buffer.push([GROUP_DEFINITION, group, child, description]);
  }
};

// jump && bundle //

const compileRecordEmpty =
  (head) =>
  ({ enabled, buffer, old_group }, tab, group, time) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([head, tab, time]);
    }
  };

const recordBeforeJumpEvent = compileRecordEmpty(BEFORE_JUMP_EVENT);

const recordAfterJumpEvent = compileRecordEmpty(AFTER_JUMP_EVENT);

const recordBeginBundleEvent = compileRecordEmpty(BEGIN_BUNDLE_EVENT);

const recordEndBundleEvent = compileRecordEmpty(END_BUNDLE_EVENT);

// function //

const recordBeginApplyEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  this_,
  arguments_,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEGIN_APPLY_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, this_),
      arguments_.map((argument) => serialize(serialization, enabled, argument)),
    ]);
  }
};

const recordEndReturnEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_RETURN_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordEndThrowEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_THROW_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, error),
    ]);
  }
};

// promise && iterator //

const recordBeforeAwaitEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  promise,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_AWAIT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, promise),
    ]);
  }
};

const recordBeforeYieldEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  iterator,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_YIELD_EVENT,
      tab,
      time,
      serialize(serialization, enabled, iterator),
    ]);
  }
};

const recordAfterResolveEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_RESOLVE_EVENT,
      tab,
      time,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordAfterRejectEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_REJECT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, error),
    ]);
  }
};

// client && server //

const compileRecordRequest =
  (head) =>
  (
    { enabled, buffer, serialization, old_group },
    tab,
    group,
    time,
    protocol,
    method,
    url,
    route,
    headers,
    body,
  ) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([
        head,
        tab,
        time,
        protocol,
        method,
        url,
        route,
        headers,
        serialize(serialization, enabled, body),
      ]);
    }
  };

const compileRecordResponse =
  (head) =>
  (
    { enabled, buffer, serialization, old_group },
    tab,
    group,
    time,
    status,
    message,
    headers,
    body,
  ) => {
    if (enabled.value) {
      updateGroup(buffer, old_group, group);
      buffer.push([
        head,
        tab,
        time,
        status,
        message,
        headers,
        serialize(serialization, enabled, body),
      ]);
    }
  };

const recordBeforeRequestEvent =
  compileRecordRequest(BEFORE_REQUEST_EVENT);

const recordAfterResponseEvent =
  compileRecordResponse(AFTER_RESPONSE_EVENT);

const recordBeginRequestEvent =
  compileRecordRequest(BEGIN_REQUEST_EVENT);

const recordBeginRequestAmend = (
  { enabled, buffer, serialization },
  tab,
  protocol,
  method,
  url,
  route,
  headers,
  body,
) => {
  if (enabled.value) {
    buffer.push([
      BEGIN_REQUEST_AMEND,
      tab,
      protocol,
      method,
      url,
      route,
      headers,
      serialize(serialization, enabled, body),
    ]);
  }
};

const recordEndResponseEvent = compileRecordResponse(END_RESPONSE_EVENT);

// database //

const recordBeforeQueryEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  database,
  version,
  sql,
  parameters,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_QUERY_EVENT,
      tab,
      time,
      database,
      version,
      sql,
      isArray$2(parameters)
        ? parameters.map((parameter) =>
            serialize(serialization, enabled, parameter),
          )
        : fromEntries$1(
            toArray$2(toEntries$1(parameters)).map(([name, parameter]) => [
              name,
              serialize(serialization, enabled, parameter),
            ]),
          ),
    ]);
  }
};

const recordAfterAnswerEvent = compileRecordEmpty(AFTER_ANSWER_EVENT);

const {
  Math: { round: round$1 },
} = globalThis;

const now = () => round$1(1000 * performance.now()) / 1000;

const unhook$e = (backup) => {
  backup.forEach(assignProperty);
};

const hook$e = (frontend, { hooks: { apply: apply_hook_variable } }) => {
  if (apply_hook_variable === null) {
    return [];
  } else {
    const runtime = {
      empty: getSerializationEmptyValue(frontend),
      getFreshTab: () => getFreshTab(frontend),
      recordApply: (tab, function_, this_, arguments_) => {
        recordBeginApplyEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          function_,
          this_,
          arguments_,
        );
      },
      recordReturn: (tab, function_, result) => {
        recordEndReturnEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          function_,
          result,
        );
      },
      recordThrow: (tab, function_, error) => {
        recordEndThrowEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          function_,
          error,
        );
      },
      recordAwait: (tab, promise) => {
        recordBeforeAwaitEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          promise,
        );
      },
      recordYield: (tab, iterator) => {
        recordBeforeYieldEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          iterator,
        );
      },
      recordResolve: (tab, result) => {
        recordAfterResolveEvent(
          frontend,
          tab,
          executionAsyncId(),
          now(),
          result,
        );
      },
      recordReject: (tab, error) => {
        recordAfterRejectEvent(frontend, tab, executionAsyncId(), now(), error);
      },
    };
    assert(
      defineGlobal(apply_hook_variable, runtime),
      "global apply hook variable already defined",
      InternalAppmapError,
    );
    return [
      "getFreshTab",
      "recordApply",
      "recordReturn",
      "recordThrow",
      "recordAwait",
      "recordResolve",
      "recordReject",
      "recordYield",
    ].map((key) => ({
      object: runtime,
      key,
      value: noop,
    }));
  }
};

var HookApply = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$e,
  hook: hook$e
});

const {
  Set: Set$1,
  Number: { isInteger, MAX_SAFE_INTEGER },
} = globalThis;

// NB: current execution id when called from C++ is 0
const isGroup = (group) =>
  isInteger(group) && group >= 0 && group < MAX_SAFE_INTEGER;

const hook$d = (frontend, { ordering }) => {
  if (ordering !== "causal") {
    return null;
  } else {
    const groups = new Set$1();
    const hook = createHook({
      init: (id, description, origin) => {
        if (isGroup(id) && isGroup(origin)) {
          // In the presence of a debugger, the init hook may be called multiple times for the same asyncId.
          // However, the asyncId is guaranteed to be unique so we should be able to safely ignore it if it's
          // already been seen.
          if (!groups.has(id)) {
            groups.add(id);
            recordGroup(frontend, origin, id, toString(description));
          }
        } /* c8 ignore start */ else {
          logWarning("Invalid group id for id = %o or origin = %o", id, origin);
        } /* c8 ignore stop */
      },
    });
    hook.enable();
    return hook;
  }
};

const unhook$d = (hook) => {
  if (hook !== null) {
    hook.disable();
  }
};

var HookGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$d,
  unhook: unhook$d
});

const { Error: Error$1, decodeURIComponent, URL: URL$1 } = globalThis;

const { from: toBuffer$3 } = Buffer$1;

const splitDataPath = (path) => {
  const index = path.indexOf(",");
  return {
    head: path.substring(0, index),
    body: path.substring(index + 1),
  };
};

const generateReadFile = (readFile) => (url) => {
  const url_obj = new URL$1(url);
  if (url_obj.protocol === "file:") {
    return readFile(url_obj, "utf8");
  } else if (url_obj.protocol === "data:") {
    const { head, body } = splitDataPath(url_obj.pathname);
    if (head.endsWith(";base64")) {
      logDebugWhen(
        !head.toLowerCase().includes(";charset=utf-8;") &&
          !head.toLowerCase().includes(";charset=utf8;"),
        "Data url is encoded as base64 and does not declare UTF-8 as its character encoding, will try to use UTF-8 anyway >> %s",
        url,
      );
      return toBuffer$3(body, "base64").toString("utf8");
    } else {
      return decodeURIComponent(body);
    }
  } else {
    // This file is meant to be used at the same
    //   abstraction level as a node library.
    // Hence, this is delibearately left as an unknown error.
    // ie: not an External/Internal AppmapError.
    throw new Error$1("unsupported protocol");
  }
};

const readFile = generateReadFile(readFileSync);

const readFileAsync = generateReadFile(readFile$1);

const {
  Reflect: { apply: apply$6 },
} = globalThis;

const { prototype } = Module;

const unhook$c = (backup) => {
  backup.forEach(assignProperty);
};

const hook$c = (frontend, { hooks: { cjs } }) => {
  if (!cjs) {
    return [];
  } else {
    const { _compile: original } = prototype;
    prototype._compile = function _compile(content, path) {
      return apply$6(original, this, [
        instrument(
          frontend,
          convertPathToFileUrl(toString(path)),
          content,
          readFile,
        ),
        path,
      ]);
    };
    return [{ object: prototype, key: "_compile", value: original }];
  }
};

const {
  Buffer,
  Buffer: { from: toBuffer$2 },
  ArrayBuffer,
  SharedArrayBuffer,
  Uint8Array,
} = globalThis;

const stringifyContent = (content) => {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof Uint8Array) {
    content = content.buffer;
  }
  if (content instanceof SharedArrayBuffer || content instanceof ArrayBuffer) {
    content = toBuffer$2(content);
  }
  if (content instanceof Buffer) {
    // We assume utf8 encoding as node does:
    // https://github.com/nodejs/node/blob/c200106305f4367ba9ad8987af5139979c6cc40c/lib/internal/modules/cjs/loader.js#L1136
    //
    // Module._extensions['.js'] = function(module, filename) {
    //   // If already analyzed the source, then it will be cached.
    //   const cached = cjsParseCache.get(module);
    //   let content;
    //   if (cached?.source) {
    //     content = cached.source;
    //     cached.source = undefined;
    //   } else {
    //     content = fs.readFileSync(filename, 'utf8');
    //   }
    return content.toString("utf8");
  } else {
    logError(
      "Expected module content to be either: a string, a UintArray, a ArrayBuffer, a SharedArrayBuffer, or a Buffer. Got: %o",
      content,
    );
    throw new ExternalAppmapError("Invalid module content");
  }
};

/* eslint-disable no-import-assign */

let hooked = false;

const unhook$b = (esm) => {
  if (esm) {
    assert(hooked, "esm not yet hooked", InternalAppmapError);
    hooks.load = loadDefault;
    hooks.transformSourceDefault = transformSourceDefault;
    hooked = false;
  }
};

const hook$b = (frontend, { hooks: { esm } }) => {
  if (esm) {
    assert(!hooked, "esm already hooked", InternalAppmapError);
    hooked = esm;
    const transformModuleAsync = async (url, format, content) => {
      // We do not want to intrument commonjs here
      // because cjs has its own hook mechanism.
      if (format === "module") {
        return await instrumentAsync(
          frontend,
          url,
          stringifyContent(content),
          readFileAsync,
        );
      } else {
        return content;
      }
    };
    hooks.load = async (url, context, nextAsync) => {
      const { format, source } = await nextAsync(url, context, nextAsync);
      return {
        format,
        source: await transformModuleAsync(url, format, source),
      };
    };
    hooks.transformSource = async (content, context, nextAsync) => {
      const { format, url } = context;
      const { source } = await nextAsync(content, context, nextAsync);
      return {
        source: await transformModuleAsync(url, format, source),
      };
    };
  }
  return esm;
};

const unhook$a = (backup) => {
  if (backup !== null) {
    unhook$c(backup.cjs);
    unhook$b(backup.esm);
  }
};

const hook$a = (frontend, configuration) => {
  if (configuration.recorder === "jest") {
    return null;
  } else {
    return {
      cjs: hook$c(frontend, configuration),
      esm: hook$b(frontend, configuration),
    };
  }
};

var HookModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$a,
  hook: hook$a
});

// TODO: detect if preloaded with `--experimental-loader`

const forward = (_url, _location, content) => content;

const unhook$9 = (maybe_hidden) => {
  if (maybe_hidden !== null) {
    writeGlobal(maybe_hidden, forward);
  }
};

const hook$9 = (
  frontend,
  {
    hooks: {
      eval: { hidden, aliases },
    },
  },
) => {
  const enabled = aliases.length > 0;
  if (enabled) {
    assert(
      defineGlobal(
        hidden,
        (url, position, content) =>
          instrument(
            frontend,
            toAbsoluteUrl(`eval-${position}.js`, toDirectoryUrl(url)),
            toString(content),
            readFile,
          ),
        true,
      ),
      "global eval hook variable already defined",
      InternalAppmapError,
    );
  }
  return enabled ? hidden : null;
};

var HookEval = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$9,
  hook: hook$9
});

const hook$8 = (frontend, _configuration) => {
  const listener = (error) => {
    recordError(frontend, error);
  };
  process.addListener("uncaughtExceptionMonitor", listener);
  return listener;
};

const unhook$8 = (listener) => {
  process.removeListener("uncaughtExceptionMonitor", listener);
};

var HookError = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$8,
  unhook: unhook$8
});

const {
  Number: { isNaN },
} = globalThis;

const toStatus = (any) => {
  const integer = toInteger(any);
  if (isNaN(integer) || integer < 0 || integer > 255) {
    return 1;
  } else {
    return integer;
  }
};

const hook$7 = (frontend, _configuration) => {
  const listener = (status) => {
    recordStopTrack(frontend, null, {
      type: "exit",
      status: toStatus(status),
    });
  };
  process.addListener("beforeExit", listener);
  process.addListener("exit", listener);
  return listener;
};

const unhook$7 = (listener) => {
  process.removeListener("beforeExit", listener);
  process.removeListener("exit", listener);
};

var HookExit = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$7,
  unhook: unhook$7
});

const { URL } = globalThis;

const requirePeerDependency = (specifier, { directory, strict }) => {
  const require = createRequire(new URL(directory));
  try {
    return require(specifier);
  } catch (error) {
    if (strict) {
      logError(
        "Could not load peer dependency %j from %j >> %O",
        specifier,
        directory,
        error,
      );
      throw new ExternalAppmapError("Could not load peer dependency");
    } else {
      logDebug(
        "Could not load peer dependency %j from %j >> %O",
        specifier,
        directory,
        error,
      );
      return null;
    }
  }
};

const {
  Set,
  Map: Map$1,
  Array: { isArray: isArray$1, from: toArray$1 },
  Object: toObject,
  Object: { entries: toEntryArray, fromEntries: fromEntryArray },
} = globalThis;

const isStringEntry = ([key]) => typeof key === "string";

const toParameterCollection = (parameters) => {
  if (parameters instanceof Set) {
    return toArray$1(parameters.values());
  } else if (parameters instanceof Map$1) {
    return fromEntryArray(toArray$1(parameters.entries()).filter(isStringEntry));
  } else if (isArray$1(parameters)) {
    return toArray$1(parameters);
  } else {
    return fromEntryArray(toEntryArray(toObject(parameters)));
  }
};

/* c8 ignore start */

const {
  Reflect: { apply: apply$5 },
} = globalThis;

const DATABASE$2 = "mysql";
const VERSION$2 = null;

const unhook$6 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$6 = (
  frontend,
  { repository: { directory }, hooks: { mysql } },
) => {
  if (mysql === false) {
    return [];
  } else {
    const Mysql = requirePeerDependency("mysql", {
      directory,
      strict: mysql === true,
    });
    if (Mysql === null) {
      return [];
    } else {
      const { createConnection, createQuery } = Mysql;
      const { __proto__: prototype } = createConnection({});
      const { query: original } = prototype;
      prototype.query = function query(sql, values, callback) {
        const query = createQuery(sql, values, callback);
        const bundle_tab = getFreshTab(frontend);
        const jump_tab = getFreshTab(frontend);
        recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        recordBeforeQueryEvent(
          frontend,
          jump_tab,
          executionAsyncId(),
          now(),
          DATABASE$2,
          VERSION$2,
          toString(query.sql),
          toParameterCollection(query.values),
        );
        const { _callback: query_callback } = query;
        query._callback = spyOnce((_error, _result, _field) => {
          recordAfterAnswerEvent(frontend, jump_tab, executionAsyncId(), now());
          recordEndBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        }, query_callback);
        return apply$5(original, this, [query]);
      };
      return [{ object: prototype, key: "query", value: original }];
    }
  }
};

/* c8 ignore start */

const {
  undefined: undefined$5,
  Reflect: { apply: apply$4 },
  Promise: Promise$4,
  TypeError: TypeError$1,
} = globalThis;

const VERSION$1 = null;
const DATABASE$1 = "postgres";

const unhook$5 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$5 = (
  frontend,
  { repository: { directory }, hooks: { pg } },
) => {
  if (pg === false) {
    return [];
  } else {
    const Postgres = requirePeerDependency("pg", {
      directory,
      strict: pg === true,
    });
    if (Postgres === null) {
      return [];
    } else {
      const { Client, Query } = Postgres;
      const { prototype } = Client;
      const { query: original } = prototype;
      const { query } = {
        // We use the method syntax to create a function that is not constructor.
        query(query, values, callback) {
          if (query === null || query === undefined$5) {
            throw new TypeError$1("Client was passed a null or undefined query");
          }
          let result = undefined$5;
          if (typeof query.submit === "function") {
            result = query;
            if (!query.callback) {
              if (typeof values === "function") {
                query.callback = values;
              } else {
                query.callback = (error, _result) => {
                  if (error !== null) {
                    query.emit("error", error);
                  }
                };
              }
            }
          } else {
            query = new Query(query, values, callback);
            if (!query.callback) {
              result = new Promise$4((resolve, reject) => {
                query.callback = (error, result) => {
                  error ? reject(error) : resolve(result);
                };
              });
            }
          }
          const bundle_tab = getFreshTab(frontend);
          const jump_tab = getFreshTab(frontend);
          recordBeginBundleEvent(
            frontend,
            bundle_tab,
            executionAsyncId(),
            now(),
          );
          recordBeforeQueryEvent(
            frontend,
            jump_tab,
            executionAsyncId(),
            now(),
            DATABASE$1,
            VERSION$1,
            toString(query.text),
            toParameterCollection(query.values),
          );
          const { callback: query_callback } = query;
          query.callback = spyOnce((_error, _result) => {
            recordAfterAnswerEvent(
              frontend,
              jump_tab,
              executionAsyncId(),
              now(),
            );
            recordEndBundleEvent(
              frontend,
              bundle_tab,
              executionAsyncId(),
              now(),
            );
          }, query_callback);
          apply$4(original, this, [query]);
          return result;
        },
      };
      prototype.query = query;
      return [{ object: prototype, key: "query", value: original }];
    }
  }
};

const {
  Array: { isArray },
  Object: { assign },
  Reflect: { apply: apply$3 },
  TypeError,
} = globalThis;

const throwIfNotNull = (error) => {
  /* c8 ignore start */
  if (error !== null) {
    throw error;
  }
  /* c8 ignore stop */
};

const DATABASE = "sqlite3";
const VERSION = null;

const extractEach = (args) => {
  let each = throwIfNotNull;
  if (args.length > 0 && typeof args[args.length - 1] === "function") {
    if (args.length > 1 && typeof args[args.length - 2] === "function") {
      each = args[args.length - 2];
      args[args.length - 2] = args[args.length - 1];
    } else {
      each = args[args.length - 1];
    }
    args.length -= 1;
  }
  return each;
};

const normalizeStatementArguments = (args) => {
  if (args.length === 0 || typeof args[args.length - 1] !== "function") {
    args[args.length] = throwIfNotNull;
  }
  if (args.length === 1) {
    args = [[], args[0]];
  } else if (args.length > 2) {
    const parameters = [];
    for (let index = 0; index < args.length - 1; index += 1) {
      parameters[parameters.length] = args[index];
    }
    args = [parameters, args[args.length - 1]];
  }
  let [parameters, callback] = args;
  if (typeof parameters !== "object" || parameters === null) {
    parameters = [parameters];
  }
  return {
    parameters,
    callback,
  };
};

const normalizeDatabaseArguments = (args) => {
  if (args.length === 0) {
    throw new TypeError("missing sql query string");
  }
  const sql = args[0];
  if (typeof sql !== "string") {
    throw new TypeError("first argument is expected to be a sql query string");
  }
  for (let index = 1; index < args.length; index += 1) {
    args[index - 1] = args[index];
  }
  args.length -= 1;
  const { parameters, callback } = normalizeStatementArguments(args);
  return { sql, parameters, callback };
};

const combine = (parameters1, parameters2) => {
  if (isArray(parameters1) && parameters1.length === 0) {
    return parameters2;
  }
  if (isArray(parameters2) && parameters2.length === 0) {
    return parameters1;
  }
  if (isArray(parameters1) && isArray(parameters2)) {
    return [...parameters1, ...parameters2];
  }
  return { ...parameters1, ...parameters2 };
};

const unhook$4 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$4 = (
  frontend,
  { repository: { directory }, hooks: { sqlite3 } },
) => {
  if (sqlite3 === false) {
    return [];
  } else {
    const Sqlite3 = requirePeerDependency("sqlite3", {
      directory,
      strict: sqlite3 === true,
    });
    /* c8 ignore start */ if (Sqlite3 === null) {
      return [];
    } /* c8 ignore stop */ else {
      const { Database } = Sqlite3;
      const { prototype: database_prototype } = Database;
      const backup = ["run", "get", "all", "each", "prepare"].map((key) => ({
        object: database_prototype,
        key,
        value: database_prototype[key],
      }));
      const copy = { ...database_prototype };
      const recordQuery = (sql, parameters, callback) => {
        const bundle_tab = getFreshTab(frontend);
        const jump_tab = getFreshTab(frontend);
        recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        recordBeforeQueryEvent(
          frontend,
          jump_tab,
          executionAsyncId(),
          now(),
          DATABASE,
          VERSION,
          toString(sql),
          toParameterCollection(parameters),
        );
        return spyOnce(() => {
          recordAfterAnswerEvent(frontend, jump_tab, executionAsyncId(), now());
          recordEndBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
        }, callback);
      };
      /////////////////////////////////
      // Direct Database method call //
      /////////////////////////////////
      database_prototype.each = function each(...args) {
        const each = extractEach(args);
        const { sql, parameters, callback } = normalizeDatabaseArguments(args);
        return apply$3(copy.each, this, [
          sql,
          parameters,
          each,
          recordQuery(sql, parameters, callback),
        ]);
      };
      for (const key of ["run", "all", "get"]) {
        database_prototype[key] = function (...args) {
          const { sql, parameters, callback } =
            normalizeDatabaseArguments(args);
          return apply$3(copy[key], this, [
            sql,
            parameters,
            recordQuery(sql, parameters, callback),
          ]);
        };
      }
      // Database.prototype.exec is immutable :(
      // database_prototype.exec = function exec (...args) {
      //   const {sql, callback} = normalizeDatabaseArguments(args);
      //   return apply(
      //     save.exec,
      //     this,
      //     [sql, recordQuery(sql, null, callback)]
      //   );
      // }
      ////////////////////////
      // Prepared Statement //
      ////////////////////////
      // NB: Statement.prototype is largely immutable, that is why we need
      // to perform object composition instead of simple prototype assignments.
      function Statement(database, sql, parameters, callback) {
        const statement = apply$3(copy.prepare, database, [sql, callback]);
        statement._appmap_statement = this;
        this._appmap_statement = statement;
        this._appmap_sql = sql;
        this._appmap_parameters = parameters;
      }
      const { prototype: statement_prototype } = Statement;
      assign(statement_prototype, {
        run: null,
        all: null,
        get: null,
        each: function each(...args) {
          const each = extractEach(args);
          let { parameters, callback } = normalizeStatementArguments(args);
          parameters = combine(this._appmap_parameters, parameters);
          this._appmap_statement.each(
            parameters,
            each,
            recordQuery(this._appmap_sql, parameters, callback),
          );
          return this;
        },
        bind: function bind(...args) {
          const { parameters, callback } = normalizeStatementArguments(args);
          this._appmap_parameters = parameters;
          this._appmap_statement.reset(callback);
          return this;
        },
        reset: function reset(callback) {
          this._appmap_statement.reset(callback);
          return this;
        },
        finalize: function finalize(callback) {
          this._appmap_statement.finalize(callback);
          return this;
        },
      });
      for (const key of ["run", "all", "get"]) {
        statement_prototype[key] = function (...args) {
          let { parameters, callback } = normalizeStatementArguments(args);
          parameters = combine(this._appmap_parameters, parameters);
          this._appmap_statement[key](
            parameters,
            recordQuery(this._appmap_sql, parameters, callback),
          );
          return this;
        };
      }
      database_prototype.prepare = function (...args) {
        const { sql, parameters, callback } = normalizeDatabaseArguments(args);
        return new Statement(this, sql, parameters, callback);
      };
      return backup;
    }
  }
};

const hook$3 = (frontend, socket, configuration) => ({
  mysql: hook$6(frontend, socket),
  pg: hook$5(frontend, socket),
  sqlite3: hook$4(frontend, socket),
});

const unhook$3 = ({ mysql, pg, sqlite3 }) => {
  unhook$6(mysql);
  unhook$5(pg);
  unhook$4(sqlite3);
};

var HookQuery = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$3,
  unhook: unhook$3
});

const {
  Reflect: { getPrototypeOf, defineProperty: defineProperty$1, getOwnPropertyDescriptor },
  undefined: undefined$4,
} = globalThis;

const patch$1 = (object, key, makePatch) => {
  if (hasOwnProperty(object, key)) {
    const descriptor = getOwnPropertyDescriptor(object, key);
    assert(
      !logErrorWhen(
        !hasOwnProperty(descriptor, "value"),
        "Cannot monkey-patch accessor property %j of object %o",
        key,
        object,
      ),
      "Cannot monkey-patch accessor property",
      ExternalAppmapError,
    );
    assert(
      !logErrorWhen(
        !descriptor.configurable && !descriptor.writable,
        "Cannot monkey-patch constant data property %j of object %o",
        key,
        object,
      ),
      "Cannot monkey-patch constant data property",
      ExternalAppmapError,
    );
    defineProperty$1(object, key, {
      __proto__: descriptor,
      value: makePatch(descriptor.value),
    });
  } else {
    let prototype = getPrototypeOf(object);
    let existing_value = undefined$4;
    while (prototype !== null) {
      if (hasOwnProperty(prototype, key)) {
        const descriptor = getOwnPropertyDescriptor(prototype, key);
        assert(
          !logErrorWhen(
            !hasOwnProperty(descriptor, "value"),
            "Cannot monkey-patch accessor property %j of prototype %o",
            key,
            prototype,
          ),
          "Cannot monkey-patch accessor property on prototype",
          ExternalAppmapError,
        );
        existing_value = descriptor.value;
        prototype = null;
      } else {
        prototype = getPrototypeOf(prototype);
      }
    }
    defineProperty$1(object, key, {
      __proto__: null,
      writable: true,
      enumerable: false,
      value: makePatch(existing_value),
      configurable: true,
    });
  }
};

const {
  Buffer: { from: toBuffer$1, concat: concatBuffer$1 },
  Object: { fromEntries, entries: toEntries },
  TextDecoder,
  Reflect: { apply: apply$2 },
  JSON: { parse: parseJSON$1 },
  Math: { round },
  undefined: undefined$3,
} = globalThis;

const normalizeChunk = (chunk, encoding) =>
  typeof chunk === "string" ? toBuffer$1(chunk, encoding) : chunk;

const spyReadable = (readable, callback) => {
  const buffers = [];
  patch$1(
    readable,
    "push",
    (original_push) =>
      function (chunk, encoding) {
        if (chunk === null) {
          callback(concatBuffer$1(buffers));
        } else {
          buffers.push(normalizeChunk(chunk, encoding));
        }
        return apply$2(original_push, this, [chunk, encoding]);
      },
  );
};

const spyWritable = (writable, callback1) => {
  const buffers = [];
  patch$1(
    writable,
    "write",
    (original_write) =>
      function (chunk, encoding, callback2) {
        buffers.push(normalizeChunk(chunk, encoding));
        return apply$2(original_write, this, [chunk, encoding, callback2]);
      },
  );
  patch$1(
    writable,
    "end",
    (original_end) =>
      function (chunk, encoding, callback2) {
        if (chunk !== null && chunk !== undefined$3) {
          buffers.push(normalizeChunk(chunk, encoding));
        }
        callback1(concatBuffer$1(buffers));
        return apply$2(original_end, this, [chunk, encoding, callback2]);
      },
  );
};

const parseJSONSafe = (string, recovery) => {
  try {
    return parseJSON$1(string);
  } catch (error) {
    logWarning("Could not parse as JSON %j >> %O", string, error);
    return recovery;
  }
};

const decodeSafe = (buffer, encoding, recovery) => {
  try {
    return new TextDecoder(encoding).decode(buffer);
  } catch (error) {
    logWarning("Could not decode as %j buffer >> %O", encoding, error);
    return recovery;
  }
};

const parseContentTypeHead = (head) => {
  const parts = /^ *([a-zA-Z-]+) *\/ *([a-zA-Z-]+) *$/u.exec(head);
  if (parts === null) {
    logWarning("Could not parse content-type head %j", head);
    return { type: "text", subtype: "plain" };
  } else {
    return { type: parts[1], subtype: parts[2] };
  }
};

const parseContentTypeParameter = (parameter) => {
  const parts = /^ *([a-zA-Z0-9-]+) *= *([a-zA-Z0-9-]+) *$/u.exec(parameter);
  if (parts === null) {
    logWarning("Could not parse content-type parameter %j", parameter);
    return [];
  } else {
    return [[parts[1], parts[2]]];
  }
};

const parseContentType = (content_type) => {
  const segments = content_type.toLowerCase().split(";");
  const { type, subtype } = parseContentTypeHead(segments.shift());
  return {
    type,
    subtype,
    parameters: fromEntries(segments.flatMap(parseContentTypeParameter)),
  };
};

const isStringKeyEntry = ({ 0: key }) => typeof key === "string";

const toStringValueEntry = ({ 0: key, 1: value }) => [key, toString(value)];

const formatHeaders = (headers) =>
  fromEntries(
    toEntries(headers).filter(isStringKeyEntry).map(toStringValueEntry),
  );

const replacements = {
  NaN: 0,
  NEGATIVE_INFINITY: 0,
  POSITIVE_INFINITY: 0,
};

const formatStatus = (any) =>
  round(jsonifyNumber(toNumber(any), replacements));

const {
  Reflect: { apply: apply$1, construct: construct$1 },
  Proxy: Proxy$1,
} = globalThis;

const unhook$2 = (backup) => backup.forEach(assignProperty);

const hook$2 = (frontend, { hooks: { http } }) => {
  if (!http) {
    return [];
  } else {
    const empty = getSerializationEmptyValue(frontend);
    const backup = [
      ...["ClientRequest", "request", "get"].map((key) => ({
        object: Http,
        key,
      })),
      ...["request", "get"].map((key) => ({ object: Https, key })),
    ].map(({ object, key }) => ({ object, key, value: object[key] }));
    const spyRequest = (request) => {
      const bundle_tab = getFreshTab(frontend);
      const jump_tab = getFreshTab(frontend);
      recordBeginBundleEvent(frontend, bundle_tab, executionAsyncId(), now());
      recordBeforeRequestEvent(
        frontend,
        jump_tab,
        executionAsyncId(),
        now(),
        "HTTP/1.1",
        toString(request.method),
        toString(request.path),
        null,
        formatHeaders(request.getHeaders()),
        empty,
      );
      request.on("response", (response) => {
        const {
          headers,
          statusCode: status,
          statusMessage: message,
        } = response;
        let body = empty;
        const { type, subtype, parameters } = parseContentType(
          getOwnProperty(headers, "content-type", "text/plain"),
        );
        const compression = getOwnProperty(
          headers,
          "content-encoding",
          "identity",
        );
        if (
          type === "application" &&
          subtype === "json" &&
          compression === "identity"
        ) {
          spyReadable(response, (buffer) => {
            const maybe = decodeSafe(
              buffer,
              getOwnProperty(parameters, "charset", "utf-8"),
              null,
            );
            if (maybe !== null) {
              body = parseJSONSafe(maybe, empty);
            }
          });
        }
        response.once(
          "end",
          spyOnce(() => {
            recordAfterResponseEvent(
              frontend,
              jump_tab,
              executionAsyncId(),
              now(),
              formatStatus(status),
              toString(message),
              formatHeaders(headers),
              body,
            );
            recordEndBundleEvent(
              frontend,
              bundle_tab,
              executionAsyncId(),
              now(),
            );
          }, identity),
        );
      });
    };
    const traps = {
      __proto__: null,
      apply: (target, context, values) => {
        const request = apply$1(target, context, values);
        spyRequest(request);
        return request;
      },
      construct: (target, values, newtarget) => {
        const request = construct$1(target, values, newtarget);
        spyRequest(request);
        return request;
      },
    };
    for (const { object, key, value } of backup) {
      object[key] = new Proxy$1(value, traps);
    }
    return backup;
  }
};

var HookHttpClient = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$2,
  hook: hook$2
});

const {
  Buffer: { from: toBuffer, concat: concatBuffer },
  Promise: Promise$3,
  Error,
  JSON: { parse: parseJSON, stringify: stringifyJSON },
} = globalThis;

const { request: createRequest } = Http;

const INVALID_HEADERS_MESSAGE =
  "in the presence of a body, 'content-type' should be 'application/json; charset=UTF-8'";

const parse = (body) => {
  if (body === "") {
    return null;
  }
  return parseJSON(body);
};

const stringify = (data) => {
  if (data === null) {
    return "";
  }
  return stringifyJSON(data);
};

const areValidHeaders = (headers) =>
  !hasOwnProperty(headers, "content-length") ||
  headers["content-length"] === "0" ||
  (hasOwnProperty(headers, "content-type") &&
    headers["content-type"] === "application/json; charset=UTF-8");

const empty_headers = {
  "content-length": 0,
};

const createHeaders = ({ length }) => {
  if (length === 0) {
    return empty_headers;
  }
  return {
    "content-type": "application/json; charset=UTF-8",
    "content-length": length,
  };
};

const requestAsync = (host, port, method, path, data) =>
  new Promise$3((resolve, reject) => {
    const buffer = toBuffer(stringify(data), "utf8");
    const request = createRequest({
      host,
      port: typeof port === "number" ? port : null,
      socketPath:
        typeof port === "string" ? toIpcPath(fileURLToPath(port)) : null,
      method,
      path,
      headers: createHeaders(buffer),
    });
    request.end(buffer);
    request.on("error", reject);
    request.on("response", (response) => {
      response.on("error", reject);
      if (areValidHeaders(response.headers)) {
        const buffers = [];
        response.on("data", (buffer) => {
          buffers.push(buffer);
        });
        response.on("end", () => {
          resolve({
            code: response.statusCode,
            message: response.statusMessage,
            body: parse(concatBuffer(buffers).toString("utf8")),
          });
        });
      } else {
        reject(new Error(INVALID_HEADERS_MESSAGE));
      }
    });
  });

const generateRespond = (respondAsync) => (request, response) => {
  if (areValidHeaders(request.headers)) {
    const buffers = [];
    request.on("data", (buffer) => {
      buffers.push(buffer);
    });
    request.on("end", async () => {
      const { code, message, body } = await respondAsync(
        request.method,
        request.url,
        parse(concatBuffer(buffers).toString("utf8")),
      );
      const buffer = toBuffer(stringify(body), "utf8");
      response.writeHead(code, message, createHeaders(buffer));
      response.end(buffer);
    });
  } else {
    request.on("data", noop);
    request.on("end", noop);
    response.writeHead(400, INVALID_HEADERS_MESSAGE, empty_headers);
    response.end();
  }
};

const {
  RegExp,
  String,
  process: { nextTick },
  Reflect: { apply, construct },
  Proxy,
  undefined: undefined$2,
} = globalThis;

// TODO: improve test coverage

/* c8 ignore start */
const getStringPort = (server) => {
  const address = server.address();
  return typeof address === "string" ? address : String(address.port);
};

const interceptTraffic = (
  { host, track_port, recorder, regexp },
  server,
  request,
  response,
) => {
  if (
    recorder === "remote" &&
    request.url.startsWith("/_appmap/") &&
    regexp.test(getStringPort(server))
  ) {
    request.url = request.url.substring("/_appmap".length);
    generateRespond((method, path, body) =>
      requestAsync(host, track_port, method, `/_appmap${path}`, body),
    )(request, response);
    return true;
  } else {
    return false;
  }
};

/* c8 ignore stop */

const recordBegin = ({ frontend, empty }, tab, request) => {
  const { httpVersion: version, method, url, headers } = request;
  const protocol = `HTTP/${version}`;
  recordBeginRequestEvent(
    frontend,
    tab,
    executionAsyncId(),
    now(),
    toString(protocol),
    toString(method),
    toString(url),
    null,
    formatHeaders(headers),
    empty,
  );
  // Give time for express to populate the request
  nextTick(() => {
    if (
      typeof coalesce(request, "baseUrl", undefined$2) === "string" &&
      typeof coalesce(request, "route", undefined$2) === "object" &&
      typeof coalesce(request.route, "path", undefined$2) === "string"
    ) {
      recordBeginRequestAmend(
        frontend,
        tab,
        toString(protocol),
        toString(method),
        toString(url),
        `${request.baseUrl}${request.route.path}`,
        formatHeaders(headers),
        empty,
      );
    }
  });
};

const recordEnd = ({ frontend }, tab, response, body) => {
  recordEndResponseEvent(
    frontend,
    tab,
    executionAsyncId(),
    now(),
    formatStatus(response.statusCode),
    toString(response.statusMessage),
    formatHeaders(response.getHeaders()),
    body,
  );
};

const serializeResponseBody = ({ empty }, response, buffer) => {
  const headers = response.getHeaders();
  const { type, subtype, parameters } = parseContentType(
    getOwnProperty(headers, "content-type", "text/plain"),
  );
  const compression = getOwnProperty(headers, "content-encoding", "identity");
  if (
    type === "application" &&
    subtype === "json" &&
    compression === "identity"
  ) {
    return fromMaybe(
      decodeSafe(buffer, getOwnProperty(parameters, "charset", "utf-8"), null),
      empty,
      (string) => parseJSONSafe(string, empty),
    );
  } /* c8 ignore start */ else {
    return empty;
  } /* c8 ignore stop */
};

const trackJump = ({ frontend }, box, emitter) => {
  const tracking = createBox(true);
  patch$1(
    emitter,
    "emit",
    (original_emit) =>
      function emit(...args) {
        if (getBox(tracking)) {
          recordAfterJumpEvent(frontend, getBox(box), executionAsyncId(), now());
          setBox(box, getFreshTab(frontend));
          try {
            return apply(original_emit, this, args);
          } finally {
            recordBeforeJumpEvent(
              frontend,
              getBox(box),
              executionAsyncId(),
              now(),
            );
          }
        } else {
          return apply(original_emit, this, args);
        }
      },
  );
  return tracking;
};

const forwardTraffic = (
  _state,
  original_server_emit,
  server,
  request,
  response,
) => apply(original_server_emit, server, ["request", request, response]);

const spyTraffic = (state, original_server_emit, server, request, response) => {
  const { frontend, empty } = state;
  const bundle_tab = getFreshTab(frontend);
  const jump_box = createBox(getFreshTab(frontend));
  const request_tracking = trackJump(state, jump_box, request);
  const response_tracking = trackJump(state, jump_box, response);
  let body = empty;
  spyWritable(response, (buffer) => {
    body = serializeResponseBody(state, response, buffer);
  });
  const generateStopTracking = (box, peer_box) => () => {
    setBox(box, false);
    if (!getBox(peer_box)) {
      // make sure the end event is the last of the tab
      nextTick(() => {
        recordAfterJumpEvent(
          state.frontend,
          getBox(jump_box),
          executionAsyncId(),
          now(),
        );
        recordEnd(state, bundle_tab, response, body);
      });
    }
  };
  request.once(
    "close",
    spyOnce(
      generateStopTracking(request_tracking, response_tracking),
      identity,
    ),
  );
  response.once(
    "close",
    spyOnce(
      generateStopTracking(response_tracking, request_tracking),
      identity,
    ),
  );
  recordBegin(state, bundle_tab, request);
  try {
    return forwardTraffic(
      state,
      original_server_emit,
      server,
      request,
      response,
    );
  } finally {
    recordBeforeJumpEvent(frontend, getBox(jump_box), executionAsyncId(), now());
  }
};

const spyServer = (state, server, handleTraffic) => {
  patch$1(
    server,
    "emit",
    (original_server_emit) =>
      function emit(name, ...args) {
        if (name !== "request") {
          return apply(original_server_emit, this, [name, ...args]);
        } else {
          assert(
            !logErrorWhen(
              args.length !== 2,
              "Expected exactly two arguments for `request` event listener on `node:http.Server`",
            ),
            "Unexpected argument number on 'request' event listener",
            ExternalAppmapError,
          );
          const [request, response] = args;
          if (!interceptTraffic(state, this, request, response)) {
            handleTraffic(state, original_server_emit, this, request, response);
          }
          return true;
        }
      },
  );
};

const unhook$1 = (backup) => {
  backup.forEach(assignProperty);
};

const compileInterceptTrackPort = (source) => {
  try {
    return new RegExp(source, "u");
  } catch (error) {
    logError(
      "Failed to compile the 'intercept-track-port' configuration field %j as regexp >> %O",
      source,
      error,
    );
    throw new ExternalAppmapError("intercept-track-port is not a regexp");
  }
};

const hook$1 = (
  frontend,
  {
    recorder,
    host,
    "intercept-track-port": intercept_track_port,
    "track-port": track_port,
    hooks: { http },
  },
) => {
  if (!http && recorder !== "remote") {
    return [];
  } else {
    const handleTraffic = http ? spyTraffic : forwardTraffic;
    const backup = [Http, Https].flatMap((object) =>
      ["Server", "createServer"].map((key) => ({
        object,
        key,
        value: object[key],
      })),
    );
    const state = {
      frontend,
      recorder,
      track_port,
      host,
      empty: getSerializationEmptyValue(frontend),
      regexp: compileInterceptTrackPort(intercept_track_port),
    };
    const traps = {
      __proto__: null,
      apply: (target, context, values) => {
        const server = apply(target, context, values);
        spyServer(state, server, handleTraffic);
        return server;
      },
      construct: (target, values, newtarget) => {
        const server = construct(target, values, newtarget);
        spyServer(state, server, handleTraffic);
        return server;
      },
    };
    for (const { object, key, value } of backup) {
      object[key] = new Proxy(value, traps);
    }
    return backup;
  }
};

var HookHttpServer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$1,
  hook: hook$1
});

const Hooks = [
  HookApply,
  HookGroup,
  HookModule,
  HookEval,
  HookError,
  HookExit,
  HookQuery,
  HookHttpClient,
  HookHttpServer,
];

const generateHookSingle = (frontend, configuration) => (_, index) =>
  Hooks[index].hook(frontend, configuration);

const unhookSingle = (hooking, index) => Hooks[index].unhook(hooking);

const hook = (frontend, configuration) =>
  Hooks.map(generateHookSingle(frontend, configuration));

const unhook = (hooking) => hooking.map(unhookSingle);

const { Promise: Promise$2, setTimeout } = globalThis;

// export const createThrottle = ({
//   "throttle-threshold": threshold
//   "throttle-timeout-step": step,
// }) => ({
//   threshold,
//   step,
//   timeout: { value: 0 },
// });

const createThrottle = ({}) => ({
  threshold: 10,
  step: 1000,
  buildup: { value: null },
  callbacks: [],
});

const updateThrottle = ({ buildup, callbacks }, count) => {
  buildup.value = count;
  if (callbacks.length > 0) {
    for (const callback of callbacks) {
      callback();
    }
    callbacks.length = 0;
  }
};

const throttleAsync = async ({
  threshold,
  buildup,
  step,
  callbacks,
}) => {
  // We want to wait for the first buildup from the backend.
  // Not doing so can still result in oom because the test
  // runner may be running a lot of test cases in the
  // meantime.
  if (buildup.value === null) {
    await new Promise$2((resolve) => {
      callbacks.push(resolve);
    });
  }
  if (buildup.value > threshold) {
    await new Promise$2((resolve) => {
      setTimeout(resolve, (buildup.value - threshold) * step);
    });
  }
};

const { patch } = NetSocketMessaging;

const openSocket = ({ host, "trace-port": port }) => {
  const socket = new Socket();
  if (typeof port === "string") {
    socket.connect(toIpcPath(fileURLToPath(port)));
  } else {
    socket.connect(port, host);
  }
  patch(socket);
  socket.on("connect", () => {
    socket.unref();
  });
  return socket;
};

const addSocketListener = (socket, name, listener) => {
  socket.addListener(name === "open" ? "connect" : name, listener);
};

const isSocketReady = (socket) => !socket.pending && socket.writable;

const closeSocket = (socket) => {
  socket.end();
};

const sendSocket = (socket, message) => {
  if (!socket.pending && socket.writable) {
    socket.send(message);
  } else {
    logWarning("Lost message >> %s", message);
  }
};

const {
  Promise: Promise$1,
  undefined: undefined$1,
  parseInt,
  Map,
  Array: { from: toArray },
  Reflect: { defineProperty },
} = globalThis;

// (node:73778) TimeoutOverflowWarning: Infinity does not fit into a 32-bit signed integer.
const TIMEOUT = 2 ** 30;

const getName = ({ name }) => name;

function showTrackMap() {
  return toArray(this.values()).map(getName);
}

const recordAsync = (configuration) => {
  configuration = extendConfigurationNode(configuration, process);
  if (configuration.session === null) {
    configuration = { ...configuration, session: getUuid() };
  }
  const { session } = configuration;
  logInfo(
    "Recording jest test cases of process #%j -- %j",
    process.pid,
    process.argv,
  );
  // I would prefer to use require rather that global variable:
  //
  // const { beforeEach, afterEach, expect } = requirePeerDependency(
  //   "@jest/globals",
  //   {
  //     directory: configuration.repository.directory,
  //     strict: true,
  //   },
  // );
  //
  // But this breaks an invariant in Jest:
  //
  // Error: There should always be a Jest object already
  //
  // Which might be a bug in jest related to `createRequire`.
  const beforeAll = readGlobal("beforeAll");
  const beforeEach = readGlobal("beforeEach");
  const afterEach = readGlobal("afterEach");
  const afterAll = readGlobal("afterAll");
  const expect = readGlobal("expect");
  const frontend = createFrontend(configuration);
  // Jest is claiming that it is running the tests from a given file serially.
  // However we detected nested calls of beforeEach / afterEach in practice.
  // So we need to maintain a set of track ids instead of a single one.
  const tracks = new Map();
  defineProperty(tracks, "toJSON", {
    __proto__: null,
    writable: true,
    configurable: true,
    enumerable: true,
    value: showTrackMap,
  });
  const backup = hook(frontend, configuration);
  const socket = openSocket(configuration);
  const throttle = createThrottle(configuration);
  addSocketListener(socket, "message", (message) => {
    updateThrottle(throttle, parseInt(message));
  });
  const flush = () => {
    if (isSocketReady(socket)) {
      const content = flushContent(frontend);
      if (content !== null) {
        sendSocket(socket, content);
      }
    }
  };
  beforeAll(async () => {
    /* c8 ignore start */
    if (!isSocketReady(socket)) {
      await new Promise$1((resolve, reject) => {
        addSocketListener(socket, "error", reject);
        addSocketListener(socket, "open", resolve);
      });
    }
    /* c8 ignore stop */
    process.once("beforeExit", flush);
    process.on("exit", flush);
    process.on("uncaughtExceptionMonitor", flush);
  }, TIMEOUT);
  beforeEach(async function () {
    await throttleAsync(throttle);
    assert(
      !logErrorWhen(
        tracks.has(this),
        "Duplicate beforeEach test context %o in %j",
        this,
        tracks,
      ),
      "Duplicate beforeEach test context",
      ExternalAppmapError,
    );
    // We cannot use a counter because another jest
    // agent may be running in a different context.
    const track = `jest-${getUuid()}`;
    const name = expect.getState().currentTestName;
    tracks.set(this, { track, name });
    logWarningWhen(
      tracks.size > 1,
      "Detected concurrent jest tests (beforeEach): %j",
      tracks,
    );
    recordStartTrack(
      frontend,
      track,
      extendConfiguration(
        configuration,
        {
          "map-name": name,
          sessions: session,
        },
        null,
      ),
    );
    flush();
  }, TIMEOUT);
  afterEach(function () {
    assert(
      !logErrorWhen(
        !tracks.has(this),
        "Missing afterEach test context %o in %j",
        this,
        tracks,
      ),
      "Missing after test context",
      ExternalAppmapError,
    );
    logWarningWhen(
      tracks.size > 1,
      "Detected concurrent jest tests (afterEach): %j",
      tracks,
    );
    const { track } = tracks.get(this);
    tracks.delete(this);
    recordStopTrack(frontend, track, {
      type: "test",
      // TODO: figure out how to fetch the status of the current test case
      passed: true,
    });
    flush();
  }, TIMEOUT);
  afterAll(async () => {
    unhook(backup);
    flush();
    closeSocket(socket);
    await new Promise$1((resolve, reject) => {
      addSocketListener(socket, "error", reject);
      addSocketListener(socket, "close", resolve);
    });
    process.off("beforeExit", flush);
    process.off("exit", flush);
    process.off("uncaughtExceptionMonitor", flush);
  }, TIMEOUT);
  return Promise$1.resolve(undefined$1);
};

export { recordAsync };
