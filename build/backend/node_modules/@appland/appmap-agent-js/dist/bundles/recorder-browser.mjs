const { Error: Error$3 } = globalThis;

class AssertionError extends Error$3 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const {
  Boolean,
  String: String$2,
  Number,
  parseInt,
  Array: { isArray: isArray$2 },
  Number: {
    isNaN,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER,
    MIN_SAFE_INTEGER,
  },
  Math: { round: round$1 },
  JSON: { stringify: stringifyJSON$3 },
} = globalThis;

const print$1 = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$2(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$3(any);
  } else {
    return String$2(any);
  }
};

const {
  Error: Error$2,
  String: String$1,
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$2(value);
      }
      if (marker === "O") {
        try {
          return String$1(value);
        } catch {
          return print$1(value);
        }
      }
      if (marker === "o") {
        return print$1(value);
      }
      throw new Error$2("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const createCounter = (value) => ({ value });
const incrementCounter = (counter) => (counter.value += 1);

const {
  Error: Error$1,
  Reflect: { apply },
  WeakMap: WeakMap$2,
} = globalThis;

new WeakMap$2();

const noop = () => {};
const identity = (x) => x;
const constant = (x) => () => x;

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const {
  undefined: undefined$4,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, ownKeys: ownKeys$1, defineProperty: defineProperty$1 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$1(Object$1, "hasOwn") === undefined$4
    ? (object, key) => getOwnPropertyDescriptor$1(object, key) !== undefined$4
    : Object$1.hasOwn;

const assignProperty = ({ object, key, value }) => {
  object[key] = value;
};

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$3,
  ReferenceError,
  Reflect: { defineProperty },
} = globalThis;

const defineGlobal = (name, value, writable = false) => {
  if (!hasOwnProperty(globalThis, name)) {
    return defineProperty(globalThis, name, {
      __proto__: null,
      value,
      writable,
      configurable: false,
      enumerable: false,
    });
  } else {
    return false;
  }
};

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

const {
  Date: { now: now$1 },
  Math: { random },
} = globalThis;

const getUuid = () =>
  `${now$1().toString(32).substr(-4)}${random().toString(32).substr(-4)}`;

const { Error } = globalThis;

class AppmapError extends Error {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const {
  console: { info: logInfo, warn: logWarning$1, error: logError$1 },
} = globalThis;

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

const { log: logDebug, logWhen: logDebugWhen } = generateLog(
  "debug",
  noop,
);

generateLog(
  "info",
  logInfo,
);

const { log: logWarning, logWhen: logWarningWhen } = generateLog(
  "warning",
  logWarning$1,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const {
  Reflect: { getOwnPropertyDescriptor, getPrototypeOf, ownKeys },
  Error: { prototype: error_prototype },
  Infinity,
  Symbol,
  Symbol: { keyFor, for: symbolFor },
  WeakMap: WeakMap$1,
  Map,
  Set,
  String,
  undefined: undefined$2,
  Math: { min },
  Object: { prototype: object_prototype, fromEntries: fromEntries$1 },
  Array: { isArray: isArray$1 },
  JSON: { stringify: stringifyJSON$1 },
} = globalThis;

const empty = symbolFor("APPMAP_EMPTY_MARKER");

const isSymbol = (any) => typeof any === "symbol";

const isString = (any) => typeof any === "string";

const wellknown = new Set(
  ownKeys(Symbol)
    .map((key) => Symbol[key])
    .filter(isSymbol),
);

////////////////////
// Reflect Helper //
////////////////////
const getOwnKeyArrayImpure = (object) => {
  try {
    return ownKeys(object);
  } catch (error) {
    logDebug(
      "Reflect.ownKeys(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return [];
  }
};
const getPrototypeImpure = (object) => {
  try {
    return getPrototypeOf(object);
  } catch (error) {
    logDebug(
      "Reflect.getPrototypeOf(%o) threw %O (this should only happen when the object is a proxy)",
      object,
      error,
    );
    return null;
  }
};
const getOwnPropertyDescriptorImpure = (object, key) => {
  try {
    return getOwnPropertyDescriptor(object, key);
  } catch (error) {
    logDebug(
      "Reflect.getOwnPropertyDescriptor(%o, %j) threw %O (this should only happen when the object is a proxy)",
      object,
      key,
      error,
    );
    return undefined$2;
  }
};
const hasPrototypeImpure = (object, prototype) => {
  while (object !== null) {
    if (object === prototype) {
      return true;
    }
    object = getPrototypeImpure(object);
  }
  return false;
};
const getDataPropertyImpure = (object, key) => {
  while (object !== null) {
    const descriptor = getOwnPropertyDescriptorImpure(object, key);
    if (descriptor !== undefined$2 && hasOwnProperty(descriptor, "value")) {
      return descriptor.value;
    }
    object = getPrototypeImpure(object);
  }
  return undefined$2;
};
const toStringImpure = (object) => {
  try {
    return object.toString();
  } catch (error) {
    logDebug("%o.toString() failure >> %O", object, error);
    return undefined$2;
  }
};
///////////
// Index //
///////////
const generateGetIndex =
  (name) =>
  ({ [name]: map, counter }, value) => {
    const index = map.get(value);
    if (index !== undefined$2) {
      return index;
    } else {
      const new_index = incrementCounter(counter);
      map.set(value, new_index);
      return new_index;
    }
  };
const getSymbolIndex = generateGetIndex("symbols");
const getReferenceIndex = generateGetIndex("references");
////////////////////////
// getConstructorName //
////////////////////////
const getConstructorName = ({ impure_constructor_naming }, object) => {
  if (impure_constructor_naming) {
    const _constructor = getDataPropertyImpure(object, "constructor");
    if (typeof _constructor === "function") {
      const name = getDataPropertyImpure(_constructor, "name");
      logDebugWhen(
        typeof name !== "string",
        "Constructor name of %o is not a string: %o",
        object,
        name,
      );
      return typeof name === "string" ? name : typeof object;
    } else {
      return typeof object;
    }
  } else {
    return typeof object;
  }
};
///////////////
// stringify //
///////////////
const generatePrint =
  (printString) =>
  ({ impure_printing }, any) => {
    if (
      any === null ||
      any === undefined$2 ||
      typeof any === "boolean" ||
      typeof any === "number"
    ) {
      return String(any);
    } else if (typeof any === "string") {
      return printString(any);
    } else if (typeof any === "bigint") {
      return `${String(any)}n`;
    } else if (typeof any === "symbol") {
      if (wellknown.has(any)) {
        return `well-known ${String(any)}`;
      } else if (keyFor(any) !== undefined$2) {
        return `global ${String(any)}`;
      } else {
        return String(any);
      }
    } else if (typeof any === "function") {
      if (impure_printing) {
        const name = getDataPropertyImpure(any, "name");
        if (getOwnPropertyDescriptorImpure(any, "prototype") !== undefined$2) {
          if (typeof name === "string" && name !== "") {
            return `function ${name} (...) { ... }`;
          } else {
            return `function (...) { ... }`;
          }
        } else {
          if (typeof name === "string" && name !== "") {
            return `${name} = (...) => { ... }`;
          } else {
            return `(...) => { ... }`;
          }
        }
      } else {
        return "function";
      }
    } else if (typeof any === "object") {
      if (impure_printing) {
        const representation = toStringImpure(any);
        logDebugWhen(
          typeof representation !== "string",
          "%o.toString() did not return a string, got: %o",
          any,
          representation,
        );
        return typeof representation === "string" ? representation : "object";
      } else {
        return "object";
      }
    } /* c8 ignore start */ else {
      throw new InternalAppmapError("unknown type");
    } /* c8 ignore stop */
  };
const print = generatePrint(stringifyJSON$1);
const show = generatePrint(identity);
//////////////////
// getSpecific  //
//////////////////
const getSpecific = (serialization, object) => {
  if (
    serialization.impure_error_inspection &&
    hasPrototypeImpure(object, error_prototype)
  ) {
    return {
      type: "error",
      name: show(serialization, getDataPropertyImpure(object, "name")),
      message: show(serialization, getDataPropertyImpure(object, "message")),
      stack: show(serialization, getDataPropertyImpure(object, "stack")),
    };
  } else if (serialization.impure_array_inspection && isArray$1(object)) {
    // Proxies cannot change array's length so we know it will be a number.
    return { type: "array", length: getDataPropertyImpure(object, "length") };
  } else if (
    serialization.impure_hash_inspection &&
    (getPrototypeImpure(object) === null ||
      getPrototypeImpure(object) === object_prototype)
  ) {
    const keys = getOwnKeyArrayImpure(object).filter(isString);
    const entries = [];
    const length = min(keys.length, serialization.maximum_properties_length);
    for (let index = 0; index < length; index += 1) {
      const key = keys[index];
      entries.push([key, typeof getDataPropertyImpure(object, key)]);
    }
    return {
      type: "hash",
      length,
      properties: fromEntries$1(entries),
    };
  } else {
    return null;
  }
};
const serializeNonEmpty = (serialization, value) => {
  const type = value === null ? "null" : typeof value;
  const representation = print(serialization, value);
  if (
    type === "null" ||
    type === "undefined" ||
    type === "boolean" ||
    type === "number" ||
    type === "string" ||
    type === "bigint"
  ) {
    return { type, print: representation };
  } else if (type === "symbol") {
    return {
      type,
      print: representation,
      index: getSymbolIndex(serialization, value),
    };
  } else {
    return {
      type,
      print: representation,
      index: getReferenceIndex(serialization, value),
      constructor: getConstructorName(serialization, value),
      specific: getSpecific(serialization, value),
    };
  }
};

const createSerialization = ({
  serialization: {
    "maximum-print-length": maximum_print_length,
    "maximum-properties-length": maximum_properties_length,
    "impure-printing": impure_printing,
    "impure-constructor-naming": impure_constructor_naming,
    "impure-array-inspection": impure_array_inspection,
    "impure-error-inspection": impure_error_inspection,
    "impure-hash-inspection": impure_hash_inspection,
  },
}) => ({
  counter: createCounter(0),
  empty,
  symbols: new Map(),
  references: new WeakMap$1(),
  maximum_print_length:
    maximum_print_length === null ? Infinity : maximum_print_length,
  maximum_properties_length,
  impure_printing,
  impure_constructor_naming,
  impure_array_inspection,
  impure_error_inspection,
  impure_hash_inspection,
});

const getSerializationEmptyValue$1 = ({ empty }) => empty;

const serialize$1 = (serialization, value) => {
  if (value === serialization.empty) {
    return null;
  } else {
    const serial = serializeNonEmpty(serialization, value);
    if (serial.print.length > serialization.maximum_print_length) {
      return {
        ...serial,
        print: `${serial.print.substring(
          0,
          serialization.maximum_print_length - 4,
        )} ...`,
      };
    } else {
      return serial;
    }
  }
};

const START = "TR?";
const STOP = "TR!";
const ERROR = "ERR";

const SESSION_ASSIGNMENT = "SE!";
const GROUP_ASSIGNMENT = "GR!";

const BEGIN_APPLY_EVENT = "APP";
const END_RETURN_EVENT = "RET";
const END_THROW_EVENT = "TRW";

const BEFORE_AWAIT_EVENT = "AWT";
const BEFORE_YIELD_EVENT = "YLD";
const AFTER_RESOLVE_EVENT = "RES";
const AFTER_REJECT_EVENT = "REJ";

const {
  Array: { isArray, from: toArray },
  Object: { fromEntries, entries: toEntries },
  JSON: { stringify: stringifyJSON },
} = globalThis;

const serialize = (serialization, enabled, value) => {
  enabled.value = false;
  try {
    return serialize$1(serialization, value);
  } finally {
    enabled.value = true;
  }
};

const updateGroup = (buffer, old_group, new_group) => {
  if (old_group.value !== new_group) {
    buffer.push([GROUP_ASSIGNMENT, new_group]);
    old_group.value = new_group;
  }
};

const initializeBuffer = (buffer, session, { value: group }) => {
  buffer.push([SESSION_ASSIGNMENT, session], [GROUP_ASSIGNMENT, group]);
};

const createFrontend = (configuration) => {
  const { session } = configuration;
  assert(session !== null, "missing session", InternalAppmapError);
  const buffer = [];
  initializeBuffer(buffer, session, { value: 0 });
  return {
    enabled: { value: true },
    buffer,
    counter: createCounter(0),
    session,
    old_group: { value: 0 },
    serialization: createSerialization(configuration),
    configuration,
  };
};

const flushContent = ({ buffer, session, old_group }) => {
  if (buffer.length === 2) {
    return null;
  } else {
    const content = stringifyJSON(buffer);
    buffer.length = 0;
    initializeBuffer(buffer, session, old_group);
    return content;
  }
};
/* c8 ignore stop */

const getFreshTab = ({ counter }) => incrementCounter(counter);

const getSerializationEmptyValue = ({ serialization }) =>
  getSerializationEmptyValue$1(serialization);

const recordError = ({ enabled, buffer, serialization }, error) => {
  if (enabled.value) {
    buffer.push([ERROR, serialize(serialization, enabled, error)]);
  }
};

const recordStartTrack = ({ enabled, buffer }, track, configuration) => {
  if (enabled.value) {
    buffer.push([START, track, configuration]);
  }
};

const recordStopTrack = ({ enabled, buffer }, track, termination) => {
  if (enabled.value) {
    buffer.push([STOP, track, termination]);
  }
};

// function //

const recordBeginApplyEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  this_,
  arguments_,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEGIN_APPLY_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, this_),
      arguments_.map((argument) => serialize(serialization, enabled, argument)),
    ]);
  }
};

const recordEndReturnEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_RETURN_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordEndThrowEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  function_,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      END_THROW_EVENT,
      tab,
      time,
      function_,
      serialize(serialization, enabled, error),
    ]);
  }
};

// promise && iterator //

const recordBeforeAwaitEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  promise,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_AWAIT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, promise),
    ]);
  }
};

const recordBeforeYieldEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  iterator,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      BEFORE_YIELD_EVENT,
      tab,
      time,
      serialize(serialization, enabled, iterator),
    ]);
  }
};

const recordAfterResolveEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  result,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_RESOLVE_EVENT,
      tab,
      time,
      serialize(serialization, enabled, result),
    ]);
  }
};

const recordAfterRejectEvent = (
  { enabled, buffer, serialization, old_group },
  tab,
  group,
  time,
  error,
) => {
  if (enabled.value) {
    updateGroup(buffer, old_group, group);
    buffer.push([
      AFTER_REJECT_EVENT,
      tab,
      time,
      serialize(serialization, enabled, error),
    ]);
  }
};

const {
  performance,
  Math: { round },
} = globalThis;

const now = () => round(1000 * performance.now()) / 1000;

const getCurrentGroup = constant(0);

const unhook$8 = (backup) => {
  backup.forEach(assignProperty);
};

const hook$9 = (frontend, { hooks: { apply: apply_hook_variable } }) => {
  if (apply_hook_variable === null) {
    return [];
  } else {
    const runtime = {
      empty: getSerializationEmptyValue(frontend),
      getFreshTab: () => getFreshTab(frontend),
      recordApply: (tab, function_, this_, arguments_) => {
        recordBeginApplyEvent(
          frontend,
          tab,
          getCurrentGroup(),
          now(),
          function_,
          this_,
          arguments_,
        );
      },
      recordReturn: (tab, function_, result) => {
        recordEndReturnEvent(
          frontend,
          tab,
          getCurrentGroup(),
          now(),
          function_,
          result,
        );
      },
      recordThrow: (tab, function_, error) => {
        recordEndThrowEvent(
          frontend,
          tab,
          getCurrentGroup(),
          now(),
          function_,
          error,
        );
      },
      recordAwait: (tab, promise) => {
        recordBeforeAwaitEvent(
          frontend,
          tab,
          getCurrentGroup(),
          now(),
          promise,
        );
      },
      recordYield: (tab, iterator) => {
        recordBeforeYieldEvent(
          frontend,
          tab,
          getCurrentGroup(),
          now(),
          iterator,
        );
      },
      recordResolve: (tab, result) => {
        recordAfterResolveEvent(
          frontend,
          tab,
          getCurrentGroup(),
          now(),
          result,
        );
      },
      recordReject: (tab, error) => {
        recordAfterRejectEvent(frontend, tab, getCurrentGroup(), now(), error);
      },
    };
    assert(
      defineGlobal(apply_hook_variable, runtime),
      "global apply hook variable already defined",
      InternalAppmapError,
    );
    return [
      "getFreshTab",
      "recordApply",
      "recordReturn",
      "recordThrow",
      "recordAwait",
      "recordResolve",
      "recordReject",
      "recordYield",
    ].map((key) => ({
      object: runtime,
      key,
      value: noop,
    }));
  }
};

var HookApply = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$8,
  hook: hook$9
});

const hook$8 = noop;
const unhook$7 = noop;

var HookGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$8,
  unhook: unhook$7
});

const hook$7 = noop;
const unhook$6 = noop;

var HookModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$7,
  unhook: unhook$6
});

const hook$6 = noop;
const unhook$5 = noop;

var HookEval = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$6,
  unhook: unhook$5
});

const { window: window$2 } = globalThis;

const hook$5 = (frontend, _configuration) => {
  const listener = (error) => {
    recordError(frontend, error);
  };
  window$2.addEventListener("error", listener);
  return listener;
};

const unhook$4 = (listener) => {
  window$2.removeEventListener("error", listener);
};

var HookError = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$5,
  unhook: unhook$4
});

const { window: window$1 } = globalThis;

const hook$4 = (frontend, _configuration) => {
  const listener = () => {
    recordStopTrack(frontend, null, { type: "exit", status: 0 });
  };
  window$1.addEventListener("beforeunload", listener);
  return listener;
};

const unhook$3 = (listener) => {
  window$1.removeEventListener("beforeunload", listener);
};

var HookExit = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$4,
  unhook: unhook$3
});

const unhook$2 = noop;

const hook$3 = (_frontend, { hooks: { mysql, pg, sqlite3 } }) => {
  assert(
    !logErrorWhen(
      mysql || pg || sqlite3,
      "No support for recording sql queries",
    ),
    "No support for recording sql queries",
    ExternalAppmapError,
  );
};

var HookQuery = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unhook: unhook$2,
  hook: hook$3
});

const hook$2 = noop;
const unhook$1 = noop;

var HookHttpClient = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$2,
  unhook: unhook$1
});

const hook$1 = noop;
const unhook = noop;

var HookHttpServer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hook: hook$1,
  unhook: unhook
});

const Hooks = [
  HookApply,
  HookGroup,
  HookModule,
  HookEval,
  HookError,
  HookExit,
  HookQuery,
  HookHttpClient,
  HookHttpServer,
];

const generateHookSingle = (frontend, configuration) => (_, index) =>
  Hooks[index].hook(frontend, configuration);

const hook = (frontend, configuration) =>
  Hooks.map(generateHookSingle(frontend, configuration));

// I'm not sure if we can rely on
const OPEN = 1;

const {
  WeakMap,
  URL,
  WebSocket,
  TextDecoder,
  window: { location },
} = globalThis;

const cache = new WeakMap();

const toWebSocketUrl = (base, path) => {
  const url_obj = new URL(base);
  url_obj.protocol = "ws:";
  url_obj.pathname = path;
  return url_obj.toString();
};

const openSocket = ({ "http-switch": segment }) =>
  new WebSocket(toWebSocketUrl(location, `/${segment}`));

const addSocketListener = (socket, name, listener) => {
  if (name === "message") {
    const old_listener = listener;
    const new_listener = ({ data }) => {
      listener(new TextDecoder().decode(data));
    };
    cache.set(old_listener, new_listener);
    socket.addEventListener(name, new_listener);
  } else {
    socket.addEventListener(name, listener);
  }
};

const isSocketReady = (socket) => socket.readyState === OPEN;

const sendSocket = (socket, message) => {
  if (socket.readyState === OPEN) {
    socket.send(message);
  } else {
    logWarning("Lost message >> %s", message);
  }
};

const { Promise: Promise$1, window, setInterval, undefined: undefined$1 } = globalThis;

const recordAsync = (configuration) => {
  if (configuration.session === null) {
    configuration = { ...configuration, session: getUuid() };
  }
  const { recorder, session, heartbeat } = configuration;
  const frontend = createFrontend(configuration);
  if (recorder === "process") {
    recordStartTrack(frontend, `process-${getUuid()}`, {
      ...configuration,
      sessions: session,
    });
  }
  const socket = openSocket(configuration);
  const flush = () => {
    if (isSocketReady(socket)) {
      const content = flushContent(frontend);
      if (content !== null) {
        sendSocket(socket, content);
      }
    }
  };
  addSocketListener(socket, "open", flush);
  if (heartbeat !== null) {
    setInterval(flush, heartbeat);
  }
  window.addEventListener("beforeunload", flush);
  hook(frontend, configuration);
  // We do not want to wait for the socket in browser setting.
  // That is because we want to be sure that this code is
  // evaluated before the observed application.
  // In the other recorders, there is a mechanism to wait for
  // the promise returned by this function before evaluating
  // the rest of the code.
  return Promise$1.resolve(undefined$1);
};

// Do not use top-level await to make this a script after bundling.
// This should only be used with browser recorder-cli and it resolve
// directly.
// In the future, we probably want to make `recorder-cli` standalone
// anyway.
recordAsync(readGlobal("__APPMAP_CONFIGURATION__"));
