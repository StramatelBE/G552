import { readFile } from 'node:fs/promises';
import { URL as URL$7, pathToFileURL, fileURLToPath } from 'node:url';
import { openSync, writeSync, readFileSync, readdirSync } from 'node:fs';
import { platform } from 'node:os';
import { win32, posix } from 'node:path';
import { spawnSync, spawn as spawn$1 } from 'node:child_process';
import Minimatch from 'minimatch';
import { platform as platform$1, cwd } from 'node:process';
import * as Minimist from 'minimist';
import { createRequire } from 'node:module';
import { parse } from 'yaml';
import { Buffer } from 'node:buffer';

const toAbsoluteUrl = (relative, base_url) =>
  new URL$7(
    /^[a-zA-Z]:\/[^/]/u.test(relative) ? `/${relative}` : relative,
    base_url,
  ).href;

const toDirectoryUrl = (url) => {
  const url_obj = new URL$7(url);
  if (url_obj.pathname.endsWith("/")) {
    return url;
  } else {
    url_obj.pathname += "/";
    return url_obj.href;
  }
};

// Alternatively:
//   url.match(/:\/{0,2}.*\/([^/#]+)(#.*)?$/)[1]
const getUrlFilename = (url) => {
  const { pathname } = new URL$7(url);
  if (pathname === "" || pathname.endsWith("/")) {
    return null;
  } else {
    return pathname.substring(pathname.lastIndexOf("/") + 1);
  }
};

// Alternatively:
//   url.match(/([^\/]+)(\.[^/#]*)(#.*)?$/)[2]
const getLastUrlExtension = (url) => {
  const filename = getUrlFilename(url);
  if (filename === null) {
    return null;
  } else if (filename.includes(".")) {
    return filename.substring(filename.lastIndexOf("."));
  } else {
    return null;
  }
};

// Consistent way to retreive home url in prod and test.

const {
  URL: URL$6,
  JSON: { parse: parseJSON$3 },
} = globalThis;

let url = toAbsoluteUrl(".", import.meta.url);

while (!url.endsWith("appmap-agent-js/")) {
  url = toAbsoluteUrl("..", url);
}

const self_directory = url;

const self_package = parseJSON$3(
  await readFile(
    new URL$6(toAbsoluteUrl("package.json", self_directory)),
    "utf8",
  ),
);

self_package.version;

const { Error: Error$6 } = globalThis;

class AppmapError extends Error$6 {}

class InternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "InternalAppmapError";
  }
}

class ExternalAppmapError extends AppmapError {
  constructor(message) {
    super(message);
    this.name = "ExternalAppmapError";
  }
}

const { Error: Error$5 } = globalThis;

class AssertionError extends Error$5 {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}

const assert = (boolean, message, Constructor) => {
  if (!boolean) {
    throw new Constructor(message);
  }
};

const {
  Boolean,
  String: String$1,
  Number,
  parseInt: parseInt$1,
  Array: { isArray: isArray$2 },
  Number: {
    isNaN,
    NaN: NaN$1,
    NEGATIVE_INFINITY,
    POSITIVE_INFINITY,
    MAX_SAFE_INTEGER,
    MIN_SAFE_INTEGER,
  },
  Math: { round },
  JSON: { stringify: stringifyJSON$3 },
} = globalThis;

const print = (any) => {
  if (typeof any === "function") {
    return "[function]";
  } else if (isArray$2(any)) {
    return "[array]";
  } else if (typeof any === "object" && any !== null) {
    return "[object]";
  } else if (typeof any === "string") {
    return stringifyJSON$3(any);
  } else {
    return String$1(any);
  }
};

const {
  Error: Error$4,
  String,
  JSON: { stringify: stringifyJSON$2 },
} = globalThis;

const format = (template, values) => {
  let index = 0;
  const { length } = values;
  const message = template.replace(
    /(%+)($|[^%])/gu,
    (_match, escape, marker) => {
      if (escape.length >= 2) {
        return `${escape.substring(1)}${marker}`;
      }
      assert(index < length, "missing format value", AssertionError);
      const value = values[index];
      index += 1;
      if (marker === "s") {
        assert(
          typeof value === "string",
          "expected a string for format",
          AssertionError,
        );
        return value;
      }
      if (marker === "f") {
        const print = value();
        assert(
          typeof print === "string",
          "expected a string as result",
          AssertionError,
        );
        return print;
      }
      if (marker === "j") {
        return stringifyJSON$2(value);
      }
      if (marker === "O") {
        try {
          return String(value);
        } catch {
          return print(value);
        }
      }
      if (marker === "o") {
        return print(value);
      }
      throw new Error$4("invalid format marker");
    },
  );
  assert(index === length, "missing format marker", AssertionError);
  return message;
};

const {
  Error: Error$3,
  Reflect: { apply },
  WeakMap,
} = globalThis;

new WeakMap();

const noop = () => {};
const identity = (x) => x;
const constant = (x) => () => x;

// export const applySafe = (closure, context, inputs, log, recovery) => {
//   try {
//     return apply(closure, context, inputs);
//   } catch (error) {
//     log(error);
//     return recovery;
//   }
// };

const mapMaybe = (maybe, transform) =>
  maybe === null ? null : transform(maybe);

const {
  undefined: undefined$5,
  Object: Object$1,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$2, ownKeys: ownKeys$1, defineProperty: defineProperty$1 },
} = globalThis;

/* c8 ignore start */
const hasOwnProperty =
  getOwnPropertyDescriptor$2(Object$1, "hasOwn") === undefined$5
    ? (object, key) => getOwnPropertyDescriptor$2(object, key) !== undefined$5
    : Object$1.hasOwn;
/* c8 ignore stop */

const getOwnProperty = (object, key, _default) =>
  hasOwnProperty(object, key) ? object[key] : _default;

const coalesce = (value, key, _default) => {
  if (
    typeof value === "function" ||
    (typeof value === "object" && value !== null)
  ) {
    return getOwnProperty(value, key, _default);
  }
  return _default;
};

/* eslint-disable local/global-object-access */

const {
  undefined: undefined$4,
  ReferenceError,
  Reflect: { defineProperty },
} = globalThis;

const readGlobal = (name) => {
  if (hasOwnProperty(globalThis, name)) {
    return globalThis[name];
  } else {
    throw ReferenceError("missing global variable");
  }
};

// NB: Synchronous loggin is important to avoid infinite loop when async hooks are enabled.

const { URL: URL$5 } = globalThis;

const openLogFile = (specifier) => {
  if (typeof specifier === "number") {
    return specifier;
  } else if (typeof specifier === "string") {
    return openSync(new URL$5(specifier), "w");
  } else {
    throw new InternalAppmapError("invalid specifier type for log file");
  }
};

const generateLog$1 = (fd, name) => (message) => {
  writeSync(fd, `APPMAP-${name} ${message}\n`);
};

const makeLog = (specifier) => {
  const fd = openLogFile(specifier);
  return {
    logDebug: generateLog$1(fd, "DEBUG"),
    logInfo: generateLog$1(fd, "INFO"),
    logWarning: generateLog$1(fd, "WARNING"),
    logError: generateLog$1(fd, "ERROR"),
  };
};

const { logDebug: logDebug$1, logInfo: logInfo$1, logWarning: logWarning$1, logError: logError$1 } = makeLog(
  readGlobal("__APPMAP_LOG_FILE__"),
);

const levels = {
  debug: 1,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};

const max_level = readGlobal("__APPMAP_LOG_LEVEL__");

assert(
  hasOwnProperty(levels, max_level),
  "invalid log level",
  InternalAppmapError,
);

const generateLog = (level, log) => {
  if (levels[level] < levels[max_level]) {
    return {
      log: noop,
      logWhen: noop,
      logAssert: assert,
    };
  } else {
    return {
      log: (template, ...rest) => {
        log(format(template, rest));
      },
      logWhen: (guard, template, ...rest) => {
        if (guard) {
          log(format(template, rest));
        }
        return guard;
      },
    };
  }
};

const { log: logDebug, logWhen: logDebugWhen } = generateLog(
  "debug",
  logDebug$1,
);

const { log: logInfo, logWhen: logInfoWhen } = generateLog(
  "info",
  logInfo$1,
);

const { log: logWarning, logWhen: logWarningWhen } = generateLog(
  "warning",
  logWarning$1,
);

const { log: logError, logWhen: logErrorWhen } = generateLog(
  "error",
  logError$1,
);

const {
  undefined: undefined$3,
  Reflect: { getOwnPropertyDescriptor: getOwnPropertyDescriptor$1 },
  Error: Error$2,
  Set: Set$1,
  /* c8 ignore start */
  Object: {
    hasOwn: hasOwn$1 = (obj, key) => getOwnPropertyDescriptor$1(obj, key) !== undefined$3,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath$1, relative: unresolvePath$1 } = win32;

const getBasename = (filename) =>
  filename.includes(".") ? filename.split(".")[0] : filename;

const forbidden = new Set$1([
  "CON",
  "PRN",
  "AUX",
  "NUL",
  "COM1",
  "COM2",
  "COM3",
  "COM4",
  "COM5",
  "COM6",
  "COM7",
  "COM8",
  "COM9",
  "LPT1",
  "LPT2",
  "LPT3",
  "LPT4",
  "LPT5",
  "LPT6",
  "LPT7",
  "LPT8",
  "LPT9",
]);

const sanitizePathFilename$2 = (filename) => {
  filename = filename.replace(/[\u0000-\u001F,\u0080-\u009F/?<>\\:*|"]/gu, "-");
  if (
    filename === "" ||
    filename.endsWith(".") ||
    filename.endsWith(" ") ||
    forbidden.has(getBasename(filename).toUpperCase())
  ) {
    filename = `_${filename}_`;
  }
  return filename;
};

const getShell$2 = (env) =>
  hasOwn$1(env, "COMSPEC") ? env.COMSPEC : "cmd.exe";

const ipc = "\\\\.\\pipe\\";

const toIpcPath$2 = (path) => `${ipc}${path}`;

const fromIpcPath$2 = (path) => {
  if (path.startsWith(ipc)) {
    return path.substring(ipc.length);
  } else {
    throw new Error$2("not an ipc path");
  }
};

const toDirectoryPath$2 = (path) =>
  path.endsWith("/") || path.endsWith("\\") ? path : `${path}\\`;

const toAbsolutePath$2 = (relative, base) => {
  const path =
    base.endsWith("/") || base.endsWith("\\")
      ? resolvePath$1(base, relative)
      : resolvePath$1(base, "..", relative);
  return relative.endsWith("/") || relative.endsWith("\\") ? `${path}\\` : path;
};

const toRelativePath$2 = (path, base) => {
  const relative = unresolvePath$1(
    base.endsWith("/") || base.endsWith("\\") ? base : `${base}\\..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/") || path.endsWith("\\")) {
    return `${relative}\\`;
  } else {
    return relative;
  }
};

const getPathFilename$2 = (path) => {
  const parts = /[\\/]([^\\/]*)$/u.exec(path);
  if (parts === null) {
    return null;
  } else {
    const filename = parts[1];
    return filename === "" ? null : filename;
  }
};

var Win32 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$2,
  getShell: getShell$2,
  toIpcPath: toIpcPath$2,
  fromIpcPath: fromIpcPath$2,
  toDirectoryPath: toDirectoryPath$2,
  toAbsolutePath: toAbsolutePath$2,
  toRelativePath: toRelativePath$2,
  getPathFilename: getPathFilename$2
});

const {
  undefined: undefined$2,
  Reflect: { getOwnPropertyDescriptor },
  /* c8 ignore start */
  Object: {
    hasOwn = (obj, key) => getOwnPropertyDescriptor(obj, key) !== undefined$2,
  },
  /* c8 ignore stop */
} = globalThis;

const { resolve: resolvePath, relative: unresolvePath } = posix;

const sanitizePathFilename$1 = (filename) =>
  // Escape `.` and `..`
  /^\.*$/u.test(filename)
    ? `...${filename}`
    : filename.replace(/\\/gu, "\\\\").replace(/\//gu, "\\");

const getShell$1 = (env) => (hasOwn(env, "SHELL") ? env.SHELL : "/bin/sh");

const toIpcPath$1 = (path) => path;

const fromIpcPath$1 = (path) => path;

const toDirectoryPath$1 = (path) =>
  path.endsWith("/") ? path : `${path}/`;

const toAbsolutePath$1 = (relative, base) => {
  const path = base.endsWith("/")
    ? resolvePath(base, relative)
    : resolvePath(base, "..", relative);
  return relative.endsWith("/") ? `${path}/` : path;
};

const toRelativePath$1 = (path, base) => {
  const relative = unresolvePath(
    base.endsWith("/") ? base : `${base}/..`,
    path,
  );
  if (relative === "") {
    return ".";
  } else if (path.endsWith("/")) {
    return `${relative}/`;
  } else {
    return relative;
  }
};

const getPathFilename$1 = (path) => {
  const segments = path.split("/");
  const filename = segments[segments.length - 1];
  return filename === "" ? null : filename;
};

var Posix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitizePathFilename: sanitizePathFilename$1,
  getShell: getShell$1,
  toIpcPath: toIpcPath$1,
  fromIpcPath: fromIpcPath$1,
  toDirectoryPath: toDirectoryPath$1,
  toAbsolutePath: toAbsolutePath$1,
  toRelativePath: toRelativePath$1,
  getPathFilename: getPathFilename$1
});

const convertPathToFileUrl = (path) =>
  pathToFileURL(path).href;

/* c8 ignore start */
const {
  getPathFilename,
  // This function convert an arbitrary string to a valid platform-specific filename.
  // For instance, it replaces path separator.
  sanitizePathFilename,
  getShell,
  toIpcPath,
  fromIpcPath,
  toDirectoryPath,
  toAbsolutePath,
  toRelativePath,
} = platform() === "win32" ? Win32 : Posix;

const {
  URL: URL$4,
  JSON: { parse: parseJSON$2 },
} = globalThis;

//////////////////////////////
// extractRepositoryPackage //
//////////////////////////////

const readPackage = (url) => {
  try {
    return {
      url,
      content: readFileSync(new URL$4("package.json", url), "utf8"),
    };
  } catch (error) {
    logWarning("Cannot read package.json file at %j >> %O", url, error);
    return null;
  }
};

const parsePackage = ({ url, content }) => {
  try {
    return {
      url,
      data: parseJSON$2(content),
    };
  } catch (error) {
    logWarning("Cannot parse package.json file at %j >> %O", url, error);
    return null;
  }
};

const summarizePackage = ({ url, data }) => {
  const { name, version, homepage } = {
    name: null,
    version: null,
    homepage: null,
    ...data,
  };
  if (typeof name !== "string") {
    logWarning(
      "Invalid type for name property in package.json file at %j, got: %j",
      url,
      name,
    );
    return null;
  } else if (typeof version !== "string") {
    logWarning(
      "Invalid type for version property in package.json file at %j, got %j",
      url,
      version,
    );
    return null;
  } else {
    return {
      name,
      version,
      homepage: typeof homepage === "string" ? homepage : null,
    };
  }
};

const extractRepositoryPackage = (url) =>
  mapMaybe(mapMaybe(readPackage(url), parsePackage), summarizePackage);

const { URL: URL$3 } = globalThis;

const spawn = (exec, argv, url) => {
  const result = spawnSync(exec, argv, {
    cwd: fileURLToPath(new URL$3(".", url)),
    encoding: "utf8",
    timeout: 1000,
    stdio: ["ignore", "pipe", "pipe"],
  });
  const error = coalesce(result, "error", null);
  assert(
    !logErrorWhen(
      error !== null,
      "Executable %j with argv %j on cwd %j threw an error >> %O",
      exec,
      argv,
      url,
      error,
    ),
    "Failed to spawn executable",
    ExternalAppmapError,
  );
  const { signal, status, stdout, stderr } = result;
  assert(
    !logErrorWhen(
      signal !== null,
      "Executable %j with argv %j on cwd %j was killed with %j",
      exec,
      argv,
      url,
      signal,
    ),
    "Command exit with unexpected kill signal",
    ExternalAppmapError,
  );
  if (status === 0) {
    return stdout.trim();
  } else {
    logWarning(
      "Executable %j with argv %j on cwd %j failed with %j >> %s",
      exec,
      argv,
      url,
      status,
      stderr,
    );
    return null;
  }
};

const { URL: URL$2, parseInt } = globalThis;

const trim = (string) => string.trim();

const parseStatus = (stdout) => stdout.split("\n").map(trim);

const parseDescription = (stdout) => {
  const parts = /^([^-]*)-([0-9]+)-/u.exec(stdout);
  /* c8 ignore start */
  if (parts === null) {
    logWarning("Failed to parse git description %j", stdout);
    return 0;
  }
  /* c8 ignore stop */
  return parseInt(parts[2], 10);
};

const readRepository = (url) => {
  try {
    return readdirSync(new URL$2(url));
  } catch (error) {
    logError("Could not read repository directory %j >> %O", url, error);
    throw new ExternalAppmapError("Could not read repository directory");
  }
};

const extractRepositoryHistory = (url) => {
  if (readRepository(url).includes(".git")) {
    return {
      repository: spawn("git", ["config", "--get", "remote.origin.url"], url),
      branch: spawn("git", ["rev-parse", "--abbrev-ref", "HEAD"], url),
      commit: spawn("git", ["rev-parse", "HEAD"], url),
      status: mapMaybe(
        spawn("git", ["status", "--porcelain"], url),
        parseStatus,
      ),
      tag: spawn("git", ["describe", "--abbrev=0", "--tags"], url),
      annotated_tag: spawn("git", ["describe", "--abbrev=0"], url),
      commits_since_tag: mapMaybe(
        spawn("git", ["describe", "--long", "--tags"], url),
        parseDescription,
      ),
      commits_since_annotated_tag: mapMaybe(
        spawn("git", ["describe", "--long"], url),
        parseDescription,
      ),
    };
  } else {
    logWarning("Repository directory %j is not a git directory", url);
    return null;
  }
};

const { Minimatch: MinimatchClass } = Minimatch;

const compileGlob = (glob) => new MinimatchClass(glob).makeRe();

const { Map, RegExp } = globalThis;

new Map();

const escape = (char) => `\\${char}`;

const sanitizeForRegExp = (string) =>
  string.replace(/[/\\+*?.^$()[\]{}|]/gu, escape);

// const sanitizeForGlob = (string) => string.replace(/[*?[\]]/g, escape);

const toTargetRegExp = (target, recursive) => {
  if (recursive) {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}`;
    } else {
      return `^${sanitizeForRegExp(target)}(/|$)`;
    }
  } else {
    if (target.endsWith("/")) {
      return `^${sanitizeForRegExp(target)}[^/]*$`;
    } else {
      return `^${sanitizeForRegExp(target)}$`;
    }
  }
};

const createMatcher = (options, base) => {
  const {
    glob,
    url,
    path,
    dist,
    regexp,
    flags,
    recursive,
    external,
    relative,
  } = {
    glob: null,
    path: null,
    url: null,
    dist: null,
    regexp: null,
    flags: "",
    recursive: true,
    external: false,
    relative: true,
    ...options,
  };
  if (regexp !== null) {
    return {
      base: relative ? base : null,
      source: regexp,
      flags,
    };
  }
  if (glob !== null) {
    const { source, flags } = compileGlob(glob);
    return {
      base,
      source,
      flags,
    };
  }
  if (path !== null) {
    return {
      base,
      source: toTargetRegExp(path, recursive),
      flags: "",
    };
  }
  if (url !== null) {
    return {
      base: null,
      source: toTargetRegExp(url, recursive),
      flags: "",
    };
  }
  if (dist !== null) {
    assert(
      dist[dist.length - 1] !== "/",
      "package path should not end with a path separator",
      InternalAppmapError,
    );
    let source = `node_modules/${sanitizeForRegExp(dist)}/`;
    if (!external) {
      source = `^${source}`;
    }
    if (!recursive) {
      source = `${source}[^/]*$`;
    }
    return {
      base,
      source,
      flags: "",
    };
  }
  throw new InternalAppmapError("invalid matcher options");
};

const {
  Array: { isArray: isArray$1 },
  Reflect: { ownKeys },
  Object: { entries: toEntries$1 },
} = globalThis;

const HOOK_APPLY_GLOBAL = "APPMAP_HOOK_APPLY";

const HOOK_EVAL_GLOBAL = "APPMAP_HOOK_EVAL";

const EXPECTED_EXTRA_PROPERTIES = ["test_recording"];

////////////
// Extend //
////////////

const assign = (value1, value2) => ({ ...value1, ...value2 });

const overwrite = (_value1, value2) => value2;

// const append = (value1, value2) => [...value1, ...value2];

const prepend = (value1, value2) => [...value2, ...value1];

const extendCommandOptions = (options1, options2) => ({
  ...options1,
  ...options2,
  env: {
    ...coalesce(options1, "env", {}),
    ...coalesce(options2, "env", {}),
  },
});

///////////////
// Normalize //
///////////////

const normalizeDefaultProcess = (default_process, _base) => {
  if (typeof default_process === "boolean") {
    return { enabled: default_process };
  } else {
    return {
      enabled: false,
      ...default_process,
    };
  }
};

const normalizeExclusion = (exclusion, _base) => {
  if (typeof exclusion === "string") {
    exclusion = {
      "qualified-name": exclusion,
      recursive: true,
    };
  }
  const default_value = coalesce(exclusion, "combinator", "and") === "and";
  return {
    combinator: "and",
    "qualified-name": default_value,
    name: default_value,
    "every-label": default_value,
    "some-label": default_value,
    excluded: true,
    recursive: false,
    ...exclusion,
  };
};

const normalizeCommandOptions = (options, base) => ({
  shell: false,
  encoding: "utf8",
  env: {},
  stdio: "inherit",
  timeout: 0,
  killSignal: "SIGTERM",
  ...options,
  cwd: hasOwnProperty(options, "cwd")
    ? toDirectoryUrl(toAbsoluteUrl(options.cwd, base))
    : toAbsoluteUrl(".", base),
});

const normalizeHooks = (hooks, _base) => {
  if (hasOwnProperty(hooks, "eval")) {
    hooks.eval =
      typeof hooks.eval === "boolean"
        ? {
            hidden: HOOK_EVAL_GLOBAL,
            aliases: hooks.eval ? ["eval"] : [],
          }
        : hooks.eval;
  }
  if (hasOwnProperty(hooks, "apply")) {
    hooks.apply =
      typeof hooks.apply === "boolean"
        ? hooks.apply
          ? HOOK_APPLY_GLOBAL
          : null
        : hooks.apply;
  }
  return hooks;
};

const normalizeDefaultPackage = (package_, _base) => {
  if (typeof package_ === "boolean") {
    package_ = { enabled: package_ };
  }
  return {
    enabled: true,
    shallow: false,
    exclude: [],
    "inline-source": null,
    "source-type": null,
    parsing: null,
    ...package_,
  };
};

const normalizeAgent = ({ directory, package: _package }, base) => ({
  directory: toDirectoryUrl(toAbsoluteUrl(directory, base)),
  package: _package,
});

const normalizeDirectoryUrl = (url, base) =>
  toDirectoryUrl(toAbsoluteUrl(url, base));

const normalizeExclude = (exclusions, _base) =>
  exclusions.map(normalizeExclusion);

const normalizeCommand = (command, _base) => ({
  source: typeof command === "string" ? command : null,
  tokens: typeof command === "string" ? null : command,
});

const normalizeScenarios = (scenarios, base) =>
  toEntries$1(scenarios).map(([key, value]) => ({
    base,
    key,
    value,
  }));

const normalizeLog = (log, base) => {
  if (typeof log === "string") {
    log = { level: log };
  }
  if (hasOwnProperty(log, "file") && typeof log.file !== "number") {
    log.file = toAbsoluteUrl(log.file, base);
  }
  return log;
};

const normalizePort = (port, base) => {
  if (typeof port === "string" && port !== "") {
    port = toAbsoluteUrl(port, base);
  }
  return port;
};

const generateNormalizeSplit = (separator, key1, key2) => (value) => {
  if (typeof value === "string") {
    const segments = value.split(separator);
    return {
      [key1]: segments[0],
      [key2]: segments.length === 1 ? null : segments[1],
    };
  }
  return value;
};

const normalizeRecording = generateNormalizeSplit(
  ".",
  "defined-class",
  "method-id",
);

const normalizeFramework = generateNormalizeSplit("@", "name", "version");

const normalizeFrameworkArray = (frameworks) =>
  frameworks.map(normalizeFramework);

const normalizePackageMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const {
    enabled,
    shallow,
    "inline-source": inline_source,
    exclude,
    "source-type": source_type,
    parsing,
    ...rest
  } = {
    enabled: true,
    "inline-source": null,
    shallow: hasOwnProperty(matcher, "dist"),
    exclude: [],
    "source-type": null,
    parsing: null,
    ...matcher,
  };
  return [
    createMatcher(rest, base),
    {
      enabled,
      "inline-source": inline_source,
      shallow,
      exclude: exclude.map(normalizeExclusion),
      "source-type": source_type,
      parsing,
    },
  ];
};

const normalizePackageMatcherArray = (matchers, base) => {
  if (!isArray$1(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizePackageMatcher(matcher, base));
};

const normalizeProcessMatcher = (matcher, base) => {
  if (typeof matcher === "string") {
    matcher = { glob: matcher };
  }
  const { enabled, ...rest } = {
    enabled: true,
    ...matcher,
  };
  return [createMatcher(rest, base), { enabled }];
};

const normalizeProcesseMatcherArray = (matchers, base) => {
  if (!isArray$1(matchers)) {
    matchers = [matchers];
  }
  return matchers.map((matcher) => normalizeProcessMatcher(matcher, base));
};

////////////
// fields //
////////////

const fields = {
  socket: {
    extend: overwrite,
    normalize: identity,
  },
  heartbeat: {
    extend: overwrite,
    normalize: identity,
  },
  threshold: {
    extend: overwrite,
    normalize: identity,
  },
  agent: {
    extend: overwrite,
    normalize: normalizeAgent,
  },
  repository: {
    extend: overwrite,
    normalize: identity,
  },
  scenario: {
    extend: overwrite,
    normalize: identity,
  },
  scenarios: {
    extend: overwrite,
    normalize: normalizeScenarios,
  },
  "recursive-process-recording": {
    extend: overwrite,
    normalize: identity,
  },
  "postmortem-function-exclusion": {
    extend: overwrite,
    normalize: identity,
  },
  command: {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-win32": {
    extend: overwrite,
    normalize: normalizeCommand,
  },
  "command-options": {
    extend: extendCommandOptions,
    normalize: normalizeCommandOptions,
  },
  validate: {
    extend: assign,
    normalize: identity,
  },
  log: {
    extend: assign,
    normalize: normalizeLog,
  },
  host: {
    extend: overwrite,
    normalize: identity,
  },
  session: {
    extend: overwrite,
    normalize: identity,
  },
  sessions: {
    extend: overwrite,
    normalize: identity,
  },
  "proxy-port": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "http-switch": {
    extend: overwrite,
    normalize: identity,
  },
  "trace-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "track-port": {
    extend: overwrite,
    normalize: normalizePort,
  },
  "track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-port": {
    extend: overwrite,
    normalize: identity,
  },
  "intercept-track-protocol": {
    extend: overwrite,
    normalize: identity,
  },
  enabled: {
    extend: overwrite,
    normalize: identity,
  },
  "default-process": {
    extend: overwrite,
    normalize: normalizeDefaultProcess,
  },
  processes: {
    extend: prepend,
    normalize: normalizeProcesseMatcherArray,
  },
  recorder: {
    extend: overwrite,
    normalize: identity,
  },
  "inline-source": {
    extend: overwrite,
    normalize: identity,
  },
  hooks: {
    extend: assign,
    normalize: normalizeHooks,
  },
  ordering: {
    extend: overwrite,
    normalize: identity,
  },
  "collapse-package-hierachy": {
    extend: overwrite,
    normalize: identity,
  },
  serialization: {
    extend: assign,
    normalize: identity,
  },
  main: {
    extend: overwrite,
    normalize: toAbsoluteUrl,
  },
  language: {
    extend: overwrite,
    normalize: identity,
  },
  engine: {
    extend: overwrite,
    normalize: identity,
  },
  "default-package": {
    extend: overwrite,
    normalize: normalizeDefaultPackage,
  },
  packages: {
    extend: prepend,
    normalize: normalizePackageMatcherArray,
  },
  exclude: {
    extend: prepend,
    normalize: normalizeExclude,
  },
  recording: {
    extend: overwrite,
    normalize: normalizeRecording,
  },
  appmap_dir: {
    extend: overwrite,
    normalize: normalizeDirectoryUrl,
  },
  appmap_file: {
    extend: overwrite,
    normalize: identity,
  },
  name: {
    extend: overwrite,
    normalize: identity,
  },
  "map-name": {
    extend: overwrite,
    normalize: identity,
  },
  pruning: {
    extend: overwrite,
    normalize: identity,
  },
  labels: {
    extend: prepend,
    normalize: identity,
  },
  feature: {
    extend: overwrite,
    normalize: identity,
    initial: null,
  },
  "feature-group": {
    extend: overwrite,
    normalize: identity,
  },
  frameworks: {
    extend: prepend,
    normalize: normalizeFrameworkArray,
  },
};

const extendConfiguration = (
  internal_configuration,
  external_configuration,
  base,
) => {
  const extended_internal_configuration = { ...internal_configuration };
  for (const key of ownKeys(external_configuration)) {
    if (hasOwnProperty(fields, key)) {
      const { normalize, extend } = fields[key];
      extended_internal_configuration[key] = extend(
        extended_internal_configuration[key],
        normalize(external_configuration[key], base),
      );
    } else {
      logInfoWhen(
        !EXPECTED_EXTRA_PROPERTIES.includes(key),
        "Configuration property not recognized by the agent: %j",
        key,
      );
    }
  }
  return extended_internal_configuration;
};

const resolveConfigurationRepository = (configuration) => {
  assert(
    configuration.agent === null,
    "duplicate respository resolution",
    InternalAppmapError,
  );
  const { directory } = configuration.repository;
  const { name, version, homepage } = self_package;
  return extendConfiguration(
    configuration,
    {
      agent: {
        directory: self_directory,
        package: { name, version, homepage },
      },
      repository: {
        directory,
        history: extractRepositoryHistory(directory),
        package: extractRepositoryPackage(directory),
      },
    },
    directory,
  );
};

// NODE_OPTIONS format is not platform-specific
// It is also not well documented but it seems to only require whitespace escaping.
// - https://github.com/nodejs/node/issues/12971
// - https://github.com/nodejs/node/commit/2eb627301c1f6681ec51f43b84e37f3908514853
// - https://nodejs.org/api/cli.html#node_optionsoptions
// - https://github.com/nodejs/node/blob/80270994d6ba6019a6a74adc1b97a0cc1bd343ed/src/node_options.cc
const escapeNodeOption = (token) => {
  assert(
    !token.includes(" "),
    "spaces should have been percent-encoded",
    InternalAppmapError,
  );
  return token;
};

const resolveShell = (shell, env) => {
  if (shell === false) {
    return null;
  } else if (shell === true) {
    return getShell(env);
  } else {
    return shell;
  }
};

const space = /^\s$/u;

const tokenizeShell = (source) => {
  const tokens = [];
  let token = "";
  let escaped = false;
  let quote = null;
  for (const char of source) {
    token += char;
    if (quote === "'") {
      if (char === "'") {
        quote = null;
      }
    } else if (escaped) {
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote === '"') {
      if (char === '"') {
        quote = null;
      }
    } else if (space.test(char)) {
      if (token.length > 1) {
        tokens.push(token.substring(0, token.length - 1));
      }
      token = "";
    } else if (char === '"' || char === "'") {
      quote = char;
    }
  }
  if (token !== "") {
    tokens.push(token);
  }
  assert(
    !logErrorWhen(quote !== null, "unterminated quote on command %s", source),
    "unterminated quote on command",
    ExternalAppmapError,
  );
  assert(
    !logErrorWhen(escaped, "missing escaped character on command %s", source),
    "missing escaped character",
    ExternalAppmapError,
  );
  return tokens;
};

// https://github.com/nodejs/node/blob/e58ed6d855e1af6579aaa50471426db8881eea99/lib/child_process.js#L628
const tokenize = (source, shell) => {
  if (shell === null) {
    return tokenizeShell(source);
  } else if (/^(?:.*\\)?cmd(?:\.exe)?$/iu.test(shell)) {
    return [shell, "/d", "/s", "/c", `"${source}"`];
  } else {
    return [shell, "-c", source];
  }
};

const isPrefixArray = (prefix, array) => {
  const { length } = prefix;
  if (length > array.length) {
    return false;
  } else {
    for (let index = 0; index < length; index += 1) {
      if (prefix[index] !== array[index]) {
        return false;
      }
    }
    return true;
  }
};

const findScriptIndex = (tokens, index) => {
  if (index < tokens.length) {
    const token = tokens[index];
    // In the node cli, `-` indicates that the script
    // is read from the stdin. In that case, we should
    // not return any index. For instance:
    // `node - foo.js`
    if (token === "-") {
      return null;
      // In the CLI of node, npm and npx: `--` indicates
      // the the script argument is following.
    } else if (token === "--") {
      return index + 1 < tokens.length ? index + 1 : null;
      // We only support named argument of the form
      // `--foo=bar` and not `--foo bar`.
    } else if (token.startsWith("-")) {
      return findScriptIndex(tokens, index + 1);
    } else {
      return index;
    }
  } else {
    return null;
  }
};

const executables = [
  ["node"],
  ["npm", "exec"],
  ["npm.cmd", "exec"],
  ["npm", "x"],
  ["npm.cmd", "x"],
  ["npx"],
  ["npx.cmd"],
  ["yarn", "exec"],
  ["yarn.cmd", "exec"],
  ["yarn", "node"],
  ["yarn.cmd", "node"],
  [],
];

const splitTokens = (tokens) => {
  const executable = executables.find((executable) =>
    isPrefixArray(executable, tokens),
  );
  const positional = findScriptIndex(tokens, executable.length);
  assert(
    !logErrorWhen(
      positional === null,
      "could not parse and hook command because of missing positional argument, got %j",
      tokens,
    ),
    "could not parse and hook command",
    ExternalAppmapError,
  );
  return {
    __proto__: null,
    exec: tokens.slice(0, positional + 1),
    argv: tokens.slice(positional + 1),
  };
};

const sniffTokens = (tokens, name) => {
  const executable = executables.find((executable) =>
    isPrefixArray(executable, tokens),
  );
  const positional = findScriptIndex(tokens, executable.length);
  return positional !== null && tokens[positional].includes(name);
};

const name$5 = "mocha";
const recursive$5 = null;

const doesSupport$7 = (tokens) => sniffTokens(tokens, "mocha");

const hookCommandAsync$5 = (tokens, self, _base) => {
  const { exec, argv } = splitTokens(tokens);
  return [
    ...exec,
    "--require",
    fileURLToPath(toAbsoluteUrl("lib/node/mocha-hook.mjs", self)),
    ...argv,
  ];
};

const hookEnvironment$5 = (env, self, _base) => ({
  ...env,
  NODE_OPTIONS: `${coalesce(
    env,
    "NODE_OPTIONS",
    "",
  )} --experimental-loader=${escapeNodeOption(
    toAbsoluteUrl("lib/node/recorder.mjs", self),
  )}`,
});

var MochaRecorder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$5,
  recursive: recursive$5,
  doesSupport: doesSupport$7,
  hookCommandAsync: hookCommandAsync$5,
  hookEnvironment: hookEnvironment$5
});

const {
  URL: URL$1,
  JSON: { parse: parseJson },
} = globalThis;

const loadJsonAsync = async (url) =>
  parseJson(await readFile(new URL$1(url), "utf8"));

const loadYamlAsync = async (url) =>
  parse(await readFile(new URL$1(url), "utf8"));

const loaders = {
  ".json": loadJsonAsync,
  ".yaml": loadYamlAsync,
  ".yml": loadYamlAsync,
};

const loadAsync = async (url) => {
  const extension = getLastUrlExtension(url);
  if (hasOwnProperty(loaders, extension)) {
    return await loaders[extension](url);
  } else {
    // Can load both cjs and esm modules
    // cf: https://nodejs.org/api/packages.html#packagejson-and-file-extensions
    // Currently, we do not support typescript.
    return (await import(url)).default;
  }
};

const isLoadMissingError = (error) =>
  hasOwnProperty(error, "code") &&
  (error.code === "ENOENT" ||
    error.code === "ERR_MODULE_NOT_FOUND" ||
    error.code === "MODULE_NOT_FOUND");

const {
  URL,
  JSON: { parse: parseJSON$1 },
} = globalThis;

const loadConfigFileAsync = async (url, strict) => {
  try {
    return await loadAsync(url);
  } catch (error) {
    if (!strict && isLoadMissingError(error)) {
      return null;
    } else {
      logError(
        "Failed to load jest configuration file at %j >> %O",
        url,
        error,
      );
      throw new ExternalAppmapError("Failed to load jest configuration file");
    }
  }
};

const loadPackageJsonAsync = async (directory) => {
  try {
    return parseJSON$1(
      await readFile(
        new URL(toAbsoluteUrl("package.json", directory)),
        "utf8",
      ),
    );
  } catch (error) {
    if (hasOwnProperty(error, "code") && error.code === "ENOENT") {
      return null;
    } else {
      logError("Could not load package.json from %j >> %O", directory, error);
      throw new ExternalAppmapError("Could not load package.json");
    }
  }
};

const loadJestConfigAsync = async (options, { root, base }) => {
  if (hasOwnProperty(options, "config")) {
    return await loadConfigFileAsync(toAbsoluteUrl(options.config, base), true);
  } else {
    const { jest: maybe_package_config } = {
      jest: null,
      ...(await loadPackageJsonAsync(root)),
    };
    if (maybe_package_config !== null) {
      return maybe_package_config;
    } else {
      for (const extension of [".ts", ".js", ".cjs", ".mjs", ".json"]) {
        const maybe_config = await loadConfigFileAsync(
          toAbsoluteUrl(`jest.config${extension}`, root),
          false,
        );
        if (maybe_config !== null) {
          return maybe_config;
        }
      }
      return {};
    }
  }
};

const PRESET_FILE_NAME_ARRAY = [
  "jest-preset.json",
  "jest-preset.js",
  "jest-preset.cjs",
  "jest-preset.mjs",
];

const resolvePresetSpecifier = (specifier, root) => {
  if (specifier.startsWith("./") || specifier.startsWith("../")) {
    return toAbsoluteUrl(specifier, root);
  } else {
    const { resolve } = createRequire(new URL(root));
    for (const filename of PRESET_FILE_NAME_ARRAY) {
      const sub_specifier = `${specifier}/${filename}`;
      try {
        return convertPathToFileUrl(resolve(sub_specifier));
      } catch (error) {
        logDebug(
          "Could not resolve jest preset at %j >> %O",
          sub_specifier,
          error,
        );
      }
    }
    logError("Could not resolve jest preset at %j", specifier);
    throw new ExternalAppmapError("Could not resolve jest preset");
  }
};

const resolveJestPresetAsync = async (config, root) => {
  if (hasOwnProperty(config, "preset")) {
    return {
      ...(await loadConfigFileAsync(
        resolvePresetSpecifier(config.preset, root),
        true,
      )),
      ...config,
      preset: null,
    };
  } else {
    return config;
  }
};

const {
  JSON: { stringify: stringifyJSON$1, parse: parseJSON },
  Object: { entries: toEntries, fromEntries },
  Array: { isArray },
} = globalThis;

const { default: minimist } = Minimist;

const hook = fileURLToPath(
  toAbsoluteUrl("lib/node/transformer-jest.mjs", self_directory),
);

const extractTransformEntryValue = (value) => {
  if (typeof value === "string") {
    return { specifier: value, options: {} };
  } else {
    assert(
      !logErrorWhen(
        !isArray(value) || value.length !== 2 || typeof value[0] !== "string",
        "Invalid transform field, expected transform field to be either a string or an array of length two whose first element is a string: %j",
        value,
      ),
      "Invalid transform field",
      ExternalAppmapError,
    );
    return { specifier: value[0], options: value[1] };
  }
};

const compileHookTransformEntry = (root) => {
  const replacement = constant(fileURLToPath(root));
  return ([key, value]) => {
    const { specifier, options } = extractTransformEntryValue(value);
    return [
      key,
      {
        specifier: specifier.replace(/<rootDir>\//gu, replacement),
        options,
      },
    ];
  };
};

const hookTransformObject = (transform, root) => ({
  "^": [
    hook,
    fromEntries(toEntries(transform).map(compileHookTransformEntry(root))),
  ],
});

const hookJestArgvAsync = async (argv, base) => {
  if (!argv.includes("--no-cache")) {
    argv = ["--no-cache", ...argv];
  }
  const options = minimist(argv);
  const root = hasOwnProperty(options, "rootDir")
    ? toDirectoryUrl(toAbsoluteUrl(options.rootDir, base))
    : base;
  if (hasOwnProperty(options, "transform")) {
    const index = argv.indexOf("--transform");
    assert(
      !logErrorWhen(
        index !== argv.lastIndexOf("--transform"),
        "Jest `--transform` argument should not be duplicate: %j",
        argv,
      ),
      "Jest --transform argument should not be duplicate",
      ExternalAppmapError,
    );
    assert(
      !logErrorWhen(
        index === argv.length - 1,
        "Jest `--transform` argument should not be in last postion: %j",
        argv,
      ),
      "Jest `--transform` argument should not be in last postion",
      ExternalAppmapError,
    );
    let transform = argv[index + 1];
    try {
      transform = parseJSON(transform);
    } catch (error) {
      logError(
        "Jest `--transform` argument should be a json string: %j >> %O",
        transform,
        error,
      );
      throw new ExternalAppmapError(
        "Jest --transform argument should be a json string",
      );
    }
    return [
      ...argv.slice(0, index + 1),
      stringifyJSON$1(hookTransformObject(transform, root)),
      ...argv.slice(index + 2, argv.length),
    ];
  } else {
    const config = await resolveJestPresetAsync(
      await loadJestConfigAsync(options, { root, base }),
      root,
    );
    const transform = hasOwnProperty(config, "transform")
      ? config.transform
      : // Default jest transformer.
        // cf: https://jestjs.io/docs/code-transformation#defaults
        // Unfortunately `require("jest-config").defaults.transform` is undefined
        { "\\.[jt]sx?$": "babel-jest" };
    return [
      ...argv,
      "--transform",
      stringifyJSON$1(hookTransformObject(transform, root)),
    ];
  }
};

const name$4 = "jest";
const recursive$4 = null;

const doesSupport$6 = (tokens) => sniffTokens(tokens, "jest");

const hookCommandAsync$4 = async (tokens, self, base) => {
  const { exec, argv } = splitTokens(tokens);
  return [
    ...exec,
    ...(await hookJestArgvAsync(argv, base)),
    "--setupFilesAfterEnv",
    fileURLToPath(toAbsoluteUrl("lib/node/recorder.mjs", self)),
  ];
};

const hookEnvironment$4 = (env, self, _base) => ({
  ...env,
  NODE_OPTIONS: `${coalesce(
    env,
    "NODE_OPTIONS",
    "",
  )} --experimental-vm-modules --experimental-loader=${escapeNodeOption(
    toAbsoluteUrl("lib/node/loader-esm.mjs", self),
  )}`,
});

var JestRecorder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$4,
  recursive: recursive$4,
  doesSupport: doesSupport$6,
  hookCommandAsync: hookCommandAsync$4,
  hookEnvironment: hookEnvironment$4
});

const doesSupport$5 = (tokens) =>
  tokens.length > 0 && tokens[0].startsWith("node");

const splitNodeCommand = (tokens) => {
  assert(
    !logErrorWhen(
      !doesSupport$5(tokens),
      "Could not recognize %j as a node command",
      tokens,
    ),
    "Not a parsed node command",
    ExternalAppmapError,
  );
  return {
    exec: tokens.slice(0, 1),
    argv: tokens.slice(1),
  };
};

const generateNodeRecorder$1 = (recorder) => ({
  doesSupport: doesSupport$5,
  recursive: false,
  name: recorder,
  hookCommandAsync: (tokens, self, _base) => {
    const { exec, argv } = splitNodeCommand(tokens);
    return [
      ...exec,
      "--experimental-loader",
      toAbsoluteUrl(`lib/node/recorder.mjs`, self),
      ...argv,
    ];
  },
  hookEnvironment: (env, _self, _base) => env,
});

const {
  name: name$3,
  recursive: recursive$3,
  doesSupport: doesSupport$4,
  hookCommandAsync: hookCommandAsync$3,
  hookEnvironment: hookEnvironment$3,
} = generateNodeRecorder$1("process");

var ProcessRecorder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$3,
  recursive: recursive$3,
  doesSupport: doesSupport$4,
  hookCommandAsync: hookCommandAsync$3,
  hookEnvironment: hookEnvironment$3
});

const doesSupport$3 = constant(true);

const generateNodeRecorder = (recorder) => ({
  name: recorder,
  recursive: true,
  doesSupport: doesSupport$3,
  hookCommandAsync: (tokens, _self, _base) => tokens,
  hookEnvironment: (env, self, _base) => ({
    ...env,
    NODE_OPTIONS: `${coalesce(
      env,
      "NODE_OPTIONS",
      "",
    )} --experimental-loader=${escapeNodeOption(
      toAbsoluteUrl(`lib/node/recorder.mjs`, self),
    )}`,
  }),
});

const {
  name: name$2,
  recursive: recursive$2,
  doesSupport: doesSupport$2,
  hookCommandAsync: hookCommandAsync$2,
  hookEnvironment: hookEnvironment$2,
} = generateNodeRecorder("process");

var ProcessRecorderRecursive = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$2,
  recursive: recursive$2,
  doesSupport: doesSupport$2,
  hookCommandAsync: hookCommandAsync$2,
  hookEnvironment: hookEnvironment$2
});

const {
  name: name$1,
  recursive: recursive$1,
  doesSupport: doesSupport$1,
  hookCommandAsync: hookCommandAsync$1,
  hookEnvironment: hookEnvironment$1,
} = generateNodeRecorder$1("remote");

var RemoteRecorder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$1,
  recursive: recursive$1,
  doesSupport: doesSupport$1,
  hookCommandAsync: hookCommandAsync$1,
  hookEnvironment: hookEnvironment$1
});

const {
  name,
  recursive,
  doesSupport,
  hookCommandAsync,
  hookEnvironment,
} = generateNodeRecorder("remote");

var RemoteRecorderRecursive = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name,
  recursive: recursive,
  doesSupport: doesSupport,
  hookCommandAsync: hookCommandAsync,
  hookEnvironment: hookEnvironment
});

const Recorders = [
  MochaRecorder,
  JestRecorder,
  ProcessRecorder,
  ProcessRecorderRecursive,
  RemoteRecorder,
  RemoteRecorderRecursive,
];

const {
  JSON: { stringify: stringifyJSON },
} = globalThis;

const platform_command_key = `command-${platform$1}`;

const pickPlatformSpecificCommand = (configuration) => {
  if (
    hasOwnProperty(configuration, platform_command_key) &&
    configuration[platform_command_key] !== null
  ) {
    return {
      ...configuration,
      command: configuration[platform_command_key],
    };
  } else {
    return configuration;
  }
};

const resolveConfigurationAutomatedRecorder = (configuration, env) => {
  assert(
    configuration.command !== null,
    "missing command in configuration",
    InternalAppmapError,
  );
  let {
    "recursive-process-recording": recursive,
    recorder,
    command: { source, tokens },
    "command-options": options,
  } = configuration;
  logWarningWhen(
    tokens !== null && options.shell !== false,
    "Tokenized commands (%j) are directly spawned so the provided shell (%j) is a no-op",
    tokens,
    options.shell,
  );
  if (tokens === null) {
    assert(
      source !== "null",
      "either command.tokens or command.source should be defined",
      InternalAppmapError,
    );
    tokens = tokenize(source, resolveShell(options.shell, env));
  }
  if (recorder === null) {
    recorder = "process";
    for (const Recorder of Recorders) {
      if (Recorder.recursive === recursive || Recorder.recursive === null) {
        if (Recorder.doesSupport(tokens)) {
          recorder = Recorder.name;
          break;
        }
      }
    }
  }
  return extendConfiguration(
    configuration,
    {
      recorder,
      command: tokens,
      "command-options": {
        ...options,
        shell: false,
      },
    },
    configuration.repository.directory,
  );
};

const compileConfigurationCommandAsync = async (configuration, env) => {
  assert(
    configuration.agent !== null,
    "missing agent in configuration",
    InternalAppmapError,
  );
  assert(
    configuration.command !== null,
    "missing command in configuration",
    InternalAppmapError,
  );
  assert(
    configuration.command.tokens !== null,
    "command should have been tokenized",
    InternalAppmapError,
  );
  const {
    "recursive-process-recording": recursive,
    recorder,
    agent: { directory: self },
    command: { tokens },
    "command-options": options,
  } = configuration;
  env = {
    ...env,
    ...options.env,
    APPMAP_CONFIGURATION: stringifyJSON(configuration),
  };
  const { hookCommandAsync, hookEnvironment } = Recorders.find(
    ({ recursive: recorder_recursive, name }) =>
      (recorder_recursive === null || recorder_recursive === recursive) &&
      name === recorder,
  );
  const [exec, ...argv] = await hookCommandAsync(tokens, self, options.cwd);
  return {
    exec,
    argv,
    options: {
      ...options,
      env: hookEnvironment(env, self, options.cwd),
    },
  };
};

const { setTimeout, Promise: Promise$1, undefined: undefined$1, Error: Error$1 } = globalThis;

const { concat: concatBuffer } = Buffer;

const compileSig = (signal) => (child) => {
  child.kill(signal);
};

const sigint = compileSig("SIGINT");

const sigkill = compileSig("SIGKILL");

const killAllAsync = (children) =>
  new Promise$1((resolve, reject) => {
    children.forEach(sigint);
    setTimeout(() => {
      children.forEach(sigkill);
      setTimeout(() => {
        /* c8 ignore start */ if (children.size !== 0) {
          reject(new Error$1("Could not kill all spawn child processes in time"));
        } /* c8 ignore stop */ else {
          resolve(undefined$1);
        }
      }, 1000);
    }, 1000);
  });

const bufferReadable = (readable) => {
  const buffers = [];
  readable.on("data", (buffer) => {
    buffers.push(buffer);
  });
  return buffers;
};

const spawnAsync$1 = ({ exec, argv, options }, children) =>
  new Promise$1((resolve, reject) => {
    logDebug("Spawn %j %j %j", exec, argv, options);
    const child = spawn$1(exec, argv, {
      ...options,
      cwd:
        "cwd" in options
          ? fileURLToPath(toAbsoluteUrl(".", options.cwd))
          : cwd(),
    });
    const stdout =
      options.stdio === "pipe" ? bufferReadable(child.stdout) : null;
    const stderr =
      options.stdio === "pipe" ? bufferReadable(child.stderr) : null;
    child.on("error", (error) => {
      logDebug("Spawn failure %j %j >> %O", exec, argv, error);
      children.delete(child);
      reject(error);
    });
    child.on("close", (status, signal) => {
      logDebug(
        "Spawn success %j %j: signal = %j status = %j ",
        exec,
        argv,
        signal,
        status,
      );
      children.delete(child);
      resolve({
        status,
        signal,
        stdout:
          stdout === null
            ? null
            : concatBuffer(stdout).toString(options.encoding),
        stderr:
          stderr === null
            ? null
            : concatBuffer(stderr).toString(options.encoding),
      });
    });
    children.add(child);
  });

const { Error } = globalThis;

/* c8 ignore start */
const isNotEmptyString = (any) => any !== "";
/* c8 ignore stop */

const rankWin32Exec = (exec) => {
  if (exec.endsWith(".exe")) {
    return 2;
  } else if (exec.endsWith(".cmd")) {
    return 1;
  } else {
    return 0;
  }
};

const compareWin32Exec = (exec1, exec2) =>
  rankWin32Exec(exec2) - rankWin32Exec(exec1);

const pickWin32Exec = (execs) => {
  assert(
    execs.length > 0,
    "where succeed and returned an empty executable array",
    Error,
  );
  execs = execs.slice();
  execs.sort(compareWin32Exec);
  return execs[0];
};

/* c8 ignore start */
const whereAsync = async (exec, children) => {
  const { status, signal, stdout, stderr } = await spawnAsync$1(
    {
      exec: "where.exe",
      argv: [exec],
      options: {
        stdio: "pipe",
        encoding: "utf8",
      },
    },
    children,
  );
  assert(
    !logErrorWhen(
      status !== 0 || signal !== null,
      "Could not locate executable %j: %j >> %s",
      exec,
      { status, signal },
      stderr,
    ),
    "Could not locate executable",
    Error,
  );
  return pickWin32Exec(stdout.split("\r\n").filter(isNotEmptyString));
};
/* c8 ignore stop */

const spawnAsync = async (command, children) => {
  try {
    return await spawnAsync$1(command, children);
  } catch (error) {
    /* c8 ignore start */ if (
      hasOwnProperty(error, "code") &&
      error.code === "ENOENT" &&
      platform$1 === "win32"
    ) {
      logWarning(
        "Could not find executable %j, we will try to locate it using `where.exe`. Often, this is caused by a missing extension on Windows. For instance `npx jest` should be `npx.cmd jest`. Note that it is possible to provide a windows-specific command with `command-win32`.",
        command.exec,
      );
      return await spawnAsync$1(
        {
          ...command,
          exec: await whereAsync(command.exec, children),
        },
        children,
      );
    } /* c8 ignore stop */ else {
      throw error;
    }
  }
};

const { Set } = globalThis;

const mainAsync = async (process, configuration) => {
  const { env } = process;
  configuration = resolveConfigurationRepository(configuration);
  configuration = pickPlatformSpecificCommand(configuration);
  configuration = resolveConfigurationAutomatedRecorder(configuration, env);
  assert(
    !logErrorWhen(
      configuration.command === null,
      "Missing command to spawn child process",
    ),
    "Missing command to spawn child process",
    ExternalAppmapError,
  );
  const children = new Set();
  process.on("SIGINT", () => {
    killAllAsync(children);
  });
  const { signal, status } = await spawnAsync(
    await compileConfigurationCommandAsync(configuration, env),
    children,
  );
  return signal === null ? status : 1;
};

export { mainAsync };
